<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Tagger Pro v8</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #0a0a0a; }
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: #111; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    #drop-overlay { display: none; position: fixed; inset: 0; background: rgba(96,165,250,0.2); border: 4px dashed #60a5fa; z-index: 9999; align-items: center; justify-content: center; }
    #drop-overlay.active { display: flex; }
  </style>
</head>
<body>
  <div id="drop-overlay"><div style="background: rgba(0,0,0,0.9); padding: 32px 64px; border-radius: 16px; color: #60a5fa; font-size: 20px; font-family: system-ui;">üìÅ Drop images or folder here</div></div>
  <div id="root"></div>

  <script>
    const overlay = document.getElementById('drop-overlay');
    let dragCounter = 0;
    document.addEventListener('dragenter', (e) => { e.preventDefault(); dragCounter++; overlay.classList.add('active'); });
    document.addEventListener('dragleave', (e) => { e.preventDefault(); dragCounter--; if (dragCounter === 0) overlay.classList.remove('active'); });
    document.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
    document.addEventListener('drop', async (e) => {
      e.preventDefault(); dragCounter = 0; overlay.classList.remove('active');
      const files = await extractFiles(e.dataTransfer);
      if (files.length > 0 && window.onFilesDropped) window.onFilesDropped(files);
    });

    async function extractFiles(dataTransfer) {
      const files = [];
      async function processEntry(entry) {
        if (!entry) return;
        if (entry.isFile) {
          try {
            const file = await new Promise((resolve, reject) => entry.file(resolve, reject));
            if (file.type.startsWith('image/')) files.push(file);
          } catch (e) {}
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          let entries = [];
          while (true) {
            const batch = await new Promise((resolve) => reader.readEntries(resolve, () => resolve([])));
            if (batch.length === 0) break;
            entries = entries.concat(batch);
          }
          for (const e of entries) await processEntry(e);
        }
      }
      const items = dataTransfer.items;
      if (items?.length > 0) {
        for (let i = 0; i < items.length; i++) {
          const entry = items[i].webkitGetAsEntry?.();
          if (entry) await processEntry(entry);
        }
      }
      if (files.length === 0 && dataTransfer.files) {
        for (let i = 0; i < dataTransfer.files.length; i++) {
          if (dataTransfer.files[i].type.startsWith('image/')) files.push(dataTransfer.files[i]);
        }
      }
      return files;
    }
  </script>

  <!-- Load data and utilities (plain JS, no JSX) -->
  <script src="js/data.js"></script>
  <script src="js/utils.js"></script>
  <script src="js/api.js"></script>

  <script type="text/babel">
    const { useState, useRef, useEffect, useMemo, useCallback } = React;

    // Import from modules
    const { DEFAULT_TAXONOMY, ROOT_COLORS, STORAGE_KEY, TAXONOMY_KEY } = window.TaggerData;
    const {
      smartCategorize, addToTaxonomy, removeFromTaxonomy, flattenTaxonomy,
      getBrandPath, looksLikeBrand, parseEra, splitBrandModel, deduplicateKeywords,
      buildTree, countKeywords, hashFile, getBaseName, loadMemory, saveMemory,
      extractFromFilename, extractFromUrls, extractExistingMetadata, generateXMP,
      embedXMP, embedXMPinPNG, convertToJPEG, isRawFormat, supportsEmbedding
    } = window.TaggerUtils;
    const { analyzeWithGemini, findDesigner, categorizeKeywords, analyzeWithVision, downloadLargerVersion } = window.TaggerAPI;

    // ============================================
    // REACT COMPONENTS (must be in Babel block for JSX)
    // ============================================
    const TreeNode = ({ name, node, depth = 0, expanded, onToggle, onDeleteKeyword }) => {
      const children = node._children || {};
      const hasChildren = Object.keys(children).length > 0;
      const keywords = node._keywords || [];
      const count = countKeywords(node);
      const pathKey = node._path?.join('>');
      const isExpanded = expanded[pathKey] !== false;
      const color = ROOT_COLORS[node._path?.[0]] || '#94a3b8';

      return (
        <div style={{ marginLeft: depth > 0 ? 12 : 0 }}>
          <div onClick={() => (hasChildren || keywords.length > 0) && onToggle(pathKey)}
            style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '4px 6px', borderRadius: 4, cursor: 'pointer', background: depth === 0 ? 'rgba(255,255,255,0.03)' : 'transparent' }}>
            <span style={{ fontSize: 9, color: '#555', width: 10 }}>{(hasChildren || keywords.length > 0) ? (isExpanded ? '‚ñº' : '‚ñ∂') : ''}</span>
            {depth === 0 && <span style={{ width: 8, height: 8, borderRadius: 3, background: color }} />}
            <span style={{ flex: 1, color: depth === 0 ? '#e5e5e5' : '#aaa', fontSize: 11 }}>{name}</span>
            <span style={{ color: '#666', fontSize: 10 }}>{count}</span>
          </div>
          {isExpanded && keywords.length > 0 && (
            <div style={{ marginLeft: 20, marginTop: 4, display: 'flex', flexWrap: 'wrap', gap: 4 }}>
              {keywords.map(kw => (
                <span key={kw.id} style={{ padding: '2px 6px', background: `${color}20`, color, borderRadius: 3, fontSize: 10, display: 'flex', alignItems: 'center', gap: 4 }}>
                  {kw.value}
                  <span onClick={(e) => { e.stopPropagation(); onDeleteKeyword(kw.id); }} style={{ cursor: 'pointer', opacity: 0.5, fontSize: 8 }}>‚úï</span>
                </span>
              ))}
            </div>
          )}
          {isExpanded && hasChildren && Object.entries(children).map(([n, c]) => (
            <TreeNode key={n} name={n} node={c} depth={depth + 1} expanded={expanded} onToggle={onToggle} onDeleteKeyword={onDeleteKeyword} />
          ))}
        </div>
      );
    };

    const MasterTaxonomyNode = ({ name, value, path = [], depth = 0, expanded, onToggle, onDelete }) => {
      const currentPath = [...path, name];
      const pathKey = currentPath.join('>');
      const isExpanded = expanded[pathKey] !== false;
      const color = ROOT_COLORS[currentPath[0]] || '#94a3b8';

      let children = {};
      let items = [];
      if (Array.isArray(value)) {
        items = value;
      } else if (typeof value === 'object' && value !== null) {
        items = value._items || [];
        children = Object.fromEntries(Object.entries(value).filter(([k]) => k !== '_items'));
      }

      const hasChildren = Object.keys(children).length > 0;
      const hasItems = items.length > 0;
      const hasContent = hasChildren || hasItems;

      return (
        <div style={{ marginLeft: depth > 0 ? 12 : 0 }}>
          <div onClick={() => hasContent && onToggle(pathKey)}
            style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '4px 6px', borderRadius: 4, cursor: hasContent ? 'pointer' : 'default', background: depth === 0 ? 'rgba(255,255,255,0.03)' : 'transparent' }}>
            <span style={{ fontSize: 9, color: '#555', width: 10 }}>{hasContent ? (isExpanded ? '‚ñº' : '‚ñ∂') : ''}</span>
            {depth === 0 && <span style={{ width: 8, height: 8, borderRadius: 3, background: color }} />}
            <span style={{ flex: 1, color: depth === 0 ? '#e5e5e5' : '#aaa', fontSize: 11 }}>{name}</span>
          </div>
          {isExpanded && hasItems && (
            <div style={{ marginLeft: 20, marginTop: 4, display: 'flex', flexWrap: 'wrap', gap: 4 }}>
              {items.map((item, idx) => (
                <span key={`${pathKey}-${item}-${idx}`} style={{ padding: '2px 6px', background: `${color}20`, color, borderRadius: 3, fontSize: 10, display: 'flex', alignItems: 'center', gap: 4 }}>
                  {item}
                  <span onClick={(e) => { e.stopPropagation(); onDelete(currentPath, item); }} style={{ cursor: 'pointer', opacity: 0.5, fontSize: 8 }}>‚úï</span>
                </span>
              ))}
            </div>
          )}
          {isExpanded && hasChildren && Object.entries(children).map(([n, v]) => (
            <MasterTaxonomyNode key={n} name={n} value={v} path={currentPath} depth={depth + 1} expanded={expanded} onToggle={onToggle} onDelete={onDelete} />
          ))}
        </div>
      );
    };

    // ============================================
    // MAIN APP
    // ============================================
    function App() {
      const [geminiKey, setGeminiKey] = useState(localStorage.getItem('gemini_api_key') || '');
      const [visionKey, setVisionKey] = useState(localStorage.getItem('vision_api_key') || '');
      const [useVision, setUseVision] = useState(localStorage.getItem('use_vision') === 'true');
      const [autoDownloadLarger, setAutoDownloadLarger] = useState(localStorage.getItem('auto_download_larger') === 'true');
      const [showSettings, setShowSettings] = useState(false);
      const [saveMode, setSaveMode] = useState(localStorage.getItem('save_mode') || 'embed');
      const [outputDir, setOutputDir] = useState(null);
      const [thumbSize, setThumbSize] = useState(parseInt(localStorage.getItem('thumb_size')) || 1);

      const [taxonomy, setTaxonomy] = useState(() => {
        try { return JSON.parse(localStorage.getItem(TAXONOMY_KEY)) || DEFAULT_TAXONOMY; }
        catch { return DEFAULT_TAXONOMY; }
      });
      const taxInfo = useMemo(() => flattenTaxonomy(taxonomy), [taxonomy]);

      const [queue, setQueue] = useState([]);
      const [memory, setMemory] = useState(loadMemory);
      const [selectedId, setSelectedId] = useState(null);

      const [showDone, setShowDone] = useState(true);
      const [showHidden, setShowHidden] = useState(false);
      const [showPending, setShowPending] = useState(true);
      const [showMasterTaxonomy, setShowMasterTaxonomy] = useState(false);

      const [pending, setPending] = useState([]);
      const [keywords, setKeywords] = useState([]);
      const [ignored, setIgnored] = useState([]);
      const [designer, setDesigner] = useState(null);
      const [modified, setModified] = useState(false);
      const [visionData, setVisionData] = useState(null);
      const [downloadedLarger, setDownloadedLarger] = useState(null);
      const [isEditing, setIsEditing] = useState(false);

      const [accepted, setAccepted] = useState([]);
      const [blocked, setBlocked] = useState([]);
      const [expanded, setExpanded] = useState({});
      const [customInput, setCustomInput] = useState('');
      const [isCategorizing, setIsCategorizing] = useState(false);

      const fileRef = useRef(null);
      const folderRef = useRef(null);
      const acceptedRef = useRef(new Set());
      const blockedRef = useRef(new Set());
      const containerRef = useRef(null);

      useEffect(() => { acceptedRef.current = new Set(accepted.map(k => k.value.toLowerCase())); }, [accepted]);
      useEffect(() => { blockedRef.current = new Set(blocked.map(k => k.value.toLowerCase())); }, [blocked]);

      const selectedImg = queue.find(q => q.id === selectedId);

      const filteredQueue = useMemo(() => {
        return queue.filter(q => {
          if (q.hidden && !showHidden) return false;
          if (q.status === 'done' && !showDone) return false;
          if ((q.status === 'pending' || q.status === 'analyzing') && !showPending) return false;
          return true;
        });
      }, [queue, showDone, showHidden, showPending]);

      const findPath = useCallback((kwValue, kwType = 'keyword') => {
        const key = kwValue.toLowerCase().trim();
        if (taxInfo.paths[key]) return taxInfo.paths[key];
        return smartCategorize({ value: kwValue, type: kwType });
      }, [taxInfo]);

      // Keyboard navigation
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const currentIndex = filteredQueue.findIndex(q => q.id === selectedId);
            let newIndex = currentIndex;

            if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
              newIndex = currentIndex < filteredQueue.length - 1 ? currentIndex + 1 : 0;
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
              newIndex = currentIndex > 0 ? currentIndex - 1 : filteredQueue.length - 1;
            }

            if (filteredQueue[newIndex]) {
              selectImage(filteredQueue[newIndex].id);
            }
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [filteredQueue, selectedId]);

      // Save settings
      useEffect(() => {
        if (geminiKey) localStorage.setItem('gemini_api_key', geminiKey);
        if (visionKey) localStorage.setItem('vision_api_key', visionKey);
        localStorage.setItem('use_vision', useVision.toString());
        localStorage.setItem('auto_download_larger', autoDownloadLarger.toString());
        localStorage.setItem('save_mode', saveMode);
        localStorage.setItem('thumb_size', thumbSize.toString());
      }, [geminiKey, visionKey, useVision, autoDownloadLarger, saveMode, thumbSize]);

      useEffect(() => { saveMemory(memory); }, [memory]);
      useEffect(() => { localStorage.setItem(TAXONOMY_KEY, JSON.stringify(taxonomy)); }, [taxonomy]);

      const queueRef = useRef(queue);
      const memoryRef = useRef(memory);
      useEffect(() => { queueRef.current = queue; }, [queue]);
      useEffect(() => { memoryRef.current = memory; }, [memory]);

      useEffect(() => {
        window.onFilesDropped = async (files) => { await processFilesRef.current(files); };
        return () => { window.onFilesDropped = null; };
      }, []);

      const processFilesRef = useRef(null);
      processFilesRef.current = async (files) => {
        const imgs = files.filter(f => f.type.startsWith('image/'));
        if (!imgs.length) return;

        const currentMemory = memoryRef.current;
        const newItems = await Promise.all(imgs.map(async (file) => {
          const hash = await hashFile(file);
          const mem = currentMemory[hash];
          const filenameKws = extractFromFilename(file.name);
          const existingKws = await extractExistingMetadata(file);

          return {
            id: hash, name: file.name, file, url: URL.createObjectURL(file),
            baseName: getBaseName(file.name),
            status: mem?.exported ? 'done' : 'pending',
            hidden: mem?.hidden || false,
            keywords: mem?.keywords || [], pending: [],
            filenameKeywords: filenameKws,
            existingKeywords: existingKws,
            creator: mem?.creator || null, hash
          };
        }));

        const existingIds = new Set(queueRef.current.map(q => q.id));
        const uniqueItems = newItems.filter(item => !existingIds.has(item.id));
        if (uniqueItems.length > 0) setQueue(prev => [...prev, ...uniqueItems]);
      };

      const handleFileInput = (e) => {
        if (e.target.files?.length) processFilesRef.current(Array.from(e.target.files));
        e.target.value = '';
      };

      // Find similar images by base name
      const getSimilarImages = useCallback((img) => {
        if (!img) return [];
        const similar = queue.filter(q =>
          q.id !== img.id &&
          q.baseName === img.baseName
        );
        if (similar.length > 0) {
          console.log(`[SIMILAR] Found ${similar.length} similar to "${img.name}" (baseName: "${img.baseName}"):`, similar.map(s => s.name));
        }
        return similar;
      }, [queue]);

      // Sync keywords to similar images and auto-save
      const syncToSimilarAndSave = useCallback(async (sourceImg, sourceKeywords, sourceDesigner) => {
        const similar = getSimilarImages(sourceImg);
        if (similar.length === 0) return;

        console.log(`[SYNC] Syncing ${sourceKeywords.length} keywords to ${similar.length} similar images`);

        for (const img of similar) {
          const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
          const newKws = sourceKeywords
            .filter(k => !existingVals.has(k.value.toLowerCase()))
            .map(k => ({ ...k, id: `sync-${Math.random().toString(36).slice(2)}` }));

          if (newKws.length > 0) {
            const updatedKeywords = [...(img.keywords || []), ...newKws];

            // Update queue
            setQueue(q => q.map(i => i.id === img.id ? {
              ...i,
              keywords: updatedKeywords,
              designer: sourceDesigner,
              status: 'done'
            } : i));

            // Save to memory
            setMemory(prev => ({
              ...prev,
              [img.hash]: { exported: true, keywords: updatedKeywords, creator: sourceDesigner?.designer, hidden: img.hidden }
            }));

            // Save file if output dir set
            if (outputDir) {
              try {
                let blob, filename = img.name;
                const creator = sourceDesigner?.designer || null;
                const isRaw = isRawFormat(img.name);
                const canEmbed = supportsEmbedding(img.file);

                if (saveMode === 'embed' && img.file.type.includes('jpeg')) {
                  blob = await embedXMP(img.file, updatedKeywords, creator);
                } else if (saveMode === 'embed' && img.file.type.includes('png')) {
                  blob = await embedXMPinPNG(img.file, updatedKeywords, creator);
                } else if (saveMode === 'embed' && !canEmbed && !isRaw) {
                  // Convert WebP/AVIF to JPEG
                  const jpegBlob = await convertToJPEG(img.file);
                  const jpegFile = new File([jpegBlob], 'temp.jpg', { type: 'image/jpeg' });
                  blob = await embedXMP(jpegFile, updatedKeywords, creator);
                  filename = filename.replace(/\.[^.]+$/, '.jpg');
                } else {
                  blob = new Blob([generateXMP(updatedKeywords, creator)], { type: 'application/rdf+xml' });
                  filename = filename.replace(/\.[^.]+$/, '') + '.xmp';
                }

                const fh = await outputDir.getFileHandle(filename, { create: true });
                const w = await fh.createWritable();
                await w.write(blob);
                await w.close();
                console.log(`[SYNC] Auto-saved: ${filename}`);

                // Copy raw file alongside XMP
                if (isRaw) {
                  const rawFh = await outputDir.getFileHandle(img.name, { create: true });
                  const rawW = await rawFh.createWritable();
                  await rawW.write(img.file);
                  await rawW.close();
                  console.log(`[SYNC] Copied raw: ${img.name}`);
                }
              } catch (e) {
                console.error('[SYNC] Save failed:', e);
              }
            }
          }
        }
      }, [queue, outputDir, saveMode, getSimilarImages]);

      // Save image - defined before selectImage to avoid stale reference
      const saveImage = useCallback(async (img, kws, des) => {
        if (!img || !kws || kws.length === 0) {
          console.log('[SAVE] Skipped - no image or keywords');
          return;
        }
        console.log('[SAVE] Saving:', img.name, 'with', kws.length, 'keywords');
        try {
          let blob, filename = img.name;
          const creator = des?.designer || null;
          const isRaw = isRawFormat(img.name);
          const canEmbed = supportsEmbedding(img.file);

          if (saveMode === 'embed' && img.file.type.includes('jpeg')) {
            blob = await embedXMP(img.file, kws, creator);
          } else if (saveMode === 'embed' && img.file.type.includes('png')) {
            blob = await embedXMPinPNG(img.file, kws, creator);
          } else if (saveMode === 'embed' && !canEmbed && !isRaw) {
            console.log('[SAVE] Converting to JPEG:', img.name);
            const jpegBlob = await convertToJPEG(img.file);
            const jpegFile = new File([jpegBlob], 'temp.jpg', { type: 'image/jpeg' });
            blob = await embedXMP(jpegFile, kws, creator);
            filename = filename.replace(/\.[^.]+$/, '.jpg');
          } else {
            blob = new Blob([generateXMP(kws, creator)], { type: 'application/rdf+xml' });
            filename = filename.replace(/\.[^.]+$/, '') + '.xmp';
          }

          const saveFile = async (data, name) => {
            if (outputDir) {
              const fh = await outputDir.getFileHandle(name, { create: true });
              const w = await fh.createWritable();
              await w.write(data);
              await w.close();
              console.log('[SAVE] Saved:', name);
            } else {
              const url = URL.createObjectURL(data);
              Object.assign(document.createElement('a'), { href: url, download: name }).click();
              URL.revokeObjectURL(url);
              console.log('[SAVE] Downloaded:', name);
            }
          };

          await saveFile(blob, filename);

          if (isRaw && outputDir) {
            await saveFile(img.file, img.name);
            console.log('[SAVE] Copied raw file:', img.name);
          }

          setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'done', keywords: kws } : i));
          setMemory(prev => ({ ...prev, [img.hash]: { exported: true, keywords: kws, creator, hidden: img.hidden } }));
          setModified(false);
          setIsEditing(false);

          await syncToSimilarAndSave(img, kws, des);
        } catch (e) { console.error('[SAVE] Failed:', e); }
      }, [saveMode, outputDir, syncToSimilarAndSave]);

      // Analysis
      const analyzeImage = useCallback(async (img) => {
        if (!geminiKey || img.status === 'analyzing' || img.status === 'ready' || img.status === 'done') return;

        setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'analyzing' } : i));
        setDownloadedLarger(null);

        try {
          const base64 = await new Promise((res, rej) => {
            const r = new FileReader();
            r.onload = () => res(r.result.split(',')[1]);
            r.onerror = rej;
            r.readAsDataURL(img.file);
          });

          const contextParts = [];
          if (img.filenameKeywords?.length) {
            contextParts.push(`Filename suggests: ${img.filenameKeywords.map(k => k.value).join(', ')}`);
          }
          if (img.existingKeywords?.length) {
            contextParts.push(`Existing tags: ${img.existingKeywords.map(k => k.value).join(', ')}`);
          }

          let rawKws = await analyzeWithGemini(geminiKey, base64, img.file.type, contextParts.join('. '));

          if (img.filenameKeywords) rawKws = [...img.filenameKeywords, ...rawKws];
          if (img.existingKeywords) rawKws = [...img.existingKeywords, ...rawKws];

          let visionResult = null;
          if (useVision && visionKey) {
            visionResult = await analyzeWithVision(visionKey, base64);
            if (visionResult?.keywords) {
              visionResult.keywords.forEach(vk => {
                if (!rawKws.some(k => k.value.toLowerCase() === vk.value.toLowerCase())) {
                  rawKws.push(vk);
                }
              });
            }

            if (autoDownloadLarger && visionResult?.matchingImages?.length > 0 && outputDir) {
              const fullMatch = visionResult.matchingImages.find(m => m.type === 'full');
              if (fullMatch) {
                const larger = await downloadLargerVersion(fullMatch.url, img.name);
                if (larger && larger.size > img.file.size) {
                  try {
                    const fh = await outputDir.getFileHandle(larger.filename, { create: true });
                    const w = await fh.createWritable();
                    await w.write(larger.blob);
                    await w.close();
                    setDownloadedLarger({ filename: larger.filename, size: larger.size });
                    console.log('[DOWNLOAD] Saved:', larger.filename);
                  } catch (e) {}
                }
              }
            }
          }

          let processedKws = [];
          const brandFound = [], modelFound = [];

          rawKws.forEach(k => {
            splitBrandModel(k.value).forEach(part => {
              let path = part.path;
              if (part.path[0] === 'Custom' || part.type === 'keyword') {
                path = findPath(part.value, part.type);
              }
              const kw = {
                id: `${img.id}-${Math.random().toString(36).slice(2)}`,
                value: part.value, confidence: k.confidence || 0.8,
                type: part.type, path: path, rootCategory: path[0],
                source: k.source || 'gemini'
              };
              if (part.type === 'brand') brandFound.push(kw);
              else if (part.type === 'model') modelFound.push(kw);
              processedKws.push(kw);
            });
          });

          processedKws = deduplicateKeywords(processedKws);

          let designerInfo = null;
          if (brandFound.length > 0 && modelFound.length > 0) {
            designerInfo = await findDesigner(geminiKey, `${brandFound[0].value} ${modelFound[0].value}`);
            if (designerInfo?.designers && designerInfo.designers.length > 0) {
              designerInfo.designers.forEach(name => {
                const designerPath = smartCategorize({ value: name, type: 'designer' });
                processedKws.push({
                  id: `designer-${Math.random().toString(36).slice(2)}`,
                  value: name, confidence: 0.8,
                  type: 'designer', path: designerPath, rootCategory: 'Creator'
                });
              });
            } else if (designerInfo?.designer) {
              const designerPath = smartCategorize({ value: designerInfo.designer, type: 'designer' });
              processedKws.push({
                id: `designer-${Math.random().toString(36).slice(2)}`,
                value: designerInfo.designer, confidence: 0.8,
                type: 'designer', path: designerPath, rootCategory: 'Creator'
              });
            }
          }

          const currentBlocked = blockedRef.current;
          const currentAccepted = acceptedRef.current;
          const auto = [], review = [];

          console.log(`[ANALYZE] Master taxonomy has ${taxInfo.allTerms.size} terms, session has ${currentAccepted.size} accepted`);

          processedKws.forEach(kw => {
            const key = kw.value.toLowerCase();
            if (currentBlocked.has(key)) {
              console.log(`[ANALYZE] Blocked: "${kw.value}"`);
              return;
            }
            const inMaster = taxInfo.allTerms.has(key);
            const inSession = currentAccepted.has(key);
            const isDesigner = kw.type === 'designer' || kw.rootCategory === 'Creator';
            const isBrand = kw.type === 'brand' || kw.rootCategory === 'Brand';
            const isEra = kw.type === 'era' || kw.rootCategory === 'Era' || /^\d{4}s$/.test(kw.value);
            const knownCountries = ['Germany', 'Italy', 'Japan', 'Denmark', 'Sweden', 'United States', 'United Kingdom', 'France', 'Switzerland', 'Finland', 'Netherlands', 'Norway', 'Austria', 'Belgium', 'Spain', 'Portugal', 'Brazil', 'Mexico', 'Canada', 'Australia', 'China', 'South Korea', 'India', 'Russia', 'Poland', 'Czech Republic', 'Hungary', 'Greece', 'Turkey', 'Israel', 'South Africa', 'Argentina', 'Chile', 'Colombia', 'Iceland', 'Ireland', 'Scotland', 'Wales', 'USA', 'UK'];
            const isCountry = kw.type === 'country' || (kw.path && kw.path.includes('Origin')) || knownCountries.some(c => c.toLowerCase() === kw.value.toLowerCase());
            const isModel = kw.type === 'model' || kw.rootCategory === 'Product';
            if (inMaster || inSession || isDesigner || isBrand || isEra || isCountry || isModel) {
              if (isCountry && (!kw.path || !kw.path.includes('Origin'))) {
                kw.path = ['Style', 'Origin'];
                kw.rootCategory = 'Style';
                kw.type = 'country';
              }
              console.log(`[ANALYZE] Auto-accept: "${kw.value}" (master: ${inMaster}, session: ${inSession}, designer: ${isDesigner}, brand: ${isBrand}, era: ${isEra}, country: ${isCountry}, model: ${isModel})`);
              auto.push(kw);
            } else {
              review.push(kw);
            }
          });

          console.log(`[ANALYZE] Result: ${auto.length} auto-accepted, ${review.length} for review`);

          setQueue(q => q.map(i => i.id === img.id ? {
            ...i, status: 'ready', keywords: auto, pending: review,
            designer: designerInfo, visionData: visionResult
          } : i));

          if (auto.length) {
            setAccepted(prev => {
              const updated = [...prev];
              auto.forEach(kw => {
                if (!updated.some(a => a.value.toLowerCase() === kw.value.toLowerCase())) updated.push(kw);
              });
              return updated;
            });
          }
        } catch (err) {
          console.error('[ANALYZE] Failed:', err);
          setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'error' } : i));
        }
      }, [geminiKey, visionKey, useVision, autoDownloadLarger, outputDir, taxInfo, findPath]);

      const selectImage = useCallback(async (id) => {
        if (isEditing && selectedImg && keywords.length > 0) {
          console.log('[NAV] Auto-saving before navigation:', selectedImg.name);
          await saveImage(selectedImg, keywords, designer);
        }

        const img = queue.find(q => q.id === id);
        if (!img) return;

        setSelectedId(id);
        setDownloadedLarger(null);
        setIsEditing(false);

        if (img.status === 'ready' || img.status === 'done' || img.status === 'editing') {
          setKeywords(img.keywords || []);
          setPending(img.pending || []);
          setDesigner(img.designer || null);
          setVisionData(img.visionData || null);
          setIgnored([]);
          setModified(false);
        } else if (img.status === 'pending') {
          setKeywords([]); setPending([]); setDesigner(null); setVisionData(null); setIgnored([]); setModified(false);
          analyzeImage(img);
        } else {
          setKeywords([]); setPending([]); setDesigner(null); setVisionData(null); setIgnored([]); setModified(false);
        }
      }, [queue, isEditing, selectedImg, keywords, designer, analyzeImage, saveImage]);

      const analyzeAllPending = () => {
        filteredQueue.filter(q => q.status === 'pending').forEach(img => analyzeImage(img));
      };

      const [isSavingAll, setIsSavingAll] = useState(false);
      const saveAll = async () => {
        if (isSavingAll) return;
        const toSave = queue.filter(q => !q.hidden && (q.status === 'ready' || q.status === 'editing') && q.keywords?.length > 0);
        if (toSave.length === 0) return;

        setIsSavingAll(true);
        console.log(`[SAVE ALL] Saving ${toSave.length} images...`);

        for (const img of toSave) {
          try {
            await saveImage(img, img.keywords, img.designer);
          } catch (e) {
            console.error(`[SAVE ALL] Failed to save ${img.name}:`, e);
          }
        }

        setIsSavingAll(false);
        console.log('[SAVE ALL] Done!');
      };

      const readyToSaveCount = queue.filter(q => !q.hidden && (q.status === 'ready' || q.status === 'editing') && q.keywords?.length > 0).length;

      const hideImage = (id, e) => {
        e?.stopPropagation();
        setQueue(q => q.map(i => {
          if (i.id === id) {
            setMemory(prev => ({ ...prev, [i.hash]: { ...prev[i.hash], hidden: true } }));
            return { ...i, hidden: true };
          }
          return i;
        }));
        if (selectedId === id) setSelectedId(null);
      };

      const unhideImage = (id, e) => {
        e?.stopPropagation();
        setQueue(q => q.map(i => {
          if (i.id === id) {
            setMemory(prev => ({ ...prev, [i.hash]: { ...prev[i.hash], hidden: false } }));
            return { ...i, hidden: false };
          }
          return i;
        }));
      };

      const accept = (id) => {
        const kw = pending.find(k => k.id === id);
        if (kw) {
          console.log(`[ACCEPT] Accepting keyword: "${kw.value}"`);
          setPending(p => p.filter(k => k.id !== id));
          const newKeywords = [...keywords, kw];
          setKeywords(newKeywords);
          setAccepted(a => a.some(x => x.value.toLowerCase() === kw.value.toLowerCase()) ? a : [...a, kw]);
          setTaxonomy(t => addToTaxonomy(t, kw));
          setModified(true);
          setIsEditing(true);

          if (selectedImg) {
            const similar = getSimilarImages(selectedImg);
            console.log(`[ACCEPT] Similar images for sync:`, similar.length);
            if (similar.length > 0) {
              setQueue(q => q.map(img => {
                if (similar.some(s => s.id === img.id)) {
                  const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                  if (!existingVals.has(kw.value.toLowerCase())) {
                    console.log(`[ACCEPT] Syncing "${kw.value}" to "${img.name}"`);
                    const syncedKw = { ...kw, id: `sync-${Math.random().toString(36).slice(2)}` };
                    return { ...img, keywords: [...(img.keywords || []), syncedKw], status: img.status === 'pending' ? 'ready' : img.status };
                  }
                }
                return img;
              }));
            }
          }
        }
      };

      const block = (id) => {
        const kw = pending.find(k => k.id === id) || ignored.find(k => k.id === id);
        if (kw) {
          setPending(p => p.filter(k => k.id !== id));
          setIgnored(i => i.filter(k => k.id !== id));
          setBlocked(b => [...b, kw]);
          setModified(true);
          setIsEditing(true);
        }
      };

      const ignore = (id) => {
        const kw = pending.find(k => k.id === id);
        if (kw) {
          setPending(p => p.filter(k => k.id !== id));
          setIgnored(i => [...i, kw]);
          setModified(true);
          setIsEditing(true);
        }
      };

      const acceptIgnored = (id) => {
        const kw = ignored.find(k => k.id === id);
        if (kw) {
          setIgnored(i => i.filter(k => k.id !== id));
          const newKeywords = [...keywords, kw];
          setKeywords(newKeywords);
          setAccepted(a => a.some(x => x.value.toLowerCase() === kw.value.toLowerCase()) ? a : [...a, kw]);
          setModified(true);
          setIsEditing(true);

          if (selectedImg) {
            const similar = getSimilarImages(selectedImg);
            if (similar.length > 0) {
              setQueue(q => q.map(img => {
                if (similar.some(s => s.id === img.id)) {
                  const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                  if (!existingVals.has(kw.value.toLowerCase())) {
                    const syncedKw = { ...kw, id: `sync-${Math.random().toString(36).slice(2)}` };
                    return { ...img, keywords: [...(img.keywords || []), syncedKw], status: img.status === 'pending' ? 'ready' : img.status };
                  }
                }
                return img;
              }));
            }
          }
        }
      };

      const acceptAll = () => {
        const newKeywords = [...keywords, ...pending];
        pending.forEach(kw => {
          setAccepted(a => a.some(x => x.value.toLowerCase() === kw.value.toLowerCase()) ? a : [...a, kw]);
        });
        setKeywords(newKeywords);
        setPending([]);
        setModified(true);
        setIsEditing(true);

        if (selectedImg) {
          const similar = getSimilarImages(selectedImg);
          if (similar.length > 0) {
            setQueue(q => q.map(img => {
              if (similar.some(s => s.id === img.id)) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                const newKws = pending
                  .filter(kw => !existingVals.has(kw.value.toLowerCase()))
                  .map(kw => ({ ...kw, id: `sync-${Math.random().toString(36).slice(2)}` }));
                if (newKws.length > 0) {
                  return { ...img, keywords: [...(img.keywords || []), ...newKws], status: img.status === 'pending' ? 'ready' : img.status };
                }
              }
              return img;
            }));
          }
        }
      };

      const removeKw = (id) => {
        setKeywords(c => c.filter(k => k.id !== id));
        setModified(true);
        setIsEditing(true);
      };

      const deleteFromTaxonomy = (id) => {
        setAccepted(a => a.filter(k => k.id !== id));
      };

      const deleteFromMasterTaxonomy = (path, value) => {
        setTaxonomy(prevTax => {
          const newTax = JSON.parse(JSON.stringify(prevTax));
          let current = newTax;

          for (let i = 0; i < path.length - 1; i++) {
            if (!current[path[i]]) return prevTax;
            current = current[path[i]];
          }

          const leafKey = path[path.length - 1];
          if (Array.isArray(current[leafKey])) {
            current[leafKey] = current[leafKey].filter(v => v.toLowerCase() !== value.toLowerCase());
          } else if (current[leafKey]?._items) {
            current[leafKey]._items = current[leafKey]._items.filter(v => v.toLowerCase() !== value.toLowerCase());
          }
          return newTax;
        });
      };

      const addCustom = () => {
        const val = customInput.trim();
        if (!val) return;
        const newKws = [];
        splitBrandModel(val).forEach(part => {
          const path = part.path[0] === 'Custom' ? findPath(part.value, part.type) : part.path;
          const kw = { id: `custom-${Date.now()}-${Math.random().toString(36).slice(2)}`, value: part.value, confidence: 1, type: part.type, path, rootCategory: path[0] };
          newKws.push(kw);
          setKeywords(c => [...c, kw]);
          setAccepted(a => a.some(x => x.value.toLowerCase() === kw.value.toLowerCase()) ? a : [...a, kw]);
          setTaxonomy(t => addToTaxonomy(t, kw));
        });
        setCustomInput('');
        setModified(true);
        setIsEditing(true);

        if (selectedImg && newKws.length > 0) {
          const similar = getSimilarImages(selectedImg);
          if (similar.length > 0) {
            setQueue(q => q.map(img => {
              if (similar.some(s => s.id === img.id)) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                const syncKws = newKws
                  .filter(kw => !existingVals.has(kw.value.toLowerCase()))
                  .map(kw => ({ ...kw, id: `sync-${Math.random().toString(36).slice(2)}` }));
                if (syncKws.length > 0) {
                  return { ...img, keywords: [...(img.keywords || []), ...syncKws], status: img.status === 'pending' ? 'ready' : img.status };
                }
              }
              return img;
            }));
          }
        }
      };

      useEffect(() => {
        if (selectedImg && (selectedImg.status === 'ready' || selectedImg.status === 'done') && !modified && !isEditing) {
          setKeywords(selectedImg.keywords || []);
          setPending(selectedImg.pending || []);
          setDesigner(selectedImg.designer || null);
          setVisionData(selectedImg.visionData || null);
        }
      }, [selectedImg?.id, selectedImg?.status]);

      const getCustomKeywords = useCallback(() => {
        const customs = [];
        const collectCustom = (obj, path = []) => {
          for (const [key, value] of Object.entries(obj)) {
            if (key === '_items') continue;
            const currentPath = [...path, key];
            if (key === 'Custom' && Array.isArray(value)) {
              customs.push(...value);
            } else if (key === 'Custom' && value?._items) {
              customs.push(...value._items);
            } else if (typeof value === 'object' && value !== null) {
              collectCustom(value, currentPath);
            }
          }
        };
        collectCustom(taxonomy);
        return customs;
      }, [taxonomy]);

      const runCategorization = async () => {
        if (!geminiKey || isCategorizing) return;

        const customKws = getCustomKeywords();
        if (customKws.length === 0) {
          console.log('[CATEGORIZE] No custom keywords to categorize');
          return;
        }

        setIsCategorizing(true);
        console.log(`[CATEGORIZE] Categorizing ${customKws.length} custom keywords...`);

        try {
          const batchSize = 20;
          for (let i = 0; i < customKws.length; i += batchSize) {
            const batch = customKws.slice(i, i + batchSize);
            const results = await categorizeKeywords(geminiKey, batch);

            if (results.length > 0) {
              setTaxonomy(prevTax => {
                let newTax = JSON.parse(JSON.stringify(prevTax));

                results.forEach(result => {
                  if (!result.path || result.path.length === 0 || result.path[0] === 'Custom') return;

                  if (Array.isArray(newTax.Custom)) {
                    newTax.Custom = newTax.Custom.filter(k => k.toLowerCase() !== result.keyword.toLowerCase());
                  } else if (newTax.Custom?._items) {
                    newTax.Custom._items = newTax.Custom._items.filter(k => k.toLowerCase() !== result.keyword.toLowerCase());
                  }

                  let current = newTax;
                  for (let j = 0; j < result.path.length; j++) {
                    const key = result.path[j];
                    if (j === result.path.length - 1) {
                      if (Array.isArray(current[key])) {
                        if (!current[key].some(k => k.toLowerCase() === result.keyword.toLowerCase())) {
                          current[key].push(result.keyword);
                        }
                      } else if (typeof current[key] === 'object' && current[key] !== null) {
                        if (!current[key]._items) current[key]._items = [];
                        if (!current[key]._items.some(k => k.toLowerCase() === result.keyword.toLowerCase())) {
                          current[key]._items.push(result.keyword);
                        }
                      } else if (current[key] === undefined) {
                        current[key] = [result.keyword];
                      }
                    } else {
                      if (current[key] === undefined) {
                        current[key] = {};
                      } else if (Array.isArray(current[key])) {
                        current[key] = { _items: current[key] };
                      }
                      current = current[key];
                    }
                  }

                  console.log(`[CATEGORIZE] Moved "${result.keyword}" to ${result.path.join(' > ')}`);
                });

                return newTax;
              });
            }
          }
          console.log('[CATEGORIZE] Done!');
        } catch (e) {
          console.error('[CATEGORIZE] Error:', e);
        } finally {
          setIsCategorizing(false);
        }
      };

      const customCount = getCustomKeywords().length;

      const tree = buildTree(accepted);
      const getColor = (r) => ROOT_COLORS[r] || '#94a3b8';

      const totalCount = queue.length;
      const hiddenCount = queue.filter(q => q.hidden).length;
      const doneCount = queue.filter(q => q.status === 'done').length;
      const readyCount = queue.filter(q => (q.status === 'ready' || q.status === 'editing') && !q.hidden).length;
      const analyzingCount = queue.filter(q => q.status === 'analyzing').length;
      const pendingCount = queue.filter(q => q.status === 'pending' && !q.hidden).length;
      const editingCount = queue.filter(q => q.status === 'editing' && !q.hidden).length;
      const similarCount = selectedImg ? getSimilarImages(selectedImg).length : 0;

      const thumbSizes = [60, 90, 130, 180];
      const currentThumbSize = thumbSizes[thumbSize];

      const s = { bg: '#0a0a0a', panel: '#111', border: '#1a1a1a', text: '#888', bright: '#e5e5e5' };

      return (
        <div ref={containerRef} tabIndex={0} style={{ display: 'flex', flexDirection: 'column', height: '100vh', width: '100vw', font: '11px/1.4 -apple-system, sans-serif', background: s.bg, color: s.text, outline: 'none' }}>
          <input ref={fileRef} type="file" accept="image/*" multiple onChange={handleFileInput} style={{ display: 'none' }} />
          <input ref={folderRef} type="file" accept="image/*" multiple webkitdirectory="" onChange={handleFileInput} style={{ display: 'none' }} />

          {/* TOOLBAR */}
          <div style={{ height: 40, background: s.panel, display: 'flex', alignItems: 'center', padding: '0 12px', gap: 10, borderBottom: `1px solid ${s.border}`, flexShrink: 0 }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
              <div style={{ width: 16, height: 16, background: 'linear-gradient(135deg, #8b5cf6, #3b82f6)', borderRadius: 3 }} />
              <span style={{ color: s.bright, fontWeight: 600, fontSize: 12 }}>Tagger v8</span>
            </div>
            <span style={{ color: '#333' }}>|</span>
            <span style={{ color: '#666', fontSize: 10 }}>
              {filteredQueue.length}/{totalCount}
              {analyzingCount > 0 && <span style={{ color: '#fbbf24' }}> ‚Ä¢ {analyzingCount} ‚è≥</span>}
              {readyCount > 0 && <span style={{ color: '#60a5fa' }}> ‚Ä¢ {readyCount} ready</span>}
            </span>

            <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: 8 }}>
              {pendingCount > 0 && (
                <button onClick={analyzeAllPending} style={{ padding: '4px 10px', background: '#2563eb', color: 'white', border: 'none', borderRadius: 3, cursor: 'pointer', fontSize: 10 }}>
                  Analyze All ({pendingCount})
                </button>
              )}
              {readyToSaveCount > 0 && (
                <button onClick={saveAll} disabled={isSavingAll} style={{ padding: '4px 10px', background: isSavingAll ? '#444' : '#4ade80', color: isSavingAll ? '#888' : '#000', border: 'none', borderRadius: 3, cursor: isSavingAll ? 'default' : 'pointer', fontSize: 10, fontWeight: 500 }}>
                  {isSavingAll ? '‚è≥ Saving...' : `üíæ Save All (${readyToSaveCount})`}
                </button>
              )}
              <button onClick={() => fileRef.current?.click()} style={{ padding: '4px 10px', background: '#222', color: s.text, border: 'none', borderRadius: 3, cursor: 'pointer', fontSize: 10 }}>+ Files</button>
              <button onClick={() => folderRef.current?.click()} style={{ padding: '4px 10px', background: '#222', color: s.text, border: 'none', borderRadius: 3, cursor: 'pointer', fontSize: 10 }}>+ Folder</button>
              {outputDir && <span style={{ color: '#4ade80', fontSize: 10 }}>‚óè Auto</span>}
              <button onClick={() => setShowSettings(true)} style={{ padding: '4px 8px', background: 'transparent', color: '#666', border: 'none', cursor: 'pointer', fontSize: 12 }}>‚öô</button>
            </div>
          </div>

          {/* MAIN */}
          <div style={{ flex: 1, display: 'flex', overflow: 'hidden', width: '100%' }}>

            {/* LEFT - GRID */}
            <div style={{ flex: 1, minWidth: 300, background: s.panel, borderRight: `1px solid ${s.border}`, display: 'flex', flexDirection: 'column' }}>
              <div style={{ padding: 8, borderBottom: `1px solid ${s.border}`, display: 'flex', gap: 4, alignItems: 'center', flexWrap: 'wrap' }}>
                <button onClick={() => setShowPending(!showPending)}
                  style={{ padding: '3px 8px', background: showPending ? 'rgba(251,191,36,0.15)' : '#222', color: showPending ? '#fbbf24' : '#666', border: 'none', borderRadius: 3, cursor: 'pointer', fontSize: 10 }}>
                  ‚óã Pending ({pendingCount})
                </button>
                <button onClick={() => setShowDone(!showDone)}
                  style={{ padding: '3px 8px', background: showDone ? 'rgba(74,222,128,0.15)' : '#222', color: showDone ? '#4ade80' : '#666', border: 'none', borderRadius: 3, cursor: 'pointer', fontSize: 10 }}>
                  ‚úì Done ({doneCount})
                </button>
                <button onClick={() => setShowHidden(!showHidden)}
                  style={{ padding: '3px 8px', background: showHidden ? 'rgba(248,113,113,0.15)' : '#222', color: showHidden ? '#f87171' : '#666', border: 'none', borderRadius: 3, cursor: 'pointer', fontSize: 10 }}>
                  üëÅ Hidden ({hiddenCount})
                </button>
                <div style={{ marginLeft: 'auto', display: 'flex', gap: 2 }}>
                  {['S', 'M', 'L', 'XL'].map((label, i) => (
                    <button key={label} onClick={() => setThumbSize(i)}
                      style={{ padding: '3px 6px', background: thumbSize === i ? '#333' : '#1a1a1a', color: thumbSize === i ? '#fff' : '#666', border: 'none', borderRadius: 2, cursor: 'pointer', fontSize: 9 }}>
                      {label}
                    </button>
                  ))}
                </div>
              </div>
              <div style={{ flex: 1, overflow: 'auto', padding: 8 }}>
                {filteredQueue.length === 0 ? (
                  <div style={{ padding: 40, textAlign: 'center', color: '#555' }}>
                    <div style={{ fontSize: 48, marginBottom: 12 }}>üìÅ</div>
                    <div style={{ fontSize: 12 }}>Drop images here</div>
                    <div style={{ fontSize: 10, marginTop: 8, color: '#444' }}>Use ‚Üê ‚Üí arrows to navigate</div>
                  </div>
                ) : (
                  <div style={{ display: 'grid', gridTemplateColumns: `repeat(auto-fill, minmax(${currentThumbSize}px, 1fr))`, gap: 6 }}>
                    {filteredQueue.map(item => {
                      const isSelected = item.id === selectedId;
                      const statusColor = item.status === 'done' ? '#4ade80' : item.status === 'editing' ? '#4ade80' : item.status === 'ready' ? '#60a5fa' : item.status === 'analyzing' ? '#fbbf24' : item.status === 'error' ? '#f87171' : '#666';
                      return (
                        <div key={item.id} onClick={() => selectImage(item.id)}
                          style={{ position: 'relative', borderRadius: 6, overflow: 'hidden', cursor: 'pointer',
                            border: `2px solid ${isSelected ? '#60a5fa' : statusColor}`,
                            opacity: item.hidden ? 0.4 : item.status === 'done' ? 0.6 : 1 }}>
                          <div style={{ aspectRatio: '1', background: `url(${item.url}) center/cover` }}>
                            <div style={{ position: 'absolute', top: 4, left: 4, width: 12, height: 12, borderRadius: 6, background: statusColor, border: '2px solid rgba(0,0,0,0.5)' }} />
                            {item.status === 'analyzing' && (
                              <div style={{ position: 'absolute', inset: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                <span style={{ fontSize: 24 }}>‚è≥</span>
                              </div>
                            )}
                            {item.status === 'done' && <div style={{ position: 'absolute', top: 4, right: 4, background: '#4ade80', color: '#000', padding: '2px 5px', borderRadius: 3, fontSize: 10, fontWeight: 600 }}>‚úì</div>}
                            {item.status === 'editing' && <div style={{ position: 'absolute', top: 4, right: 4, background: '#4ade80', color: '#000', padding: '2px 5px', borderRadius: 3, fontSize: 10, fontWeight: 600 }}>‚óè</div>}
                            {item.hidden && <div style={{ position: 'absolute', top: 4, right: 4, background: '#f87171', color: '#fff', padding: '2px 5px', borderRadius: 3, fontSize: 10 }}>H</div>}
                          </div>
                          <button onClick={(e) => item.hidden ? unhideImage(item.id, e) : hideImage(item.id, e)} tabIndex={-1}
                            style={{ position: 'absolute', bottom: 4, right: 4, background: 'rgba(0,0,0,0.8)', border: 'none', color: '#888', cursor: 'pointer', padding: '3px 6px', borderRadius: 3, fontSize: 10 }}>
                            {item.hidden ? 'üëÅ' : '‚úï'}
                          </button>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            </div>

            {/* CENTER - PREVIEW */}
            <div style={{ width: 340, minWidth: 280, maxWidth: 400, flexShrink: 0, display: 'flex', flexDirection: 'column' }}>
              {selectedImg ? (
                <>
                  <div style={{ height: '35%', minHeight: 120, background: '#000', display: 'flex', alignItems: 'center', justifyContent: 'center', position: 'relative' }}>
                    <img src={selectedImg.url} style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain' }} />
                    <div style={{ position: 'absolute', bottom: 4, left: 4, background: 'rgba(0,0,0,0.8)', padding: '2px 6px', borderRadius: 3, color: '#888', fontSize: 9, maxWidth: '80%', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                      {selectedImg.name}
                    </div>
                    {modified && <div style={{ position: 'absolute', top: 4, right: 4, background: '#fbbf24', color: '#000', padding: '2px 6px', borderRadius: 3, fontSize: 9 }}>‚óè</div>}
                    {downloadedLarger && (
                      <div style={{ position: 'absolute', top: 4, left: 4, background: '#4ade80', color: '#000', padding: '2px 6px', borderRadius: 3, fontSize: 9 }}>
                        ‚¨á {(downloadedLarger.size / 1024 / 1024).toFixed(1)}MB
                      </div>
                    )}
                  </div>

                  <div style={{ flex: 1, overflow: 'auto', padding: 10 }}>
                    {selectedImg.status === 'analyzing' && (
                      <div style={{ textAlign: 'center', padding: 20, color: '#666' }}>
                        <div style={{ fontSize: 24, marginBottom: 6 }}>‚è≥</div>
                        Analyzing...
                      </div>
                    )}

                    {selectedImg.status === 'error' && (
                      <div style={{ textAlign: 'center', padding: 20, color: '#f87171' }}>
                        <div style={{ fontSize: 20, marginBottom: 6 }}>‚ö†Ô∏è</div>
                        Failed
                        <button onClick={() => { setQueue(q => q.map(i => i.id === selectedImg.id ? {...i, status: 'pending'} : i)); analyzeImage({...selectedImg, status: 'pending'}); }}
                          style={{ display: 'block', margin: '10px auto', padding: '5px 10px', background: '#2563eb', color: 'white', border: 'none', borderRadius: 3, cursor: 'pointer', fontSize: 10 }}>
                          Retry
                        </button>
                      </div>
                    )}

                    {(selectedImg.status === 'ready' || selectedImg.status === 'done' || selectedImg.status === 'editing' || isEditing) && (
                      <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                        {(designer?.designer || designer?.designers?.length > 0) && (
                          <div style={{ background: 'rgba(167,139,250,0.1)', padding: 8, borderRadius: 5, border: '1px solid rgba(167,139,250,0.3)' }}>
                            <span style={{ color: '#a78bfa', fontSize: 10 }}>üé® {designer.designers?.length > 1 ? designer.designers.join(', ') : designer.designer}</span>
                          </div>
                        )}

                        {similarCount > 0 && (
                          <div style={{ background: 'rgba(251,191,36,0.1)', padding: 8, borderRadius: 5, border: '1px solid rgba(251,191,36,0.3)' }}>
                            <span style={{ color: '#fbbf24', fontSize: 10 }}>üìé {similarCount} similar image{similarCount > 1 ? 's' : ''} will sync</span>
                          </div>
                        )}

                        {visionData?.matchingImages?.length > 0 && (
                          <div style={{ background: 'rgba(96,165,250,0.1)', padding: 8, borderRadius: 5, border: '1px solid rgba(96,165,250,0.3)' }}>
                            <div style={{ color: '#60a5fa', fontSize: 9, marginBottom: 4 }}>üîç {visionData.matchingImages.length} web matches</div>
                            <div style={{ display: 'flex', gap: 3, flexWrap: 'wrap' }}>
                              {visionData.matchingImages.slice(0, 4).map((img, i) => (
                                <a key={i} href={img.url} target="_blank" rel="noreferrer" style={{ color: '#60a5fa', fontSize: 8, textDecoration: 'none', padding: '1px 4px', background: 'rgba(96,165,250,0.1)', borderRadius: 2 }}>
                                  {img.type}
                                </a>
                              ))}
                            </div>
                          </div>
                        )}

                        {keywords.length > 0 && (
                          <div style={{ background: s.panel, borderRadius: 5, padding: 8, border: `1px solid ${s.border}` }}>
                            <div style={{ color: '#4ade80', marginBottom: 5, fontSize: 10, fontWeight: 600 }}>
                              Tagged ({keywords.length})
                            </div>
                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: 3 }}>
                              {keywords.map(k => (
                                <span key={k.id} style={{ padding: '2px 5px', background: `${getColor(k.rootCategory)}20`, color: getColor(k.rootCategory), borderRadius: 3, fontSize: 9, display: 'flex', alignItems: 'center', gap: 3 }}>
                                  {k.source === 'vision' && <span style={{ fontSize: 7 }}>üîç</span>}
                                  {k.source === 'filename' && <span style={{ fontSize: 7 }}>üìÑ</span>}
                                  {k.value}
                                  <span onClick={() => removeKw(k.id)} style={{ cursor: 'pointer', opacity: 0.5, fontSize: 7 }}>‚úï</span>
                                </span>
                              ))}
                            </div>
                          </div>
                        )}

                        {pending.length > 0 && (
                          <div style={{ background: s.panel, borderRadius: 5, padding: 8, border: `1px solid ${s.border}` }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: 5 }}>
                              <span style={{ color: s.bright, fontSize: 10, fontWeight: 600 }}>{pending.length} review</span>
                              <button onClick={acceptAll} style={{ padding: '1px 5px', background: 'rgba(96,165,250,0.15)', color: '#60a5fa', border: 'none', borderRadius: 2, cursor: 'pointer', fontSize: 8 }}>All ‚úì</button>
                            </div>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                              {pending.map(k => (
                                <div key={k.id} style={{ display: 'flex', alignItems: 'center', gap: 3, padding: '3px 4px', background: 'rgba(255,255,255,0.02)', borderRadius: 3 }}>
                                  <button onClick={() => accept(k.id)} tabIndex={-1} style={{ padding: '1px 4px', background: 'rgba(74,222,128,0.15)', color: '#4ade80', border: 'none', borderRadius: 2, cursor: 'pointer', fontSize: 8 }}>‚úì</button>
                                  <button onClick={() => ignore(k.id)} tabIndex={-1} style={{ padding: '1px 4px', background: 'rgba(251,191,36,0.15)', color: '#fbbf24', border: 'none', borderRadius: 2, cursor: 'pointer', fontSize: 8 }}>‚Äì</button>
                                  <button onClick={() => block(k.id)} tabIndex={-1} style={{ padding: '1px 4px', background: 'rgba(248,113,113,0.15)', color: '#f87171', border: 'none', borderRadius: 2, cursor: 'pointer', fontSize: 8 }}>‚úï</button>
                                  <span style={{ width: 4, height: 4, borderRadius: 2, background: getColor(k.rootCategory), flexShrink: 0 }} />
                                  <span style={{ color: s.bright, fontSize: 9, flex: 1, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{k.value}</span>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}

                        {ignored.length > 0 && (
                          <div style={{ background: s.panel, borderRadius: 5, padding: 8, border: `1px solid ${s.border}` }}>
                            <div style={{ color: '#fbbf24', marginBottom: 4, fontSize: 9 }}>Skipped ({ignored.length})</div>
                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: 3 }}>
                              {ignored.map(k => (
                                <span key={k.id} style={{ padding: '2px 5px', background: 'rgba(251,191,36,0.1)', color: '#b45309', borderRadius: 3, fontSize: 9, display: 'flex', alignItems: 'center', gap: 3 }}>
                                  {k.value}
                                  <span onClick={() => acceptIgnored(k.id)} style={{ cursor: 'pointer', color: '#4ade80', fontSize: 7 }}>‚úì</span>
                                  <span onClick={() => block(k.id)} style={{ cursor: 'pointer', color: '#f87171', fontSize: 7 }}>‚úï</span>
                                </span>
                              ))}
                            </div>
                          </div>
                        )}

                        <div style={{ display: 'flex', gap: 4 }}>
                          <input type="text" value={customInput} onChange={e => setCustomInput(e.target.value)}
                            onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); addCustom(); } }}
                            placeholder="Add..."
                            style={{ flex: 1, padding: '5px 8px', background: s.panel, border: `1px solid ${s.border}`, borderRadius: 3, color: s.bright, font: 'inherit', outline: 'none', fontSize: 10 }} />
                          <button onClick={addCustom} disabled={!customInput.trim()} tabIndex={-1}
                            style={{ padding: '5px 10px', background: customInput.trim() ? '#f472b6' : '#222', color: customInput.trim() ? 'white' : '#444', border: 'none', borderRadius: 3, cursor: customInput.trim() ? 'pointer' : 'default', fontSize: 10 }}>+</button>
                        </div>

                        {keywords.length > 0 && (
                          <button onClick={() => saveImage(selectedImg, keywords, designer)} tabIndex={-1} style={{ padding: '6px 12px', background: '#2563eb', color: 'white', border: 'none', borderRadius: 4, cursor: 'pointer', fontSize: 10, fontWeight: 500 }}>
                            üíæ Save{similarCount > 0 ? ` + ${similarCount} similar` : ''}
                          </button>
                        )}
                      </div>
                    )}

                    {selectedImg.status === 'pending' && (
                      <div style={{ textAlign: 'center', padding: 20, color: '#666' }}>
                        <button onClick={() => analyzeImage(selectedImg)} tabIndex={-1}
                          style={{ padding: '6px 14px', background: '#2563eb', color: 'white', border: 'none', borderRadius: 4, cursor: 'pointer', fontSize: 10 }}>
                          Analyze
                        </button>
                      </div>
                    )}
                  </div>
                </>
              ) : (
                <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#555' }}>
                  <div style={{ textAlign: 'center' }}>
                    <div style={{ fontSize: 36, marginBottom: 10, opacity: 0.3 }}>üñº</div>
                    <div style={{ fontSize: 10 }}>Select image</div>
                    <div style={{ fontSize: 9, marginTop: 6, color: '#444' }}>‚Üê ‚Üí to navigate</div>
                  </div>
                </div>
              )}
            </div>

            {/* RIGHT - TAXONOMY */}
            <div style={{ width: 280, minWidth: 220, flexShrink: 0, background: s.panel, borderLeft: `1px solid ${s.border}`, display: 'flex', flexDirection: 'column' }}>
              <div style={{ padding: 12, borderBottom: `1px solid ${s.border}`, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <div>
                  <div style={{ color: s.bright, fontSize: 12, fontWeight: 600 }}>Taxonomy</div>
                  <div style={{ color: '#666', fontSize: 10 }}>{accepted.length} accepted ‚Ä¢ {taxInfo.allTerms.size} dictionary{customCount > 0 ? ` ‚Ä¢ ${customCount} uncategorized` : ''}</div>
                </div>
                <div style={{ display: 'flex', gap: 4 }}>
                  {customCount > 0 && showMasterTaxonomy && (
                    <button onClick={runCategorization} disabled={isCategorizing || !geminiKey} tabIndex={-1}
                      style={{ padding: '3px 6px', background: isCategorizing ? '#444' : '#f472b6', color: isCategorizing ? '#888' : 'white', border: 'none', borderRadius: 3, cursor: isCategorizing ? 'default' : 'pointer', fontSize: 9 }}>
                      {isCategorizing ? '‚è≥' : 'üîÑ'} {customCount}
                    </button>
                  )}
                  <button onClick={() => setShowMasterTaxonomy(!showMasterTaxonomy)} tabIndex={-1}
                    style={{ padding: '3px 6px', background: showMasterTaxonomy ? 'rgba(96,165,250,0.15)' : '#222', color: showMasterTaxonomy ? '#60a5fa' : '#666', border: 'none', borderRadius: 3, cursor: 'pointer', fontSize: 9 }}>
                    {showMasterTaxonomy ? 'Session' : 'Master'}
                  </button>
                </div>
              </div>
              <div style={{ flex: 1, padding: 8, overflowY: 'auto' }}>
                {showMasterTaxonomy ? (
                  <div style={{ fontSize: 10 }}>
                    <div style={{ color: '#666', marginBottom: 8 }}>Master dictionary ({taxInfo.allTerms.size} terms):</div>
                    {Object.entries(taxonomy).map(([name, value]) => (
                      <MasterTaxonomyNode key={name} name={name} value={value} depth={0} expanded={expanded}
                        onToggle={p => setExpanded(e => ({ ...e, [p]: e[p] === false ? true : false }))}
                        onDelete={deleteFromMasterTaxonomy} />
                    ))}
                  </div>
                ) : Object.keys(tree).length === 0 ? (
                  <div style={{ textAlign: 'center', padding: 16, color: '#555', fontSize: 10 }}>
                    <div style={{ marginBottom: 6 }}>Empty</div>
                    <div style={{ fontSize: 9, color: '#444' }}>Analyze images to build</div>
                  </div>
                ) : (
                  Object.entries(tree).map(([name, node]) => (
                    <TreeNode key={name} name={name} node={node} depth={0} expanded={expanded}
                      onToggle={p => setExpanded(e => ({ ...e, [p]: e[p] === false ? true : false }))}
                      onDeleteKeyword={deleteFromTaxonomy} />
                  ))
                )}
              </div>
            </div>
          </div>

          {/* SETTINGS */}
          {showSettings && (
            <div onClick={() => setShowSettings(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 200 }}>
              <div onClick={e => e.stopPropagation()} style={{ background: s.panel, borderRadius: 10, width: 420, maxHeight: '80vh', overflow: 'auto', border: `1px solid ${s.border}` }}>
                <div style={{ padding: 14, borderBottom: `1px solid ${s.border}`, color: s.bright, fontSize: 13, fontWeight: 600 }}>Settings</div>
                <div style={{ padding: 14, display: 'flex', flexDirection: 'column', gap: 12 }}>
                  <div>
                    <div style={{ marginBottom: 4, color: '#666', fontSize: 10 }}>Gemini API Key</div>
                    <input type="password" value={geminiKey} onChange={e => setGeminiKey(e.target.value)}
                      style={{ width: '100%', padding: '6px 10px', background: '#0a0a0a', border: `1px solid ${s.border}`, borderRadius: 4, color: s.bright, font: 'inherit', outline: 'none', fontSize: 10 }} />
                    <a href="https://aistudio.google.com/apikey" target="_blank" rel="noreferrer" style={{ color: '#60a5fa', fontSize: 9 }}>Get key ‚Üí</a>
                  </div>
                  <div>
                    <div style={{ marginBottom: 4, color: '#666', fontSize: 10 }}>Vision API Key (optional)</div>
                    <input type="password" value={visionKey} onChange={e => setVisionKey(e.target.value)}
                      style={{ width: '100%', padding: '6px 10px', background: '#0a0a0a', border: `1px solid ${s.border}`, borderRadius: 4, color: s.bright, font: 'inherit', outline: 'none', fontSize: 10 }} />
                    <a href="https://console.cloud.google.com/apis/library/vision.googleapis.com" target="_blank" rel="noreferrer" style={{ color: '#60a5fa', fontSize: 9 }}>Enable Vision API ‚Üí</a>
                  </div>
                  <label style={{ display: 'flex', alignItems: 'center', gap: 8, cursor: 'pointer' }}>
                    <input type="checkbox" checked={useVision} onChange={e => setUseVision(e.target.checked)} />
                    <span style={{ fontSize: 10, color: s.text }}>Use Vision API for reverse image search</span>
                  </label>
                  <label style={{ display: 'flex', alignItems: 'center', gap: 8, cursor: 'pointer' }}>
                    <input type="checkbox" checked={autoDownloadLarger} onChange={e => setAutoDownloadLarger(e.target.checked)} />
                    <span style={{ fontSize: 10, color: s.text }}>Auto-download larger versions (needs output folder)</span>
                  </label>
                  <div style={{ display: 'flex', gap: 10 }}>
                    <label style={{ flex: 1, padding: 8, border: `1px solid ${saveMode === 'embed' ? '#60a5fa' : s.border}`, borderRadius: 4, cursor: 'pointer', fontSize: 10 }}>
                      <input type="radio" checked={saveMode === 'embed'} onChange={() => setSaveMode('embed')} style={{ marginRight: 6 }} />
                      Embed XMP
                    </label>
                    <label style={{ flex: 1, padding: 8, border: `1px solid ${saveMode === 'sidecar' ? '#60a5fa' : s.border}`, borderRadius: 4, cursor: 'pointer', fontSize: 10 }}>
                      <input type="radio" checked={saveMode === 'sidecar'} onChange={() => setSaveMode('sidecar')} style={{ marginRight: 6 }} />
                      Sidecar .xmp
                    </label>
                  </div>
                  <button onClick={async () => { try { setOutputDir(await window.showDirectoryPicker({ mode: 'readwrite' })); } catch {} }}
                    style={{ padding: '8px', background: outputDir ? 'rgba(74,222,128,0.15)' : '#222', color: outputDir ? '#4ade80' : '#888', border: 'none', borderRadius: 4, cursor: 'pointer', fontSize: 10 }}>
                    {outputDir ? '‚úì Output folder set' : 'Choose output folder'}
                  </button>
                </div>
                <div style={{ padding: 14, borderTop: `1px solid ${s.border}`, display: 'flex', justifyContent: 'flex-end' }}>
                  <button onClick={() => setShowSettings(false)} style={{ padding: '6px 16px', background: '#2563eb', color: 'white', border: 'none', borderRadius: 4, cursor: 'pointer', fontSize: 10 }}>Done</button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
