<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MegaTagger</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/framer-motion@11/dist/framer-motion.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #0a0a0a; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #111; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #444; }
    #drop-overlay { display: none; position: fixed; inset: 0; background: rgba(96,165,250,0.15); border: 3px dashed #60a5fa; z-index: 9999; align-items: center; justify-content: center; backdrop-filter: blur(4px); }
    #drop-overlay.active { display: flex; }
    .material-symbols-rounded { font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24; vertical-align: middle; }
    .material-symbols-rounded.filled { font-variation-settings: 'FILL' 1, 'wght' 400, 'GRAD' 0, 'opsz' 24; }
    button { transition: all 0.15s ease; }
    button:hover:not(:disabled) { filter: brightness(1.1); }
    button:active:not(:disabled) { transform: scale(0.98); }
  </style>
</head>
<body>
  <div id="drop-overlay"><div style="background: rgba(0,0,0,0.95); padding: 40px 72px; border-radius: 20px; color: #60a5fa; font-size: 16px; display: flex; align-items: center; gap: 16px; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);"><span class="material-symbols-rounded" style="font-size: 36px;">upload_file</span> Drop images or folder here</div></div>
  <div id="root"></div>

  <script>
    const overlay = document.getElementById('drop-overlay');
    let dragCounter = 0;
    document.addEventListener('dragenter', (e) => { e.preventDefault(); dragCounter++; overlay.classList.add('active'); });
    document.addEventListener('dragleave', (e) => { e.preventDefault(); dragCounter--; if (dragCounter === 0) overlay.classList.remove('active'); });
    document.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
    document.addEventListener('drop', async (e) => {
      e.preventDefault(); dragCounter = 0; overlay.classList.remove('active');
      const files = await extractFiles(e.dataTransfer);
      if (files.length > 0 && window.onFilesDropped) window.onFilesDropped(files);
    });

    async function extractFiles(dataTransfer) {
      const files = [];
      const entries = [];

      // First, collect all entries (must be done synchronously before promises)
      const items = dataTransfer.items;
      if (items?.length > 0) {
        for (let i = 0; i < items.length; i++) {
          const entry = items[i].webkitGetAsEntry?.();
          if (entry) entries.push(entry);
        }
      }

      console.log('[EXTRACT] Items:', items?.length, 'Entries:', entries.length);

      async function processEntry(entry) {
        if (!entry) return;
        if (entry.isFile) {
          try {
            const file = await new Promise((resolve, reject) => entry.file(resolve, reject));
            if (file.type.startsWith('image/')) {
              console.log('[EXTRACT] Found image:', file.name);
              files.push(file);
            }
          } catch (e) { console.error('[EXTRACT] Error getting file:', e); }
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          let dirEntries = [];
          while (true) {
            const batch = await new Promise((resolve) => reader.readEntries(resolve, () => resolve([])));
            if (batch.length === 0) break;
            dirEntries = dirEntries.concat(batch);
          }
          for (const e of dirEntries) await processEntry(e);
        }
      }

      // Process all entries
      for (const entry of entries) {
        await processEntry(entry);
      }

      // Fallback to dataTransfer.files if no entries worked
      if (files.length === 0 && dataTransfer.files) {
        console.log('[EXTRACT] Fallback to dataTransfer.files:', dataTransfer.files.length);
        for (let i = 0; i < dataTransfer.files.length; i++) {
          if (dataTransfer.files[i].type.startsWith('image/')) files.push(dataTransfer.files[i]);
        }
      }

      console.log('[EXTRACT] Total files:', files.length);
      return files;
    }
  </script>

  <!-- Load data and utilities (plain JS, no JSX) -->
  <script src="js/data.js"></script>
  <script src="js/utils.js"></script>
  <script src="js/api.js"></script>
  <script src="js/performance.js"></script>

  <script type="text/babel">
    const { useState, useRef, useEffect, useMemo, useCallback, memo } = React;
    const { motion, AnimatePresence } = window.Motion;

    // Import performance utilities
    const { generateThumbnail, storeThumbnail, getThumbnail, storeAnalysis, getAnalysis, BatchProcessor, LazyLoader, throttle, debounce, getMemoryUsage, saveOutputDirectory, loadOutputDirectory } = window.TaggerPerformance;

    // Icon component for Material Symbols
    const Icon = ({ name, size = 20, filled = false, style = {} }) => (
      <span
        className={`material-symbols-rounded${filled ? ' filled' : ''}`}
        style={{ fontSize: size, ...style }}
      >{name}</span>
    );

    // Claude-style Toggle Switch component
    const Toggle = ({ checked, onChange, label, disabled = false }) => (
      <div
        onClick={() => !disabled && onChange(!checked)}
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: 10,
          cursor: disabled ? 'not-allowed' : 'pointer',
          opacity: disabled ? 0.5 : 1,
          padding: '6px 12px',
          background: checked ? 'rgba(96,165,250,0.15)' : '#1f2937',
          borderRadius: 8,
          transition: 'all 0.2s ease'
        }}
      >
        <div style={{
          width: 36,
          height: 20,
          borderRadius: 10,
          background: checked ? '#3b82f6' : '#374151',
          position: 'relative',
          transition: 'background 0.2s ease'
        }}>
          <div style={{
            width: 16,
            height: 16,
            borderRadius: 8,
            background: '#fff',
            position: 'absolute',
            top: 2,
            left: checked ? 18 : 2,
            transition: 'left 0.2s ease',
            boxShadow: '0 1px 3px rgba(0,0,0,0.3)'
          }} />
        </div>
        {label && <span style={{ fontSize: 13, color: checked ? '#60a5fa' : '#9ca3af' }}>{label}</span>}
      </div>
    );

    // Optimized thumbnail component with lazy loading
    const ThumbnailImage = memo(({ item, isSelected, onSelect, onHide, onUnhide, thumbSize }) => {
      const [thumbUrl, setThumbUrl] = useState(null);
      const [isLoading, setIsLoading] = useState(true);
      const imgRef = useRef(null);

      useEffect(() => {
        let mounted = true;
        let objectUrl = null;

        const loadThumbnail = async () => {
          try {
            // Try to get cached thumbnail first
            const cachedThumb = await getThumbnail(item.hash);
            if (cachedThumb && mounted) {
              objectUrl = URL.createObjectURL(cachedThumb);
              setThumbUrl(objectUrl);
              setIsLoading(false);
              return;
            }

            // Generate and cache thumbnail
            const thumb = await generateThumbnail(item.file, thumbSize * 2); // 2x for retina
            if (thumb && mounted) {
              await storeThumbnail(item.hash, thumb);
              objectUrl = URL.createObjectURL(thumb);
              setThumbUrl(objectUrl);
              setIsLoading(false);
            }
          } catch (e) {
            console.error('[THUMB] Load failed:', e);
            // Fallback to original URL
            if (mounted) {
              setThumbUrl(item.url);
              setIsLoading(false);
            }
          }
        };

        // Use IntersectionObserver for lazy loading
        const observer = new IntersectionObserver(
          (entries) => {
            if (entries[0].isIntersecting) {
              loadThumbnail();
              observer.disconnect();
            }
          },
          { rootMargin: '400px' }
        );

        if (imgRef.current) {
          observer.observe(imgRef.current);
        }

        return () => {
          mounted = false;
          if (objectUrl) URL.revokeObjectURL(objectUrl);
          observer.disconnect();
        };
      }, [item.hash, item.file, thumbSize]);

      const statusColor = item.status === 'done' ? '#4ade80' : item.status === 'editing' ? '#4ade80' : item.status === 'ready' ? '#60a5fa' : item.status === 'analyzing' ? '#fbbf24' : item.status === 'error' ? '#f87171' : '#6b7280';

      return (
        <motion.div
          ref={imgRef}
          layout
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.15, layout: { duration: 0.1, ease: 'easeOut' } }}
          onClick={(e) => onSelect(item.id, e)}
          title={item.status === 'error' ? item.errorMessage || 'Analysis failed - click to retry' : ''}
          style={{
            position: 'relative', borderRadius: 8, overflow: 'hidden', cursor: 'pointer',
            border: `2px solid ${isSelected ? '#60a5fa' : 'transparent'}`,
            boxShadow: isSelected ? '0 0 0 2px rgba(96,165,250,0.3)' : 'none',
            opacity: item.hidden ? 0.4 : item.status === 'done' ? 0.7 : 1,
            backgroundColor: '#1a1a1a'
          }}
        >
          <div style={{ aspectRatio: '1', background: thumbUrl && !isLoading ? `url(${thumbUrl}) center/cover` : '#1a1a1a', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            {isLoading && <Icon name="image" size={24} style={{ color: '#4b5563' }} />}
            <div style={{ position: 'absolute', top: 6, left: 6, width: 10, height: 10, borderRadius: 5, background: statusColor, boxShadow: '0 1px 3px rgba(0,0,0,0.4)' }} />
            {item.status === 'analyzing' && (
              <div style={{ position: 'absolute', inset: 0, background: 'rgba(0,0,0,0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                <Icon name="hourglass_empty" size={28} style={{ color: '#fbbf24' }} />
              </div>
            )}
            {item.status === 'error' && (
              <div style={{ position: 'absolute', inset: 0, background: 'rgba(0,0,0,0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                <Icon name="error" size={28} style={{ color: '#f87171' }} />
              </div>
            )}
            {item.status === 'done' && (
              <div style={{ position: 'absolute', top: 6, right: 6, background: '#4ade80', color: '#000', padding: '3px 6px', borderRadius: 6, fontSize: 12, fontWeight: 600, display: 'flex', alignItems: 'center' }}>
                <Icon name="check" size={14} />
              </div>
            )}
            {item.status === 'editing' && (
              <div style={{ position: 'absolute', top: 6, right: 6, background: '#60a5fa', color: '#000', padding: '3px 6px', borderRadius: 6, fontSize: 12, fontWeight: 600, display: 'flex', alignItems: 'center' }}>
                <Icon name="edit" size={14} />
              </div>
            )}
            {item.hidden && (
              <div style={{ position: 'absolute', top: 6, right: 6, background: '#f87171', color: '#fff', padding: '3px 6px', borderRadius: 6, fontSize: 12, display: 'flex', alignItems: 'center' }}>
                <Icon name="visibility_off" size={14} />
              </div>
            )}
          </div>
          <button
            onClick={(e) => item.hidden ? onUnhide(item.id, e) : onHide(item.id, e)}
            tabIndex={-1}
            style={{ position: 'absolute', bottom: 6, right: 6, background: 'rgba(0,0,0,0.8)', border: 'none', color: '#9ca3af', cursor: 'pointer', padding: 4, borderRadius: 6, display: 'flex', alignItems: 'center', justifyContent: 'center' }}
          >
            <Icon name={item.hidden ? "visibility" : "close"} size={16} />
          </button>
        </motion.div>
      );
    });

    // Import from modules
    const { DEFAULT_TAXONOMY, ROOT_COLORS, STORAGE_KEY, TAXONOMY_KEY, REQUIRED_CATEGORIES } = window.TaggerData;
    const {
      smartCategorize, addToTaxonomy, removeFromTaxonomy, flattenTaxonomy,
      getBrandPath, looksLikeBrand, parseEra, splitBrandModel, deduplicateKeywords,
      buildTree, countKeywords, hashFile, getBaseName, loadMemory, saveMemory,
      getCachedAnalysis, setCachedAnalysis,
      extractFromFilename, extractFromUrls, extractExistingMetadata, generateXMP,
      embedXMP, embedXMPinPNG, convertToJPEG, isRawFormat, supportsEmbedding,
      autoAssignRequiredCategory
    } = window.TaggerUtils;
    const { analyzeWithGemini, findDesigner, categorizeKeywords, analyzeWithVision, extractCreatorsFromWebMatches, downloadLargerVersion, organizeTaxonomy, researchKeyword } = window.TaggerAPI;

    // ============================================
    // REACT COMPONENTS (must be in Babel block for JSX)
    // ============================================
    const TreeNode = ({ name, node, depth = 0, expanded, onToggle, onDeleteKeyword }) => {
      const children = node._children || {};
      const hasChildren = Object.keys(children).length > 0;
      const keywords = node._keywords || [];
      const count = countKeywords(node);
      const pathKey = node._path?.join('>');
      const isExpanded = expanded[pathKey] !== false;
      const color = ROOT_COLORS[node._path?.[0]] || '#94a3b8';

      return (
        <div style={{ marginLeft: depth > 0 ? 16 : 0 }}>
          <div onClick={() => (hasChildren || keywords.length > 0) && onToggle(pathKey)}
            style={{ display: 'flex', alignItems: 'center', gap: 8, padding: '6px 8px', borderRadius: 6, cursor: 'pointer', background: depth === 0 ? 'rgba(255,255,255,0.03)' : 'transparent' }}>
            <Icon name={isExpanded ? "expand_more" : "chevron_right"} size={16} style={{ color: '#4b5563', opacity: (hasChildren || keywords.length > 0) ? 1 : 0 }} />
            {depth === 0 && <span style={{ width: 10, height: 10, borderRadius: 4, background: color }} />}
            <span style={{ flex: 1, color: depth === 0 ? '#f3f4f6' : '#9ca3af', fontSize: 13 }}>{name}</span>
            <span style={{ color: '#6b7280', fontSize: 12 }}>{count}</span>
          </div>
          {isExpanded && keywords.length > 0 && (
            <div style={{ marginLeft: 28, marginTop: 6, display: 'flex', flexWrap: 'wrap', gap: 6 }}>
              {keywords.map(kw => (
                <span key={kw.id} style={{ padding: '4px 10px', background: `${color}15`, color, borderRadius: 16, fontSize: 12, display: 'flex', alignItems: 'center', gap: 6, border: `1px solid ${color}25` }}>
                  {kw.value}
                  <span onClick={(e) => { e.stopPropagation(); onDeleteKeyword(kw.id); }} style={{ cursor: 'pointer', opacity: 0.6, display: 'flex' }}>
                    <Icon name="close" size={12} />
                  </span>
                </span>
              ))}
            </div>
          )}
          {isExpanded && hasChildren && Object.entries(children).map(([n, c]) => (
            <TreeNode key={n} name={n} node={c} depth={depth + 1} expanded={expanded} onToggle={onToggle} onDeleteKeyword={onDeleteKeyword} />
          ))}
        </div>
      );
    };

    const MasterTaxonomyNode = ({ name, value, path = [], depth = 0, expanded, onToggle, onDelete }) => {
      const currentPath = [...path, name];
      const pathKey = currentPath.join('>');
      const isExpanded = expanded[pathKey] !== false;
      const color = ROOT_COLORS[currentPath[0]] || '#94a3b8';

      let children = {};
      let items = [];
      if (Array.isArray(value)) {
        items = value;
      } else if (typeof value === 'object' && value !== null) {
        items = value._items || [];
        children = Object.fromEntries(Object.entries(value).filter(([k]) => k !== '_items'));
      }

      const hasChildren = Object.keys(children).length > 0;
      const hasItems = items.length > 0;
      const hasContent = hasChildren || hasItems;

      return (
        <div style={{ marginLeft: depth > 0 ? 16 : 0 }}>
          <div onClick={() => hasContent && onToggle(pathKey)}
            style={{ display: 'flex', alignItems: 'center', gap: 8, padding: '6px 8px', borderRadius: 6, cursor: hasContent ? 'pointer' : 'default', background: depth === 0 ? 'rgba(255,255,255,0.03)' : 'transparent' }}>
            <Icon name={isExpanded ? "expand_more" : "chevron_right"} size={16} style={{ color: '#4b5563', opacity: hasContent ? 1 : 0 }} />
            {depth === 0 && <span style={{ width: 10, height: 10, borderRadius: 4, background: color }} />}
            <span style={{ flex: 1, color: depth === 0 ? '#f3f4f6' : '#9ca3af', fontSize: 13 }}>{name}</span>
          </div>
          {isExpanded && hasItems && (
            <div style={{ marginLeft: 28, marginTop: 6, display: 'flex', flexWrap: 'wrap', gap: 6 }}>
              {items.map((item, idx) => (
                <span key={`${pathKey}-${item}-${idx}`} style={{ padding: '4px 10px', background: `${color}15`, color, borderRadius: 16, fontSize: 12, display: 'flex', alignItems: 'center', gap: 6, border: `1px solid ${color}25` }}>
                  {item}
                  <span onClick={(e) => { e.stopPropagation(); onDelete(currentPath, item); }} style={{ cursor: 'pointer', opacity: 0.6, display: 'flex' }}>
                    <Icon name="close" size={12} />
                  </span>
                </span>
              ))}
            </div>
          )}
          {isExpanded && hasChildren && Object.entries(children).map(([n, v]) => (
            <MasterTaxonomyNode key={n} name={n} value={v} path={currentPath} depth={depth + 1} expanded={expanded} onToggle={onToggle} onDelete={onDelete} />
          ))}
        </div>
      );
    };

    // ============================================
    // MAIN APP
    // ============================================
    function App() {
      const [geminiKey, setGeminiKey] = useState(localStorage.getItem('gemini_api_key') || '');
      const [visionKey, setVisionKey] = useState(localStorage.getItem('vision_api_key') || '');
      const [useVision, setUseVision] = useState(localStorage.getItem('use_vision') === 'true');
      const [autoDownloadLarger, setAutoDownloadLarger] = useState(localStorage.getItem('auto_download_larger') === 'true');
      const [showSettings, setShowSettings] = useState(false);
      const [saveMode, setSaveMode] = useState(localStorage.getItem('save_mode') || 'embed');
      const [outputDir, setOutputDir] = useState(null);
      const [outputDirName, setOutputDirName] = useState(localStorage.getItem('output_dir_name') || '');
      const [thumbSize, setThumbSize] = useState(parseInt(localStorage.getItem('thumb_size')) || 1);

      const [taxonomy, setTaxonomy] = useState(() => {
        try { return JSON.parse(localStorage.getItem(TAXONOMY_KEY)) || DEFAULT_TAXONOMY; }
        catch { return DEFAULT_TAXONOMY; }
      });
      const taxInfo = useMemo(() => flattenTaxonomy(taxonomy), [taxonomy]);
      // Master taxonomy terms - only from DEFAULT_TAXONOMY, not user additions
      const masterTerms = useMemo(() => {
        const result = flattenTaxonomy(DEFAULT_TAXONOMY);
        console.log('[MASTER] Built', result.allTerms.size, 'master terms');
        return result.allTerms;
      }, []);

      const [queue, setQueue] = useState([]);
      const [memory, setMemory] = useState({});
      const [selectedId, setSelectedId] = useState(null);
      const [selectedIds, setSelectedIds] = useState([]); // Multi-select support
      const [lastClickedId, setLastClickedId] = useState(null); // For shift-click range selection

      // Load memory from IndexedDB on mount
      useEffect(() => {
        loadMemory().then(m => {
          if (m && Object.keys(m).length > 0) {
            setMemory(m);
            console.log('[MEMORY] Loaded from IndexedDB:', Object.keys(m).length, 'items');
          }
        });

        // Load saved output directory on mount
        loadOutputDirectory().then(handle => {
          if (handle) {
            setOutputDir(handle);
            setOutputDirName(handle.name);
            console.log('[INIT] Restored output directory:', handle.name);
          }
        }).catch(e => {
          console.error('[INIT] Failed to restore output directory:', e);
        });
      }, []);

      const [showDone, setShowDone] = useState(true);
      const [showHidden, setShowHidden] = useState(false);
      const [showPending, setShowPending] = useState(true);
      const [showAnalyzing, setShowAnalyzing] = useState(true);
      const [showMasterTaxonomy, setShowMasterTaxonomy] = useState(false);

      const [pending, setPending] = useState([]);
      const [keywords, setKeywords] = useState([]);
      const [ignored, setIgnored] = useState([]);
      const [designer, setDesigner] = useState(null);
      const [modified, setModified] = useState(false);
      const [visionData, setVisionData] = useState(null);
      const [downloadedLarger, setDownloadedLarger] = useState(null);
      const [isEditing, setIsEditing] = useState(false);

      const [accepted, setAccepted] = useState([]);
      const [blocked, setBlocked] = useState([]);
      const [expanded, setExpanded] = useState({});
      const [customInput, setCustomInput] = useState('');
      const [isCategorizing, setIsCategorizing] = useState(false);
      const [isOrganizing, setIsOrganizing] = useState(false);
      const [organizeProgress, setOrganizeProgress] = useState(null);
      const [gridWidth, setGridWidth] = useState(() => parseInt(localStorage.getItem('grid_width')) || 50); // percentage
      const [isDraggingDivider, setIsDraggingDivider] = useState(false);
      const [autoScan, setAutoScan] = useState(false); // Auto-scan toggle (default: paused)
      const [batchProgress, setBatchProgress] = useState(null); // Batch processing progress

      const fileRef = useRef(null);
      const folderRef = useRef(null);
      const acceptedRef = useRef(new Set());
      const blockedRef = useRef(new Set());
      const containerRef = useRef(null);
      const mainPanelRef = useRef(null);

      // Batch processor for analysis
      const analysisBatchRef = useRef(null);
      useEffect(() => {
        if (!analysisBatchRef.current) {
          analysisBatchRef.current = new BatchProcessor(
            async (img) => {
              await analyzeImageRef.current?.(img);
            },
            { batchSize: 3, delayMs: 500 } // Process 3 images at a time with 500ms delay
          );
        }
      }, []);

      useEffect(() => { acceptedRef.current = new Set(accepted.map(k => k.value.toLowerCase())); }, [accepted]);
      useEffect(() => { blockedRef.current = new Set(blocked.map(k => k.value.toLowerCase())); }, [blocked]);

      const selectedImg = queue.find(q => q.id === selectedId);
      const selectedImgs = queue.filter(q => selectedIds.includes(q.id));
      const isMultiSelect = selectedIds.length > 1;

      const filteredQueue = useMemo(() => {
        return queue.filter(q => {
          // Hidden items only show when showHidden is true (exclusive filter)
          if (q.hidden) return showHidden;
          // Non-hidden items filter by status
          if (q.status === 'done') return showDone;
          if (q.status === 'analyzing') return showAnalyzing;
          // Ready filter controls: pending, ready, editing statuses
          return showPending;
        });
      }, [queue, showDone, showHidden, showPending, showAnalyzing]);

      const findPath = useCallback((kwValue, kwType = 'keyword') => {
        const key = kwValue.toLowerCase().trim();
        if (taxInfo.paths[key]) return taxInfo.paths[key];
        return smartCategorize({ value: kwValue, type: kwType });
      }, [taxInfo]);

      // Keyboard navigation
      useEffect(() => {
        const handleKeyDown = async (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          // X key - hide current image and advance to next
          if (e.key === 'x' || e.key === 'X') {
            e.preventDefault();
            const img = selectedImgRef.current;
            if (img) {
              console.log('[KEYBOARD] X pressed - hiding:', img.name);
              // Hide the image
              setQueue(q => q.map(i => i.id === img.id ? { ...i, hidden: true } : i));
              setMemory(prev => ({ ...prev, [img.hash]: { ...prev[img.hash], hidden: true } }));

              // Advance to next image
              const currentIndex = filteredQueue.findIndex(q => q.id === img.id);
              const nextFiltered = filteredQueue.filter(q => q.id !== img.id); // Re-filter without hidden
              if (nextFiltered.length > 0) {
                const nextIndex = currentIndex < nextFiltered.length ? currentIndex : 0;
                const nextId = nextFiltered[nextIndex].id;
                setSelectedIds([nextId]);
                setLastClickedId(nextId);
                selectImage(nextId);
              }
            }
            return;
          }

          // Enter key - save current image(s) and advance to next
          if (e.key === 'Enter') {
            e.preventDefault();
            const img = selectedImgRef.current;
            const kws = keywordsRef.current;
            const currentSelectedIds = selectedIdsRef.current;

            if (img && kws.length > 0 && saveImageRef.current) {
              // Check for required category
              const hasRequiredCategory = kws.some(k => REQUIRED_CATEGORIES.includes(k.value));
              if (!hasRequiredCategory) {
                alert('Please select at least one primary category (Industrial Design, Graphic Design, Art, Photography, or Architecture) before saving.');
                return;
              }

              // Check if multi-select is active
              if (currentSelectedIds.length > 1) {
                console.log('[KEYBOARD] Enter pressed - saving', currentSelectedIds.length, 'selected images');
                // Save all selected images with the CURRENT keywords from the primary selection (skip sync to avoid cascade)
                const selectedImages = queueRef.current.filter(q => currentSelectedIds.includes(q.id));
                for (const selectedImg of selectedImages) {
                  // Apply current keywords to ALL selected images
                  console.log('[KEYBOARD] Saving:', selectedImg.name, 'with', kws.length, 'keywords');
                  await saveImageRef.current(selectedImg, kws, designerRef.current, true); // skipSync=true
                }

                // Clear multi-select and advance to next
                const nextFiltered = filteredQueue.filter(q => !currentSelectedIds.includes(q.id));
                if (nextFiltered.length > 0) {
                  const nextId = nextFiltered[0].id;
                  setSelectedIds([nextId]);
                  setLastClickedId(nextId);
                  selectImage(nextId);
                }
              } else {
                // Single selection - save with sync
                console.log('[KEYBOARD] Enter pressed - saving:', img.name);
                await saveImageRef.current(img, kws, designerRef.current, false); // skipSync=false

                // Advance to next image
                const currentIndex = filteredQueue.findIndex(q => q.id === img.id);
                if (currentIndex !== -1 && filteredQueue.length > 1) {
                  const nextIndex = currentIndex < filteredQueue.length - 1 ? currentIndex + 1 : 0;
                  const nextId = filteredQueue[nextIndex].id;
                  setSelectedIds([nextId]);
                  setLastClickedId(nextId);
                  selectImage(nextId);
                }
              }
            }
            return;
          }

          if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const currentIndex = filteredQueue.findIndex(q => q.id === selectedId);
            let newIndex = currentIndex;

            if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
              newIndex = currentIndex < filteredQueue.length - 1 ? currentIndex + 1 : 0;
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
              newIndex = currentIndex > 0 ? currentIndex - 1 : filteredQueue.length - 1;
            }

            if (filteredQueue[newIndex]) {
              const newId = filteredQueue[newIndex].id;
              setSelectedIds([newId]); // Update blue outline to follow arrow navigation
              setLastClickedId(newId);
              selectImage(newId);
            }
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [filteredQueue, selectedId]);

      // Save settings
      useEffect(() => {
        if (geminiKey) localStorage.setItem('gemini_api_key', geminiKey);
        if (visionKey) localStorage.setItem('vision_api_key', visionKey);
        localStorage.setItem('use_vision', useVision.toString());
        localStorage.setItem('auto_download_larger', autoDownloadLarger.toString());
        localStorage.setItem('save_mode', saveMode);
        localStorage.setItem('thumb_size', thumbSize.toString());
      }, [geminiKey, visionKey, useVision, autoDownloadLarger, saveMode, thumbSize]);

      // Auto-save memory to IndexedDB (debounced to avoid excessive writes)
      useEffect(() => {
        const timeoutId = setTimeout(() => {
          if (Object.keys(memory).length > 0) {
            saveMemory(memory).catch(e => console.error('[MEMORY] Save failed:', e));
          }
        }, 1000); // Debounce 1 second
        return () => clearTimeout(timeoutId);
      }, [memory]);
      useEffect(() => { localStorage.setItem(TAXONOMY_KEY, JSON.stringify(taxonomy)); }, [taxonomy]);
      useEffect(() => { localStorage.setItem('grid_width', gridWidth.toString()); }, [gridWidth]);

      // Divider drag handlers
      const handleDividerMouseDown = useCallback((e) => {
        e.preventDefault();
        setIsDraggingDivider(true);
      }, []);

      useEffect(() => {
        if (!isDraggingDivider) return;

        const handleMouseMove = (e) => {
          const container = mainPanelRef.current;
          if (!container) return;
          const rect = container.getBoundingClientRect();
          const taxonomyWidth = 375; // fixed taxonomy panel width
          const dividerWidth = 12;
          const availableWidth = rect.width - taxonomyWidth - dividerWidth;
          const mouseX = e.clientX - rect.left;
          // Calculate as percentage of available width (excluding taxonomy)
          const newGridWidth = Math.max(20, Math.min(80, (mouseX / availableWidth) * 100));
          setGridWidth(Math.round(newGridWidth));
        };

        const handleMouseUp = () => {
          setIsDraggingDivider(false);
        };

        // Add cursor style to body during drag for consistent cursor
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        return () => {
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        };
      }, [isDraggingDivider]);

      const queueRef = useRef(queue);
      const memoryRef = useRef(memory);
      const geminiKeyRef = useRef(geminiKey);
      const autoScanRef = useRef(autoScan);
      const analyzeImageRef = useRef(null);
      const saveImageRef = useRef(null);
      const selectedImgRef = useRef(null);
      const selectedIdsRef = useRef([]);
      const keywordsRef = useRef([]);
      const designerRef = useRef(null);
      useEffect(() => { queueRef.current = queue; }, [queue]);
      useEffect(() => { memoryRef.current = memory; }, [memory]);
      useEffect(() => { geminiKeyRef.current = geminiKey; }, [geminiKey]);
      useEffect(() => { autoScanRef.current = autoScan; }, [autoScan]);
      useEffect(() => { keywordsRef.current = keywords; }, [keywords]);
      useEffect(() => { designerRef.current = designer; }, [designer]);

      useEffect(() => {
        window.onFilesDropped = async (files) => { await processFilesRef.current(files); };
        return () => { window.onFilesDropped = null; };
      }, []);

      // Restore output directory on mount if we have a saved name
      useEffect(() => {
        if (outputDirName && !outputDir) {
          // Show a hint that output folder needs to be re-selected
          console.log('[OUTPUT] Previous output folder was:', outputDirName);
        }
      }, []);

      // Save output dir to IndexedDB when it changes
      useEffect(() => {
        if (outputDir) {
          localStorage.setItem('output_dir_name', outputDir.name); // Keep for backward compatibility
          setOutputDirName(outputDir.name);
          // Save the actual handle to IndexedDB for persistence
          saveOutputDirectory(outputDir).catch(e => {
            console.error('[SETTINGS] Failed to save output directory:', e);
          });
        }
      }, [outputDir]);

      // Clear cache and re-analyze non-done images
      const refreshAnalysis = useCallback(() => {
        const cacheKey = 'tagger_analysis_cache';
        const nonDoneImages = queue.filter(q => q.status !== 'done' && !q.hidden);

        console.log('[REFRESH] Clearing cache for', nonDoneImages.length, 'non-done images');

        // Clear cache entries for non-done images
        try {
          const cache = JSON.parse(localStorage.getItem(cacheKey) || '{}');
          nonDoneImages.forEach(img => {
            delete cache[img.hash];
          });
          localStorage.setItem(cacheKey, JSON.stringify(cache));
        } catch (e) {
          console.error('[REFRESH] Cache clear failed:', e);
        }

        // Reset status to pending and trigger re-analysis
        setQueue(q => q.map(item => {
          if (item.status !== 'done' && !item.hidden) {
            return { ...item, status: 'pending', keywords: [], pending: [] };
          }
          return item;
        }));

        // Trigger analysis after state update
        setTimeout(() => {
          if (geminiKey) {
            nonDoneImages.forEach(img => {
              analyzeImageRef.current?.({ ...img, status: 'pending' });
            });
          }
        }, 100);
      }, [queue, geminiKey]);

      // Organize taxonomy - research and categorize custom keywords
      const handleOrganizeTaxonomy = useCallback(async () => {
        if (!geminiKey || isOrganizing) return;

        setIsOrganizing(true);
        setOrganizeProgress({ phase: 'init', message: 'Starting...' });

        try {
          const result = await organizeTaxonomy(geminiKey, taxonomy, (progress) => {
            setOrganizeProgress(progress);
          });

          if (result.changes.length > 0) {
            setTaxonomy(result.taxonomy);
            localStorage.setItem(TAXONOMY_KEY, JSON.stringify(result.taxonomy));
            console.log('[ORGANIZE] Applied', result.changes.length, 'changes');
          } else {
            console.log('[ORGANIZE] No changes needed');
          }
        } catch (e) {
          console.error('[ORGANIZE] Error:', e);
        } finally {
          setIsOrganizing(false);
          setOrganizeProgress(null);
        }
      }, [geminiKey, isOrganizing, taxonomy]);

      const processFilesRef = useRef(null);
      processFilesRef.current = async (files) => {
        console.log('[DROP] Received files:', files.length, files.map(f => f.name));
        const imgs = files.filter(f => f.type.startsWith('image/'));
        console.log('[DROP] Image files:', imgs.length);
        if (!imgs.length) return;

        const currentMemory = memoryRef.current;
        const newItems = await Promise.all(imgs.map(async (file) => {
          const hash = await hashFile(file);
          const mem = currentMemory[hash];
          const filenameKws = extractFromFilename(file.name);
          const existingKws = await extractExistingMetadata(file);
          const calculatedBaseName = getBaseName(file.name);

          // Check if we have cached analysis in IndexedDB
          const cachedAnalysis = await getAnalysis(hash);

          // Determine status: done if exported, pending if needs analysis
          let status = 'pending';
          let keywords = [];
          let pending = [];

          if (mem?.exported) {
            status = 'done';
            keywords = mem.keywords || [];
            pending = mem.pending || [];
          } else if (mem?.keywords && mem.keywords.length > 0) {
            // Has keywords in memory but not exported - mark as ready
            status = 'ready';
            keywords = mem.keywords || [];
            pending = mem.pending || [];
          }
          // If cachedAnalysis exists but no keywords in memory, leave as pending
          // and let analyzeImage process the cache to set it to ready

          console.log('[DROP] Processing:', file.name, 'hash:', hash, 'baseName:', calculatedBaseName, 'status:', status, 'cachedAnalysis:', !!cachedAnalysis);
          return {
            id: hash, name: file.name, file, url: URL.createObjectURL(file),
            baseName: calculatedBaseName,
            status,
            hidden: mem?.hidden || false,
            keywords, pending,
            filenameKeywords: filenameKws,
            existingKeywords: existingKws,
            creator: mem?.creator || null, hash
          };
        }));

        const existingIds = new Set(queueRef.current.map(q => q.id));
        const uniqueItems = newItems.filter(item => !existingIds.has(item.id));
        console.log('[DROP] New items:', newItems.length, 'Unique:', uniqueItems.length, 'Existing IDs:', existingIds.size);

        if (uniqueItems.length > 0) {
          setQueue(prev => [...prev, ...uniqueItems]);

          setTimeout(async () => {
            if (geminiKeyRef.current) {
              // First, check for items with cached analysis that need processing
              const cachedItems = [];
              for (const item of uniqueItems) {
                if (item.status === 'pending' && !item.hidden) {
                  const cached = await getAnalysis(item.hash);
                  if (cached) {
                    cachedItems.push(item);
                  }
                }
              }

              // Always process cached items (they're instant)
              if (cachedItems.length > 0) {
                console.log('[AUTO-ANALYZE] Processing', cachedItems.length, 'cached items');
                cachedItems.forEach(item => {
                  analyzeImageRef.current?.(item);
                });
              }

              // Only auto-analyze NEW items if autoScan is enabled
              if (autoScanRef.current) {
                const toAnalyze = uniqueItems.filter(item => item.status === 'pending' && !item.hidden && !cachedItems.includes(item));
                console.log('[AUTO-ANALYZE] Auto-scan ON - batch analyzing', toAnalyze.length, 'new items');

                // Use batch processor for large sets
                if (toAnalyze.length > 10) {
                  setBatchProgress({ current: 0, total: toAnalyze.length });
                  analysisBatchRef.current.addBatch(toAnalyze);

                  // Monitor batch progress
                  const checkProgress = setInterval(() => {
                    const pending = analysisBatchRef.current.pending;
                    const processed = toAnalyze.length - pending;
                    setBatchProgress({ current: processed, total: toAnalyze.length });

                    if (pending === 0) {
                      clearInterval(checkProgress);
                      setTimeout(() => setBatchProgress(null), 2000);
                    }
                  }, 500);
                } else {
                  // Small batch, process directly
                  toAnalyze.forEach(item => {
                    analyzeImageRef.current?.(item);
                  });
                }
              } else if (cachedItems.length === 0) {
                console.log('[AUTO-ANALYZE] Auto-scan OFF - skipping new analysis');
              }
            }
          }, 100);
        }
      };

      const handleFileInput = (e) => {
        if (e.target.files?.length) processFilesRef.current(Array.from(e.target.files));
        e.target.value = '';
      };

      // Find similar images using multi-criteria scoring
      const getSimilarImages = useCallback((img) => {
        if (!img) {
          console.log('[SIMILAR] Called with no image');
          return [];
        }

        console.log(`[SIMILAR] Called for "${img.name}" with baseName: "${img.baseName}" (length: ${img.baseName?.length || 0})`);

        // Minimum baseName length check (lowered to 3 to support IMG_XXXX patterns)
        if (!img.baseName || img.baseName.length < 3) {
          console.log(`[SIMILAR] Rejected: baseName too short or missing`);
          return [];
        }

        // Helper: Extract sequence number from filename
        const getSequenceNumber = (filename) => {
          const noExt = filename.replace(/\.[^.]+$/, '');
          const match = noExt.match(/[-_](\d{1,3})$/);
          return match ? parseInt(match[1], 10) : null;
        };

        // Helper: Calculate keyword similarity (0-1)
        const getKeywordSimilarity = (kw1, kw2) => {
          if (!kw1 || !kw2 || kw1.length === 0 || kw2.length === 0) return 0;
          const set1 = new Set(kw1.map(k => k.value.toLowerCase()));
          const set2 = new Set(kw2.map(k => k.value.toLowerCase()));
          const intersection = new Set([...set1].filter(k => set2.has(k)));
          const union = new Set([...set1, ...set2]);
          return intersection.size / union.size; // Jaccard similarity
        };

        // Score each potential match using combined criteria
        const candidates = queue
          .filter(q => q.id !== img.id && q.baseName === img.baseName)
          .map(q => {
            const reasons = [];
            let isMatch = false;

            const name1 = img.name.toLowerCase().replace(/\.[^.]+$/, '');
            const name2 = q.name.toLowerCase().replace(/\.[^.]+$/, '');

            // Calculate all match criteria
            // 1. Filename prefix similarity
            const minLen = Math.min(name1.length, name2.length);
            const maxLen = Math.max(name1.length, name2.length);
            let commonPrefixLen = 0;
            for (let i = 0; i < minLen; i++) {
              if (name1[i] === name2[i]) commonPrefixLen++;
              else break;
            }
            const prefixMatch = (commonPrefixLen / maxLen) >= 0.7;

            // 2. Sequential filename numbers
            const seq1 = getSequenceNumber(img.name);
            const seq2 = getSequenceNumber(q.name);
            const seqDiff = (seq1 !== null && seq2 !== null) ? Math.abs(seq1 - seq2) : Infinity;
            const isSequential = seqDiff <= 10;

            // 3. File timestamp proximity
            let timeMatch = false;
            let timeWithinTwoDays = false;
            if (img.file && q.file) {
              const time1 = img.file.lastModified || 0;
              const time2 = q.file.lastModified || 0;
              const timeDiff = Math.abs(time1 - time2);
              const oneHour = 60 * 60 * 1000;
              const oneDay = 24 * oneHour;
              const twoDays = 2 * oneDay;

              if (timeDiff < oneHour) {
                reasons.push('time: <1h');
                timeMatch = true;
                timeWithinTwoDays = true;
              } else if (timeDiff < oneDay) {
                reasons.push('time: <1d');
                timeWithinTwoDays = true;
              } else if (timeDiff < twoDays) {
                reasons.push('time: <2d');
                timeWithinTwoDays = true;
              }
            }

            // 4. Keyword similarity
            const kwSim = getKeywordSimilarity(img.keywords || [], q.keywords || []);
            const keywordsMatch = kwSim >= 0.5;

            // Match logic: Combined criteria to prevent false matches
            // IMPORTANT: Disable prefix-only matching for very short baseNames (like "img")
            // to prevent false matches across different photo sessions
            const baseNameTooShort = img.baseName.length <= 4;

            if (prefixMatch && !baseNameTooShort) {
              // Prefix match only works for longer baseNames
              reasons.push(`prefix: ${Math.round((commonPrefixLen / maxLen) * 100)}%`);
              isMatch = true;
            } else if (isSequential && (timeWithinTwoDays || keywordsMatch)) {
              // Sequential numbers + time proximity OR keyword match
              reasons.push(`seq: ${seq1}→${seq2} (Δ${seqDiff})`);
              if (keywordsMatch) reasons.push(`keywords: ${Math.round(kwSim * 100)}%`);
              isMatch = true;
            } else if (timeMatch && (isSequential || keywordsMatch)) {
              // Time match MUST be combined with sequential numbers OR keywords
              // to prevent matching all files dropped at the same time
              if (isSequential) reasons.push(`seq: ${seq1}→${seq2} (Δ${seqDiff})`);
              if (keywordsMatch) reasons.push(`keywords: ${Math.round(kwSim * 100)}%`);
              isMatch = true;
            } else if (keywordsMatch && kwSim >= 0.7) {
              // High keyword similarity (70%+) can stand alone
              reasons.push(`keywords: ${Math.round(kwSim * 100)}%`);
              isMatch = true;
            }

            return { img: q, isMatch, reasons };
          });

        // Debug: Log all candidates
        if (candidates.length > 0) {
          console.log(`[SIMILAR] Checking candidates for "${img.name}" (baseName: "${img.baseName}"):`);
          candidates.forEach(c => {
            const status = c.isMatch ? '✓' : '✗';
            console.log(`  ${status} ${c.img.name}: [${c.reasons.join(', ')}]`);
          });
        }

        // Filter: only include matches where isMatch is true
        const similar = candidates
          .filter(c => c.isMatch)
          .map(c => c.img);

        if (similar.length > 0) {
          console.log(`[SIMILAR] ✓ Matched ${similar.length} images using OR logic`);
        } else if (candidates.length > 0) {
          console.log(`[SIMILAR] ✗ No matches found`);
        }

        return similar;
      }, [queue]);

      // Sync keywords to similar images and auto-save
      const syncToSimilarAndSave = useCallback(async (sourceImg, sourceKeywords, sourceDesigner) => {
        const similar = getSimilarImages(sourceImg);
        if (similar.length === 0) return;

        console.log(`[SYNC] Syncing ${sourceKeywords.length} keywords to ${similar.length} similar images`);

        for (const img of similar) {
          const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
          const newKws = sourceKeywords
            .filter(k => !existingVals.has(k.value.toLowerCase()))
            .map(k => ({ ...k, id: `sync-${Math.random().toString(36).slice(2)}` }));

          if (newKws.length > 0) {
            const updatedKeywords = [...(img.keywords || []), ...newKws];

            // Update queue
            setQueue(q => q.map(i => i.id === img.id ? {
              ...i,
              keywords: updatedKeywords,
              designer: sourceDesigner,
              status: 'done'
            } : i));

            // Save to memory
            setMemory(prev => ({
              ...prev,
              [img.hash]: { exported: true, keywords: updatedKeywords, creator: sourceDesigner?.designer, hidden: img.hidden }
            }));

            // Save file if output dir set
            if (outputDir) {
              try {
                let blob, filename = img.name;
                const creator = sourceDesigner?.designer || null;
                const isRaw = isRawFormat(img.name);
                const canEmbed = supportsEmbedding(img.file);

                if (saveMode === 'embed' && img.file.type.includes('jpeg')) {
                  blob = await embedXMP(img.file, updatedKeywords, creator);
                } else if (saveMode === 'embed' && img.file.type.includes('png')) {
                  blob = await embedXMPinPNG(img.file, updatedKeywords, creator);
                } else if (saveMode === 'embed' && !canEmbed && !isRaw) {
                  // Convert WebP/AVIF to JPEG
                  const jpegBlob = await convertToJPEG(img.file);
                  const jpegFile = new File([jpegBlob], 'temp.jpg', { type: 'image/jpeg' });
                  blob = await embedXMP(jpegFile, updatedKeywords, creator);
                  filename = filename.replace(/\.[^.]+$/, '.jpg');
                } else {
                  blob = new Blob([generateXMP(updatedKeywords, creator)], { type: 'application/rdf+xml' });
                  filename = filename.replace(/\.[^.]+$/, '') + '.xmp';
                }

                const fh = await outputDir.getFileHandle(filename, { create: true });
                const w = await fh.createWritable();
                await w.write(blob);
                await w.close();
                console.log(`[SYNC] Auto-saved: ${filename}`);

                // Copy raw file alongside XMP
                if (isRaw) {
                  const rawFh = await outputDir.getFileHandle(img.name, { create: true });
                  const rawW = await rawFh.createWritable();
                  await rawW.write(img.file);
                  await rawW.close();
                  console.log(`[SYNC] Copied raw: ${img.name}`);
                }
              } catch (e) {
                console.error('[SYNC] Save failed:', e);
              }
            }
          }
        }
      }, [queue, outputDir, saveMode, getSimilarImages]);

      // Save image - defined before selectImage to avoid stale reference
      const saveImage = useCallback(async (img, kws, des, skipSync = false) => {
        if (!img || !kws || kws.length === 0) {
          console.log('[SAVE] Skipped - no image or keywords', { img: img?.name, kwsLength: kws?.length });
          return;
        }

        // Require output directory to be set for batch operations
        if (!outputDir && skipSync) {
          console.error('[SAVE] ❌ Cannot batch save without output directory set. Please select an output folder in settings.');
          console.error('[SAVE] Image:', img.name, 'Keywords:', kws.length, 'outputDir:', !!outputDir, 'skipSync:', skipSync);
          alert('Please select an output folder in settings before saving multiple files.');
          return;
        }

        console.log('[SAVE] ✅ Saving:', img.name, 'with', kws.length, 'keywords', 'skipSync:', skipSync, 'outputDir:', !!outputDir);
        try {
          let blob, filename = img.name;
          const creator = des?.designer || null;
          const isRaw = isRawFormat(img.name);
          const canEmbed = supportsEmbedding(img.file);

          if (saveMode === 'embed' && img.file.type.includes('jpeg')) {
            blob = await embedXMP(img.file, kws, creator);
          } else if (saveMode === 'embed' && img.file.type.includes('png')) {
            blob = await embedXMPinPNG(img.file, kws, creator);
          } else if (saveMode === 'embed' && !canEmbed && !isRaw) {
            console.log('[SAVE] Converting to JPEG:', img.name);
            const jpegBlob = await convertToJPEG(img.file);
            const jpegFile = new File([jpegBlob], 'temp.jpg', { type: 'image/jpeg' });
            blob = await embedXMP(jpegFile, kws, creator);
            filename = filename.replace(/\.[^.]+$/, '.jpg');
          } else {
            blob = new Blob([generateXMP(kws, creator)], { type: 'application/rdf+xml' });
            filename = filename.replace(/\.[^.]+$/, '') + '.xmp';
          }

          const saveFile = async (data, name) => {
            if (outputDir) {
              const fh = await outputDir.getFileHandle(name, { create: true });
              const w = await fh.createWritable();
              await w.write(data);
              await w.close();
              console.log('[SAVE] Saved:', name);
            } else {
              const url = URL.createObjectURL(data);
              Object.assign(document.createElement('a'), { href: url, download: name }).click();
              URL.revokeObjectURL(url);
              console.log('[SAVE] Downloaded:', name);
            }
          };

          await saveFile(blob, filename);

          if (isRaw && outputDir) {
            await saveFile(img.file, img.name);
            console.log('[SAVE] Copied raw file:', img.name);
          }

          // Preserve pending keywords so they show when re-selecting done images
          const currentPending = pending.length > 0 ? pending : (img.pending || []);
          setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'done', keywords: kws, pending: currentPending } : i));
          setMemory(prev => ({ ...prev, [img.hash]: { exported: true, keywords: kws, pending: currentPending, creator, hidden: img.hidden } }));
          setModified(false);
          setIsEditing(false);

          // Auto-select next image if current becomes filtered out
          setTimeout(() => {
            const currentQueue = queueRef.current;
            const currentFiltered = currentQueue.filter(q => {
              if (q.hidden) return showHidden;
              if (q.status === 'done') return showDone;
              if (q.status === 'analyzing') return showAnalyzing;
              return showPending;
            });

            // If current image is no longer visible in filtered view, select next
            if (!currentFiltered.find(q => q.id === img.id)) {
              const currentIndex = currentFiltered.findIndex(q => q.id === selectedId);
              if (currentFiltered.length > 0) {
                const nextIndex = currentIndex >= 0 && currentIndex < currentFiltered.length ? currentIndex : 0;
                selectImage(currentFiltered[nextIndex].id, true); // Skip auto-save to prevent cascade
              } else {
                setSelectedId(null);
              }
            }
          }, 100);

          // Only sync to similar images if not explicitly skipped (to avoid cascades in multi-select)
          if (!skipSync) {
            await syncToSimilarAndSave(img, kws, des);
          }
        } catch (e) { console.error('[SAVE] Failed:', e); }
      }, [saveMode, outputDir, syncToSimilarAndSave, showHidden, showDone, showAnalyzing, showPending, selectedId]);

      // Analysis
      const analyzeImage = useCallback(async (img) => {
        if (!geminiKey || img.status === 'analyzing' || img.status === 'ready' || img.status === 'done') return;

        setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'analyzing' } : i));
        setDownloadedLarger(null);

        try {
          // Check IndexedDB cache first
          const cached = await getAnalysis(img.hash);
          if (cached) {
            console.log('[ANALYZE] Using cached analysis from IndexedDB for:', img.name);
            // Re-process cached keywords through the categorization logic
            const rawKws = cached.rawKeywords || [];
            const visionResult = cached.visionData || null;
            const designerInfo = cached.designer || null;

            // Process keywords (same logic as fresh analysis)
            const processedKws = rawKws.map(kw => {
              const path = smartCategorize(kw);
              return { ...kw, id: kw.id || Math.random().toString(36), path, rootCategory: path[0] };
            });
            const allKws = deduplicateKeywords(processedKws);
            const currentAccepted = acceptedRef.current;
            const currentBlocked = blockedRef.current;

            const auto = [], review = [];
            allKws.forEach(kw => {
              const key = kw.value.toLowerCase().trim();
              if (currentBlocked.has(key)) return;
              // Auto-accept if:
              // - In master taxonomy
              // - From embedded XMP metadata (user's own tags)
              // - Identified as brand, creator, or country of origin
              const inMaster = masterTerms.has(key);
              const isEmbedded = kw.source === 'xmp' || kw.source === 'existing';
              const isBrandOrCreator = ['brand', 'designer', 'artist', 'photographer', 'architect', 'creator'].includes(kw.type);
              const isCountry = kw.type === 'country' || (kw.path && kw.path.includes('Origin'));
              if (inMaster || isEmbedded || isBrandOrCreator || isCountry) {
                auto.push(kw);
              } else {
                review.push(kw);
              }
            });
            console.log(`[CACHE] ${auto.length} auto-accepted, ${review.length} for review`);

            // Auto-assign required category if not present
            const autoWithRequired = autoAssignRequiredCategory(auto);

            setQueue(q => q.map(i => i.id === img.id ? {
              ...i, status: 'ready', keywords: autoWithRequired, pending: review,
              designer: designerInfo, visionData: visionResult
            } : i));

            if (autoWithRequired.length) {
              setAccepted(prev => {
                const updated = [...prev];
                autoWithRequired.forEach(kw => {
                  if (!updated.some(a => a.value.toLowerCase() === kw.value.toLowerCase())) updated.push(kw);
                });
                return updated;
              });
            }
            return;
          }

          const base64 = await new Promise((res, rej) => {
            const r = new FileReader();
            r.onload = () => res(r.result.split(',')[1]);
            r.onerror = rej;
            r.readAsDataURL(img.file);
          });

          const contextParts = [];
          if (img.filenameKeywords?.length) {
            contextParts.push(`Filename suggests: ${img.filenameKeywords.map(k => k.value).join(', ')}`);
          }
          if (img.existingKeywords?.length) {
            contextParts.push(`Existing tags: ${img.existingKeywords.map(k => k.value).join(', ')}`);
          }

          let rawKws = await analyzeWithGemini(geminiKey, base64, img.file.type, contextParts.join('. '));

          if (img.filenameKeywords) rawKws = [...img.filenameKeywords, ...rawKws];
          if (img.existingKeywords) rawKws = [...img.existingKeywords, ...rawKws];

          let visionResult = null;
          if (useVision && visionKey) {
            visionResult = await analyzeWithVision(visionKey, base64);
            if (visionResult?.keywords) {
              visionResult.keywords.forEach(vk => {
                if (!rawKws.some(k => k.value.toLowerCase() === vk.value.toLowerCase())) {
                  rawKws.push(vk);
                }
              });
            }

            // Use Gemini with grounding to extract creator info from web matches
            if (visionResult?.matchingImages?.length > 0) {
              const productContext = rawKws.filter(k => k.type === 'brand' || k.type === 'model').map(k => k.value).join(' ');
              const webCreators = await extractCreatorsFromWebMatches(geminiKey, visionResult.matchingImages, productContext);
              webCreators.forEach(wc => {
                if (!rawKws.some(k => k.value.toLowerCase() === wc.value.toLowerCase())) {
                  rawKws.push(wc);
                }
              });
            }

            if (autoDownloadLarger && visionResult?.matchingImages?.length > 0 && outputDir) {
              const fullMatch = visionResult.matchingImages.find(m => m.type === 'full');
              if (fullMatch) {
                const larger = await downloadLargerVersion(fullMatch.url, img.name);
                if (larger && larger.size > img.file.size) {
                  try {
                    const fh = await outputDir.getFileHandle(larger.filename, { create: true });
                    const w = await fh.createWritable();
                    await w.write(larger.blob);
                    await w.close();
                    setDownloadedLarger({ filename: larger.filename, size: larger.size });
                    console.log('[DOWNLOAD] Saved:', larger.filename);
                  } catch (e) {}
                }
              }
            }
          }

          let processedKws = [];
          const brandFound = [], modelFound = [];

          rawKws.forEach(k => {
            splitBrandModel(k.value).forEach(part => {
              // Always use smartCategorize for better accuracy, unless it's an explicitly known brand/model with good path
              let path = part.path;
              const needsRecategorization = part.path[0] === 'Custom' || part.type === 'keyword' ||
                (part.path.length === 1 && part.path[0] === 'Brand' && part.type !== 'brand');

              if (needsRecategorization) {
                path = findPath(part.value, part.type);
              }

              const kw = {
                id: `${img.id}-${Math.random().toString(36).slice(2)}`,
                value: part.value, confidence: k.confidence || 0.8,
                type: part.type, path: path, rootCategory: path[0],
                source: k.source || 'gemini'
              };
              if (part.type === 'brand') brandFound.push(kw);
              else if (part.type === 'model') modelFound.push(kw);
              processedKws.push(kw);
            });
          });

          processedKws = deduplicateKeywords(processedKws);

          let designerInfo = null;
          if (brandFound.length > 0 && modelFound.length > 0) {
            designerInfo = await findDesigner(geminiKey, `${brandFound[0].value} ${modelFound[0].value}`);
            if (designerInfo?.designers && designerInfo.designers.length > 0) {
              designerInfo.designers.forEach(name => {
                const designerPath = smartCategorize({ value: name, type: 'designer' });
                processedKws.push({
                  id: `designer-${Math.random().toString(36).slice(2)}`,
                  value: name, confidence: 0.8,
                  type: 'designer', path: designerPath, rootCategory: 'Creator'
                });
              });
            } else if (designerInfo?.designer) {
              const designerPath = smartCategorize({ value: designerInfo.designer, type: 'designer' });
              processedKws.push({
                id: `designer-${Math.random().toString(36).slice(2)}`,
                value: designerInfo.designer, confidence: 0.8,
                type: 'designer', path: designerPath, rootCategory: 'Creator'
              });
            }
          }

          const currentBlocked = blockedRef.current;
          const currentAccepted = acceptedRef.current;
          const auto = [], review = [];

          console.log(`[ANALYZE] Master taxonomy has ${masterTerms.size} terms, session has ${currentAccepted.size} accepted`);

          processedKws.forEach(kw => {
            const key = kw.value.toLowerCase().trim();
            if (currentBlocked.has(key)) return;
            // Auto-accept if:
            // - In master taxonomy
            // - From embedded XMP metadata (user's own tags)
            // - Identified as brand, creator, or country of origin
            const inMaster = masterTerms.has(key);
            const isEmbedded = kw.source === 'xmp' || kw.source === 'existing';
            const isBrandOrCreator = ['brand', 'designer', 'artist', 'photographer', 'architect', 'creator'].includes(kw.type);
            const isCountry = kw.type === 'country' || (kw.path && kw.path.includes('Origin'));
            if (inMaster || isEmbedded || isBrandOrCreator || isCountry) {
              auto.push(kw);
            } else {
              review.push(kw);
            }
          });

          console.log(`[ANALYZE] ${auto.length} auto-accepted, ${review.length} for review`);

          // Auto-assign required category if not present
          const autoWithRequired = autoAssignRequiredCategory(auto);

          // Cache the raw analysis results in IndexedDB
          await storeAnalysis(img.hash, {
            rawKeywords: processedKws,
            visionData: visionResult,
            designer: designerInfo
          });

          setQueue(q => q.map(i => i.id === img.id ? {
            ...i, status: 'ready', keywords: autoWithRequired, pending: review,
            designer: designerInfo, visionData: visionResult
          } : i));

          if (autoWithRequired.length) {
            setAccepted(prev => {
              const updated = [...prev];
              autoWithRequired.forEach(kw => {
                if (!updated.some(a => a.value.toLowerCase() === kw.value.toLowerCase())) updated.push(kw);
              });
              return updated;
            });
          }
        } catch (err) {
          console.error('[ANALYZE] Failed:', err.message || err);
          setQueue(q => q.map(i => i.id === img.id ? {
            ...i,
            status: 'error',
            errorMessage: err.message || 'Analysis failed'
          } : i));
        }
      }, [geminiKey, visionKey, useVision, autoDownloadLarger, outputDir, taxInfo, masterTerms, findPath]);

      // Keep ref updated for use in processFiles
      useEffect(() => { analyzeImageRef.current = analyzeImage; }, [analyzeImage]);
      useEffect(() => { saveImageRef.current = saveImage; }, [saveImage]);
      useEffect(() => { selectedImgRef.current = selectedImg; }, [selectedImg]);
      useEffect(() => { selectedIdsRef.current = selectedIds; }, [selectedIds]);
      useEffect(() => { keywordsRef.current = keywords; }, [keywords]);
      useEffect(() => { designerRef.current = designer; }, [designer]);

      const selectImage = useCallback(async (id, skipAutoSave = false) => {
        // Only auto-save if actually modified and not skipped
        if (!skipAutoSave && isEditing && modified && selectedImg && keywords.length > 0) {
          // Check if multi-select is active - save ALL selected images
          if (selectedIds.length > 1) {
            console.log('[NAV] Auto-saving', selectedIds.length, 'selected images before navigation');
            const selectedImages = queue.filter(q => selectedIds.includes(q.id));
            for (const img of selectedImages) {
              // Use the current keywords for all selected images
              await saveImage(img, keywords, designer, true); // skipSync=true for batch
            }
          } else {
            console.log('[NAV] Auto-saving before navigation:', selectedImg.name);
            await saveImage(selectedImg, keywords, designer);
          }
        }

        const img = queue.find(q => q.id === id);
        if (!img) return;

        setSelectedId(id);
        setDownloadedLarger(null);
        setIsEditing(false);

        // Only update keywords/pending if NOT in multi-select mode
        // Multi-select mode uses aggregated data from the useEffect below
        if (selectedIds.length <= 1) {
          if (img.status === 'ready' || img.status === 'done' || img.status === 'editing') {
            setKeywords(img.keywords || []);
            setPending(img.pending || []);
            setDesigner(img.designer || null);
            setVisionData(img.visionData || null);
            setIgnored([]);
            setModified(false);
          } else if (img.status === 'pending') {
            setKeywords([]); setPending([]); setDesigner(null); setVisionData(null); setIgnored([]); setModified(false);
            analyzeImage(img);
          } else {
            setKeywords([]); setPending([]); setDesigner(null); setVisionData(null); setIgnored([]); setModified(false);
          }
        }
      }, [queue, isEditing, modified, selectedImg, selectedIds, keywords, designer, analyzeImage, saveImage]);

      // Multi-select handler with Ctrl-click and Shift-click support
      const handleThumbnailClick = useCallback((id, event) => {
        const isCtrlClick = event?.ctrlKey || event?.metaKey; // Ctrl on Windows/Linux, Cmd on Mac
        const isShiftClick = event?.shiftKey;

        if (isCtrlClick) {
          // Ctrl-click: Toggle individual selection
          if (selectedIds.includes(id)) {
            // Deselect
            const newSelection = selectedIds.filter(sid => sid !== id);
            setSelectedIds(newSelection);
            if (newSelection.length === 0) {
              setSelectedId(null);
            } else if (selectedId === id) {
              // If we deselected the primary, make the first remaining selection primary
              setSelectedId(newSelection[0]);
            }
          } else {
            // Add to selection
            setSelectedIds(prev => [...prev, id]);
            setSelectedId(id); // This becomes the new primary selection
          }
          setLastClickedId(id);
        } else if (isShiftClick && lastClickedId) {
          // Shift-click: Select range between last clicked and current
          const currentIndex = filteredQueue.findIndex(q => q.id === id);
          const lastIndex = filteredQueue.findIndex(q => q.id === lastClickedId);

          if (currentIndex !== -1 && lastIndex !== -1) {
            const start = Math.min(currentIndex, lastIndex);
            const end = Math.max(currentIndex, lastIndex);
            const rangeIds = filteredQueue.slice(start, end + 1).map(q => q.id);

            // Merge with existing selection
            const newSelection = Array.from(new Set([...selectedIds, ...rangeIds]));
            setSelectedIds(newSelection);
            setSelectedId(id); // This becomes the new primary selection
          }
        } else {
          // Normal click: Single selection
          // Auto-save multi-select before changing selection
          if (selectedIds.length > 1 && isEditing && modified) {
            const selectedImages = queue.filter(q => selectedIds.includes(q.id));
            // Filter to only images that have keywords to save
            const imagesToSave = selectedImages.filter(img => img.keywords && img.keywords.length > 0);

            console.log('[MULTI-SELECT] Auto-save triggered:', {
              selectedCount: selectedIds.length,
              isEditing,
              modified,
              aggregatedKeywordsCount: keywords.length,
              imagesToSaveCount: imagesToSave.length,
              imagesWithKeywords: selectedImages.map(i => ({ name: i.name, kwCount: (i.keywords || []).length }))
            });

            if (imagesToSave.length > 0) {
              // Save each image with its OWN keywords, not the aggregated keywords
              Promise.all(imagesToSave.map(img => {
                console.log('[MULTI-SELECT] Saving', img.name, 'with', img.keywords.length, 'keywords');
                return saveImage(img, img.keywords, img.designer || designer, true);
              }))
                .then(() => {
                  console.log('[MULTI-SELECT] Auto-save complete - saved', imagesToSave.length, 'images');
                  setModified(false);
                  setIsEditing(false);
                })
                .catch(err => console.error('[MULTI-SELECT] Auto-save failed:', err));
            } else {
              console.log('[MULTI-SELECT] No images with keywords to save');
            }
          } else {
            console.log('[MULTI-SELECT] Auto-save skipped:', {
              selectedCount: selectedIds.length,
              isEditing,
              modified,
              keywordsCount: keywords.length
            });
          }

          setSelectedIds([id]);
          setLastClickedId(id);
          selectImage(id, true); // skipAutoSave=true since we already handled it above
        }
      }, [selectedIds, selectedId, lastClickedId, filteredQueue, selectImage, isEditing, modified, keywords, designer, queue, saveImage]);

      // Aggregate keywords and pending tags when multi-select is active
      useEffect(() => {
        if (selectedIds.length > 1) {
          const selectedImages = queue.filter(q => selectedIds.includes(q.id));
          console.log('[MULTI-SELECT] Aggregating tags from', selectedImages.length, 'images');

          // Build keyword occurrence map for accepted keywords
          const keywordOccurrences = new Map(); // Map<lowercaseValue, { keyword, count }>
          selectedImages.forEach((img, idx) => {
            console.log(`[MULTI-SELECT] Image ${idx + 1}/${selectedImages.length} (${img.name}) has ${(img.keywords || []).length} keywords:`, (img.keywords || []).map(k => k.value).join(', '));
            (img.keywords || []).forEach(kw => {
              const key = kw.value.toLowerCase();
              if (keywordOccurrences.has(key)) {
                keywordOccurrences.get(key).count++;
              } else {
                keywordOccurrences.set(key, { keyword: kw, count: 1 });
              }
            });
          });

          console.log('[MULTI-SELECT] Keyword occurrences:', Array.from(keywordOccurrences.entries()).map(([key, {count}]) => `${key}: ${count}/${selectedImages.length}`));

          // Separate into "all" (in every image) and "some" (in some images)
          const allKeywords = [];
          const someKeywords = [];
          keywordOccurrences.forEach(({ keyword, count }) => {
            console.log(`[MULTI-SELECT] Keyword "${keyword.value}": count=${count}, totalImages=${selectedImages.length}, isAll=${count === selectedImages.length}`);
            if (count === selectedImages.length) {
              allKeywords.push(keyword);
            } else {
              someKeywords.push({ ...keyword, partialCount: count });
            }
          });

          // Build pending occurrence map
          const pendingOccurrences = new Map();
          selectedImages.forEach((img, idx) => {
            console.log(`[MULTI-SELECT] Image ${idx + 1}/${selectedImages.length} (${img.name}) has ${(img.pending || []).length} pending:`, (img.pending || []).map(k => k.value).join(', '));
            (img.pending || []).forEach(kw => {
              const key = kw.value.toLowerCase();
              if (pendingOccurrences.has(key)) {
                pendingOccurrences.get(key).count++;
              } else {
                pendingOccurrences.set(key, { keyword: kw, count: 1 });
              }
            });
          });

          console.log('[MULTI-SELECT] Pending occurrences:', Array.from(pendingOccurrences.entries()).map(([key, {count}]) => `${key}: ${count}/${selectedImages.length}`));

          // Separate pending into "all" and "some"
          const allPending = [];
          const somePending = [];
          pendingOccurrences.forEach(({ keyword, count }) => {
            console.log(`[MULTI-SELECT] Pending "${keyword.value}": count=${count}, totalImages=${selectedImages.length}, isAll=${count === selectedImages.length}`);
            if (count === selectedImages.length) {
              allPending.push(keyword);
            } else {
              somePending.push({ ...keyword, partialCount: count });
            }
          });

          console.log('[MULTI-SELECT] All:', allKeywords.length, 'Some:', someKeywords.length, 'Pending All:', allPending.length, 'Pending Some:', somePending.length);
          console.log('[MULTI-SELECT] Some keywords:', someKeywords.map(k => `${k.value} (${k.partialCount}/${selectedImages.length})`));
          console.log('[MULTI-SELECT] Some pending:', somePending.map(k => `${k.value} (${k.partialCount}/${selectedImages.length})`));

          // Verify partialCount is set correctly
          const combinedKeywords = [...allKeywords, ...someKeywords];
          const combinedPending = [...allPending, ...somePending];
          console.log('[MULTI-SELECT] Combined keywords with partialCount:', combinedKeywords.filter(k => k.partialCount).map(k => `${k.value} (${k.partialCount})`));
          console.log('[MULTI-SELECT] Combined pending with partialCount:', combinedPending.filter(k => k.partialCount).map(k => `${k.value} (${k.partialCount})`));

          // Store aggregated keywords - combine all and some for now, UI will display separately
          setKeywords(combinedKeywords);
          setPending(combinedPending);
          setModified(false);
          setIsEditing(false);
        }
      }, [selectedIds, queue]);

      const analyzeAllPending = () => {
        const pendingImgs = queue.filter(q => q.status === 'pending' && !q.hidden);
        console.log('[ANALYZE ALL] Found', pendingImgs.length, 'pending images, geminiKey:', !!geminiKey);
        pendingImgs.forEach(img => analyzeImage(img));
      };

      // When autoScan is toggled ON, start analyzing pending non-hidden images
      useEffect(() => {
        if (autoScan && geminiKey) {
          const pendingImgs = queue.filter(q => q.status === 'pending' && !q.hidden);
          if (pendingImgs.length > 0) {
            console.log('[AUTO-SCAN] Toggled ON - starting analysis of', pendingImgs.length, 'pending items');
            pendingImgs.forEach(img => analyzeImage(img));
          }
        }
      }, [autoScan]); // Only trigger when autoScan changes

      const reanalyzeSelected = () => {
        if (!selectedImg || !geminiKey) return;
        // Clear cache for this image
        try {
          const cacheKey = 'tagger_analysis_cache';
          const cache = JSON.parse(localStorage.getItem(cacheKey) || '{}');
          delete cache[selectedImg.hash];
          localStorage.setItem(cacheKey, JSON.stringify(cache));
        } catch (e) { console.error('[REANALYZE] Cache clear failed:', e); }
        // Reset to pending and re-analyze
        setQueue(q => q.map(i => i.id === selectedImg.id ? { ...i, status: 'pending', keywords: [], pending: [] } : i));
        setKeywords([]);
        setPending([]);
        analyzeImage({ ...selectedImg, status: 'pending' });
      };

      const [isSavingAll, setIsSavingAll] = useState(false);
      const saveAll = async () => {
        if (isSavingAll) return;
        const toSave = queue.filter(q => !q.hidden && (q.status === 'ready' || q.status === 'editing') && q.keywords?.length > 0);
        if (toSave.length === 0) return;

        setIsSavingAll(true);
        console.log(`[SAVE ALL] Saving ${toSave.length} images...`);

        for (const img of toSave) {
          try {
            // Skip sync when batch saving to avoid cascade
            await saveImage(img, img.keywords, img.designer, true);
          } catch (e) {
            console.error(`[SAVE ALL] Failed to save ${img.name}:`, e);
          }
        }

        setIsSavingAll(false);
        console.log('[SAVE ALL] Done!');
      };

      const readyToSaveCount = queue.filter(q => !q.hidden && (q.status === 'ready' || q.status === 'editing') && q.keywords?.length > 0).length;

      const hideImage = (id, e) => {
        e?.stopPropagation();
        setQueue(q => q.map(i => {
          if (i.id === id) {
            setMemory(prev => ({ ...prev, [i.hash]: { ...prev[i.hash], hidden: true } }));
            return { ...i, hidden: true };
          }
          return i;
        }));
        if (selectedId === id) setSelectedId(null);
      };

      const unhideImage = (id, e) => {
        e?.stopPropagation();
        setQueue(q => q.map(i => {
          if (i.id === id) {
            setMemory(prev => ({ ...prev, [i.hash]: { ...prev[i.hash], hidden: false } }));
            return { ...i, hidden: false };
          }
          return i;
        }));
      };

      const accept = async (id) => {
        const kw = pending.find(k => k.id === id);
        if (kw) {
          console.log(`[ACCEPT] Accepting keyword: "${kw.value}"`);
          setPending(p => p.filter(k => k.id !== id));

          // If it's a partial recommendation in multi-select mode, remove partialCount to apply to all
          const fullKw = (isMultiSelect && kw.partialCount) ? { ...kw } : kw;
          if (isMultiSelect && kw.partialCount) {
            delete fullKw.partialCount;
            console.log(`[ACCEPT] Removed partialCount - will apply to all ${selectedImgs.length} images`);
          }

          // Accept immediately with current categorization (non-blocking)
          const newKeywords = [...keywords, fullKw];
          setKeywords(newKeywords);
          setAccepted(a => a.some(x => x.value.toLowerCase() === fullKw.value.toLowerCase()) ? a : [...a, fullKw]);
          setTaxonomy(t => addToTaxonomy(t, fullKw));
          setModified(true);
          setIsEditing(true);

          // Apply to all selected images (multi-select support) - optimized for performance
          const targetImgs = isMultiSelect ? selectedImgs : [selectedImg];
          console.log(`[ACCEPT] Applying to ${targetImgs.length} selected image(s)`);

          // Build a Set of target IDs for O(1) lookups
          const targetIds = new Set(targetImgs.filter(t => t).map(t => t.id));

          // Get similar images once
          const similarIds = selectedImg ? new Set(getSimilarImages(selectedImg).map(s => s.id)) : new Set();

          setQueue(q => {
            // Only update if we have targets
            if (targetIds.size === 0 && similarIds.size === 0) return q;

            return q.map(img => {
              const isTarget = targetIds.has(img.id);
              const isSimilar = similarIds.has(img.id);

              if (isTarget) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                if (!existingVals.has(fullKw.value.toLowerCase())) {
                  const syncedKw = img.id === selectedImg?.id ? fullKw : { ...fullKw, id: `sync-${Math.random().toString(36).slice(2)}` };
                  return {
                    ...img,
                    keywords: [...(img.keywords || []), syncedKw],
                    pending: img.id === selectedImg?.id ? pending.filter(k => k.id !== id) : img.pending,
                    status: img.status === 'pending' ? 'ready' : (img.id === selectedImg?.id ? 'editing' : img.status)
                  };
                } else if (img.id === selectedImg?.id) {
                  return { ...img, pending: pending.filter(k => k.id !== id) };
                }
              } else if (isSimilar) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                if (!existingVals.has(fullKw.value.toLowerCase())) {
                  const syncedKw = { ...fullKw, id: `sync-${Math.random().toString(36).slice(2)}` };
                  return { ...img, keywords: [...(img.keywords || []), syncedKw], status: img.status === 'pending' ? 'ready' : img.status };
                }
              }
              return img;
            });
          });

          // Background categorization for Custom keywords (non-blocking)
          if (fullKw.path?.[0] === 'Custom' && geminiKey) {
            setTimeout(async () => {
              try {
                const results = await categorizeKeywords(geminiKey, [fullKw.value]);
                if (results.length > 0 && results[0].path) {
                  const categorizedPath = results[0].path;
                  const categorizedType = results[0].type || fullKw.type;
                  console.log(`[ACCEPT] Background categorized "${fullKw.value}" as:`, categorizedPath);

                  // Update the keyword with better categorization
                  setKeywords(current => current.map(k =>
                    k.id === fullKw.id ? { ...k, path: categorizedPath, rootCategory: categorizedPath[0], type: categorizedType } : k
                  ));
                  setAccepted(current => current.map(k =>
                    k.id === fullKw.id ? { ...k, path: categorizedPath, rootCategory: categorizedPath[0], type: categorizedType } : k
                  ));
                }
              } catch (e) {
                console.error('[ACCEPT] Background categorization failed:', e);
              }
            }, 100);
          }
        }
      };

      const block = (id) => {
        const kw = pending.find(k => k.id === id) || ignored.find(k => k.id === id);
        if (kw) {
          setPending(p => p.filter(k => k.id !== id));
          setIgnored(i => i.filter(k => k.id !== id));
          setBlocked(b => [...b, kw]);
          setModified(true);
          setIsEditing(true);
        }
      };

      const ignore = (id) => {
        const kw = pending.find(k => k.id === id);
        if (kw) {
          setPending(p => p.filter(k => k.id !== id));
          setIgnored(i => [...i, kw]);
          setModified(true);
          setIsEditing(true);
        }
      };

      const acceptIgnored = (id) => {
        const kw = ignored.find(k => k.id === id);
        if (kw) {
          setIgnored(i => i.filter(k => k.id !== id));
          const newKeywords = [...keywords, kw];
          setKeywords(newKeywords);
          setAccepted(a => a.some(x => x.value.toLowerCase() === kw.value.toLowerCase()) ? a : [...a, kw]);
          setModified(true);
          setIsEditing(true);

          if (selectedImg) {
            const similar = getSimilarImages(selectedImg);

            // Update both the selected image AND similar images in the queue
            setQueue(q => q.map(img => {
              // Update the current selected image
              if (img.id === selectedImg.id) {
                return { ...img, keywords: newKeywords };
              }
              // Update similar images
              if (similar.some(s => s.id === img.id)) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                if (!existingVals.has(kw.value.toLowerCase())) {
                  const syncedKw = { ...kw, id: `sync-${Math.random().toString(36).slice(2)}` };
                  return { ...img, keywords: [...(img.keywords || []), syncedKw], status: img.status === 'pending' ? 'ready' : img.status };
                }
              }
              return img;
            }));
          }
        }
      };

      const acceptAll = () => {
        const newKeywords = [...keywords, ...pending];

        // Batch update accepted keywords once
        setAccepted(a => {
          const existing = new Set(a.map(x => x.value.toLowerCase()));
          const toAdd = pending.filter(kw => !existing.has(kw.value.toLowerCase()));
          return [...a, ...toAdd];
        });

        setKeywords(newKeywords);
        setPending([]);
        setModified(true);
        setIsEditing(true);

        // Apply to all selected images (multi-select support) - optimized for performance
        const targetImgs = isMultiSelect ? selectedImgs : [selectedImg];
        console.log(`[ACCEPT ALL] Applying to ${targetImgs.length} selected image(s)`);

        // Build a Set of target IDs for O(1) lookups
        const targetIds = new Set(targetImgs.filter(t => t).map(t => t.id));

        // Get similar images once
        const similarIds = selectedImg ? new Set(getSimilarImages(selectedImg).map(s => s.id)) : new Set();

        setQueue(q => {
          // Only update if we have targets
          if (targetIds.size === 0 && similarIds.size === 0) return q;

          return q.map(img => {
            const isTarget = targetIds.has(img.id);
            const isSimilar = similarIds.has(img.id);

            if (isTarget) {
              const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
              const newKws = pending
                .filter(kw => !existingVals.has(kw.value.toLowerCase()))
                .map(kw => img.id === selectedImg?.id ? kw : { ...kw, id: `sync-${Math.random().toString(36).slice(2)}` });
              if (newKws.length > 0 || img.id === selectedImg?.id) {
                return {
                  ...img,
                  keywords: img.id === selectedImg?.id ? newKeywords : [...(img.keywords || []), ...newKws],
                  pending: img.id === selectedImg?.id ? [] : img.pending,
                  status: img.status === 'pending' ? 'ready' : (img.id === selectedImg?.id ? 'editing' : img.status)
                };
              }
            } else if (isSimilar) {
              const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
              const newKws = pending
                .filter(kw => !existingVals.has(kw.value.toLowerCase()))
                .map(kw => ({ ...kw, id: `sync-${Math.random().toString(36).slice(2)}` }));
              if (newKws.length > 0) {
                return { ...img, keywords: [...(img.keywords || []), ...newKws], status: img.status === 'pending' ? 'ready' : img.status };
              }
            }
            return img;
          });
        });
      };

      const removeKw = (id) => {
        // Find the keyword being removed
        const kw = keywords.find(k => k.id === id);
        if (kw) {
          // Move it back to pending (recommendations) instead of deleting
          // Check if it already exists in pending to avoid duplicates
          setPending(p => {
            const exists = p.some(existing => existing.value.toLowerCase() === kw.value.toLowerCase());
            return exists ? p : [...p, kw];
          });
        }
        setKeywords(c => c.filter(k => k.id !== id));
        setModified(true);
        setIsEditing(true);
      };

      // Add a partial keyword to all selected images
      const addToAll = (kw) => {
        console.log(`[ADD-TO-ALL] Adding "${kw.value}" to all ${selectedImgs.length} selected images`);

        // Remove partialCount to make it a full keyword
        const fullKw = { ...kw };
        delete fullKw.partialCount;

        // Update local keywords state
        setKeywords(current => current.map(k =>
          k.id === kw.id ? fullKw : k
        ));

        // Apply to all selected images in the queue
        const targetIds = new Set(selectedImgs.filter(t => t).map(t => t.id));

        setQueue(q => q.map(img => {
          if (!targetIds.has(img.id)) return img;

          // Check if keyword already exists
          const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
          if (existingVals.has(kw.value.toLowerCase())) return img;

          // Add keyword with unique ID
          const syncedKw = { ...fullKw, id: `sync-${Math.random().toString(36).slice(2)}` };
          return {
            ...img,
            keywords: [...(img.keywords || []), syncedKw],
            status: img.status === 'pending' ? 'ready' : img.status
          };
        }));

        setModified(true);
        setIsEditing(true);
      };

      const removeAllPartial = () => {
        const partialKeywords = keywords.filter(k => k.partialCount);
        console.log(`[REMOVE-ALL-PARTIAL] Removing ${partialKeywords.length} partial keywords from accepted and moving to pending`);

        // Remove all partial keywords from the keywords list
        setKeywords(current => current.filter(k => !k.partialCount));

        // Add them to pending (as recommendations)
        const newPending = partialKeywords.map(k => {
          const kw = { ...k };
          delete kw.partialCount; // Remove the partial count
          return kw;
        });
        setPending(current => [...current, ...newPending]);

        // Remove from all selected images in the queue
        const targetIds = new Set(selectedImgs.filter(t => t).map(t => t.id));
        const kwValues = new Set(partialKeywords.map(k => k.value.toLowerCase()));

        setQueue(q => q.map(img => {
          if (!targetIds.has(img.id)) return img;

          // Filter out the partial keywords
          const filteredKeywords = (img.keywords || []).filter(k => !kwValues.has(k.value.toLowerCase()));

          // Add to pending for this image
          const imgPending = img.pending || [];
          const existingPendingVals = new Set(imgPending.map(p => p.value.toLowerCase()));
          const newImgPending = [...imgPending, ...newPending.filter(k => !existingPendingVals.has(k.value.toLowerCase()))];

          return {
            ...img,
            keywords: filteredKeywords,
            pending: newImgPending
          };
        }));

        setModified(true);
        setIsEditing(true);
      };

      const deleteFromTaxonomy = (id) => {
        setAccepted(a => a.filter(k => k.id !== id));
      };

      const deleteFromMasterTaxonomy = (path, value) => {
        setTaxonomy(prevTax => {
          const newTax = JSON.parse(JSON.stringify(prevTax));
          let current = newTax;

          for (let i = 0; i < path.length - 1; i++) {
            if (!current[path[i]]) return prevTax;
            current = current[path[i]];
          }

          const leafKey = path[path.length - 1];
          if (Array.isArray(current[leafKey])) {
            current[leafKey] = current[leafKey].filter(v => v.toLowerCase() !== value.toLowerCase());
          } else if (current[leafKey]?._items) {
            current[leafKey]._items = current[leafKey]._items.filter(v => v.toLowerCase() !== value.toLowerCase());
          }
          return newTax;
        });
      };

      const addCustom = async () => {
        const val = customInput.trim();
        if (!val) return;
        const newKws = [];
        const uncategorizedKws = [];

        // Build all keywords first (non-blocking)
        splitBrandModel(val).forEach(part => {
          const path = part.path[0] === 'Custom' ? findPath(part.value, part.type) : part.path;
          const kw = { id: `custom-${Date.now()}-${Math.random().toString(36).slice(2)}`, value: part.value, confidence: 1, type: part.type, path, rootCategory: path[0] };
          newKws.push(kw);

          // Track uncategorized keywords for background research
          if (path[0] === 'Custom' && geminiKey) {
            uncategorizedKws.push(kw);
          }
        });

        // Batch update state once (much faster than multiple updates)
        setKeywords(c => [...c, ...newKws]);
        setAccepted(a => {
          const existing = new Set(a.map(x => x.value.toLowerCase()));
          const toAdd = newKws.filter(kw => !existing.has(kw.value.toLowerCase()));
          return [...a, ...toAdd];
        });
        setTaxonomy(t => {
          let updatedTax = t;
          newKws.forEach(kw => {
            updatedTax = addToTaxonomy(updatedTax, kw);
          });
          return updatedTax;
        });

        setCustomInput('');
        setModified(true);
        setIsEditing(true);

        // Apply to all selected images (multi-select support) - optimized for performance
        if (newKws.length > 0) {
          const targetImgs = isMultiSelect ? selectedImgs : [selectedImg];
          console.log(`[ADD CUSTOM] Applying to ${targetImgs.length} selected image(s)`);

          // Build a Set of target IDs for O(1) lookups
          const targetIds = new Set(targetImgs.filter(t => t).map(t => t.id));

          // Get similar images once
          const similarIds = selectedImg ? new Set(getSimilarImages(selectedImg).map(s => s.id)) : new Set();

          setQueue(q => {
            // Only update if we have targets
            if (targetIds.size === 0 && similarIds.size === 0) return q;

            return q.map(img => {
              const isTarget = targetIds.has(img.id);
              const isSimilar = similarIds.has(img.id);
              const isPrimary = img.id === selectedImg?.id;

              if (isTarget || isSimilar) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                const syncKws = newKws
                  .filter(kw => !existingVals.has(kw.value.toLowerCase()))
                  .map(kw => isPrimary ? kw : { ...kw, id: `sync-${Math.random().toString(36).slice(2)}` });

                if (syncKws.length > 0) {
                  return { ...img, keywords: [...(img.keywords || []), ...syncKws], status: img.status === 'pending' ? 'ready' : img.status };
                }
              }
              return img;
            });
          });
        }

        // Background research for uncategorized keywords
        if (uncategorizedKws.length > 0 && geminiKey) {
          setTimeout(async () => {
            for (const kw of uncategorizedKws) {
              const result = await researchKeyword(geminiKey, kw.value);
              if (result && result.path && result.path.length > 0 && result.path[0] !== 'Custom') {
                console.log(`[AUTO-CATEGORIZE] ${kw.value} -> ${result.path.join(' > ')}`);
                // Update the keyword's path in taxonomy
                setTaxonomy(prevTax => {
                  const newTax = JSON.parse(JSON.stringify(prevTax));
                  // Remove from Custom
                  if (newTax.Custom) {
                    if (Array.isArray(newTax.Custom)) {
                      newTax.Custom = newTax.Custom.filter(v => v.toLowerCase() !== kw.value.toLowerCase());
                    } else if (newTax.Custom._items) {
                      newTax.Custom._items = newTax.Custom._items.filter(v => v.toLowerCase() !== kw.value.toLowerCase());
                    }
                  }
                  // Add to new path
                  let current = newTax;
                  for (let i = 0; i < result.path.length; i++) {
                    const segment = result.path[i];
                    if (!current[segment]) current[segment] = i === result.path.length - 1 ? [] : {};
                    if (i === result.path.length - 1) {
                      if (Array.isArray(current[segment])) {
                        if (!current[segment].includes(kw.value)) current[segment].push(kw.value);
                      } else {
                        if (!current[segment]._items) current[segment]._items = [];
                        if (!current[segment]._items.includes(kw.value)) current[segment]._items.push(kw.value);
                      }
                    } else {
                      current = current[segment];
                    }
                  }
                  localStorage.setItem(TAXONOMY_KEY, JSON.stringify(newTax));
                  return newTax;
                });
                // Update keyword in current keywords list
                setKeywords(prev => prev.map(k =>
                  k.value.toLowerCase() === kw.value.toLowerCase()
                    ? { ...k, path: result.path, rootCategory: result.path[0], type: result.type || k.type }
                    : k
                ));
              }
            }
          }, 100);
        }
      };

      useEffect(() => {
        // Skip this in multi-select mode - the multi-select aggregation useEffect handles it
        if (selectedIds.length > 1) return;

        if (selectedImg && (selectedImg.status === 'ready' || selectedImg.status === 'done') && !modified && !isEditing) {
          setKeywords(selectedImg.keywords || []);
          setPending(selectedImg.pending || []);
          setDesigner(selectedImg.designer || null);
          setVisionData(selectedImg.visionData || null);
        }
      }, [selectedImg?.id, selectedImg?.status, selectedIds.length]);

      const getCustomKeywords = useCallback(() => {
        const customs = [];
        const collectCustom = (obj, path = []) => {
          for (const [key, value] of Object.entries(obj)) {
            if (key === '_items') continue;
            const currentPath = [...path, key];
            if (key === 'Custom' && Array.isArray(value)) {
              customs.push(...value);
            } else if (key === 'Custom' && value?._items) {
              customs.push(...value._items);
            } else if (typeof value === 'object' && value !== null) {
              collectCustom(value, currentPath);
            }
          }
        };
        collectCustom(taxonomy);
        return customs;
      }, [taxonomy]);

      const runCategorization = async () => {
        if (!geminiKey || isCategorizing) return;

        const customKws = getCustomKeywords();
        if (customKws.length === 0) {
          console.log('[CATEGORIZE] No custom keywords to categorize');
          return;
        }

        setIsCategorizing(true);
        console.log(`[CATEGORIZE] Categorizing ${customKws.length} custom keywords...`);

        try {
          const batchSize = 20;
          for (let i = 0; i < customKws.length; i += batchSize) {
            const batch = customKws.slice(i, i + batchSize);
            const results = await categorizeKeywords(geminiKey, batch);

            if (results.length > 0) {
              setTaxonomy(prevTax => {
                let newTax = JSON.parse(JSON.stringify(prevTax));

                results.forEach(result => {
                  if (!result.path || result.path.length === 0 || result.path[0] === 'Custom') return;

                  if (Array.isArray(newTax.Custom)) {
                    newTax.Custom = newTax.Custom.filter(k => k.toLowerCase() !== result.keyword.toLowerCase());
                  } else if (newTax.Custom?._items) {
                    newTax.Custom._items = newTax.Custom._items.filter(k => k.toLowerCase() !== result.keyword.toLowerCase());
                  }

                  let current = newTax;
                  for (let j = 0; j < result.path.length; j++) {
                    const key = result.path[j];
                    if (j === result.path.length - 1) {
                      if (Array.isArray(current[key])) {
                        if (!current[key].some(k => k.toLowerCase() === result.keyword.toLowerCase())) {
                          current[key].push(result.keyword);
                        }
                      } else if (typeof current[key] === 'object' && current[key] !== null) {
                        if (!current[key]._items) current[key]._items = [];
                        if (!current[key]._items.some(k => k.toLowerCase() === result.keyword.toLowerCase())) {
                          current[key]._items.push(result.keyword);
                        }
                      } else if (current[key] === undefined) {
                        current[key] = [result.keyword];
                      }
                    } else {
                      if (current[key] === undefined) {
                        current[key] = {};
                      } else if (Array.isArray(current[key])) {
                        current[key] = { _items: current[key] };
                      }
                      current = current[key];
                    }
                  }

                  console.log(`[CATEGORIZE] Moved "${result.keyword}" to ${result.path.join(' > ')}`);
                });

                return newTax;
              });
            }
          }
          console.log('[CATEGORIZE] Done!');
        } catch (e) {
          console.error('[CATEGORIZE] Error:', e);
        } finally {
          setIsCategorizing(false);
        }
      };

      const customCount = getCustomKeywords().length;

      // Auto-run categorization when custom keywords accumulate
      const autoCategorizeTimeoutRef = useRef(null);
      useEffect(() => {
        if (customCount > 0 && geminiKey && !isCategorizing) {
          // Clear any pending timeout
          if (autoCategorizeTimeoutRef.current) {
            clearTimeout(autoCategorizeTimeoutRef.current);
          }
          // Schedule auto-categorization after 3 seconds of inactivity
          autoCategorizeTimeoutRef.current = setTimeout(() => {
            console.log('[AUTO-CATEGORIZE] Triggering auto-categorization for', customCount, 'custom keywords');
            runCategorization();
          }, 3000);
        }
        return () => {
          if (autoCategorizeTimeoutRef.current) {
            clearTimeout(autoCategorizeTimeoutRef.current);
          }
        };
      }, [customCount, geminiKey, isCategorizing]);

      // Auto-consolidation disabled - was causing false matches
      const [isConsolidating, setIsConsolidating] = useState(false);

      const tree = buildTree(accepted);
      const getColor = (r) => ROOT_COLORS[r] || '#94a3b8';

      const totalCount = queue.length;
      const hiddenCount = queue.filter(q => q.hidden).length;
      const doneCount = queue.filter(q => q.status === 'done').length;
      const readyCount = queue.filter(q => (q.status === 'ready' || q.status === 'editing') && !q.hidden).length;
      const analyzingCount = queue.filter(q => q.status === 'analyzing').length;
      const pendingCount = queue.filter(q => q.status === 'pending' && !q.hidden).length;
      const editingCount = queue.filter(q => q.status === 'editing' && !q.hidden).length;
      const errorCount = queue.filter(q => q.status === 'error').length;
      const similarCount = selectedImg ? getSimilarImages(selectedImg).length : 0;

      // Retry failed analyses
      const retryFailed = useCallback(() => {
        const failed = queue.filter(q => q.status === 'error');
        console.log('[RETRY] Retrying', failed.length, 'failed analyses');
        failed.forEach(img => {
          setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'pending' } : i));
          setTimeout(() => analyzeImage({ ...img, status: 'pending' }), 100);
        });
      }, [queue, analyzeImage]);

      const thumbSizes = [60, 90, 130, 180];
      const currentThumbSize = thumbSizes[thumbSize];

      // Unified style system
      const s = {
        bg: '#0a0a0a',
        panel: '#111',
        panelHover: '#1a1a1a',
        border: '#222',
        text: '#9ca3af',
        bright: '#f3f4f6',
        muted: '#6b7280',
        fontSize: 14,
        radius: 8,
        radiusSm: 6,
        radiusLg: 12
      };

      return (
        <div ref={containerRef} tabIndex={0} style={{ display: 'flex', flexDirection: 'column', height: '100vh', width: '100vw', fontSize: s.fontSize, lineHeight: 1.5, background: s.bg, color: s.text, outline: 'none' }}>
          <input ref={fileRef} type="file" accept="image/*" multiple onChange={handleFileInput} style={{ display: 'none' }} />
          <input ref={folderRef} type="file" accept="image/*" multiple webkitdirectory="" onChange={handleFileInput} style={{ display: 'none' }} />

          {/* TOOLBAR */}
          <div style={{ height: 56, background: s.panel, display: 'flex', alignItems: 'center', padding: '0 16px', gap: 12, borderBottom: `1px solid ${s.border}`, flexShrink: 0 }}>
            {/* Left side - Import buttons */}
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <button onClick={() => fileRef.current?.click()} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '8px 14px', background: '#1f2937', color: s.bright, border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                <Icon name="add_photo_alternate" size={18} /> Files
              </button>
              <button onClick={() => folderRef.current?.click()} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '8px 14px', background: '#1f2937', color: s.bright, border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                <Icon name="folder_open" size={18} /> Folder
              </button>
              {queue.filter(q => q.status !== 'done' && !q.hidden).length > 0 && (
                <button onClick={refreshAnalysis} title="Clear cache and re-analyze non-done images" style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: 40, height: 40, background: '#1f2937', color: '#60a5fa', border: 'none', borderRadius: s.radius, cursor: 'pointer' }}>
                  <Icon name="refresh" size={20} />
                </button>
              )}
              {errorCount > 0 && (
                <button onClick={retryFailed} title={`Retry ${errorCount} failed analyses`} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '8px 12px', background: '#1f2937', color: '#f87171', border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                  <Icon name="refresh" size={18} /> Retry ({errorCount})
                </button>
              )}
            </div>

            <div style={{ width: 1, height: 24, background: s.border }} />

            {/* Logo & Status */}
            <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
              <div style={{ width: 20, height: 20, background: 'linear-gradient(135deg, #8b5cf6, #3b82f6)', borderRadius: 5 }} />
              <span style={{ color: s.bright, fontWeight: 600, fontSize: s.fontSize }}>MegaTagger</span>
            </div>

            <span style={{ color: s.muted, fontSize: s.fontSize }}>
              {filteredQueue.length}/{totalCount}
              {analyzingCount > 0 && <span style={{ color: '#fbbf24' }}> · {analyzingCount} analyzing</span>}
              {readyCount > 0 && <span style={{ color: '#60a5fa' }}> · {readyCount} ready</span>}
              {(() => {
                const mem = getMemoryUsage();
                if (mem && parseInt(mem.percent) > 80) {
                  return <span style={{ color: '#f87171' }}> · Mem: {mem.percent}%</span>;
                }
                return null;
              })()}
            </span>

            {/* Right side - Actions */}
            <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: 10 }}>
              {readyToSaveCount > 0 && (
                <button onClick={saveAll} disabled={isSavingAll} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '8px 16px', background: isSavingAll ? '#374151' : '#10b981', color: isSavingAll ? '#9ca3af' : 'white', border: 'none', borderRadius: s.radius, cursor: isSavingAll ? 'default' : 'pointer', fontSize: s.fontSize, fontWeight: 500 }}>
                  <Icon name={isSavingAll ? "hourglass_empty" : "save"} size={18} /> {isSavingAll ? 'Saving...' : `Save All (${readyToSaveCount})`}
                </button>
              )}
              {outputDir && (
                <div style={{ display: 'flex', alignItems: 'center', gap: 4, color: '#10b981', fontSize: s.fontSize }}>
                  <Icon name="check_circle" size={16} filled /> Auto-save
                </div>
              )}
              <button onClick={() => setShowSettings(true)} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: 40, height: 40, background: 'transparent', color: s.muted, border: 'none', borderRadius: s.radius, cursor: 'pointer' }}>
                <Icon name="settings" size={22} />
              </button>
            </div>
          </div>

          {/* MAIN */}
          <div ref={mainPanelRef} style={{ flex: 1, display: 'flex', overflow: 'hidden', width: '100%', cursor: isDraggingDivider ? 'col-resize' : 'default' }}>

            {/* LEFT - GRID */}
            <div style={{ width: `${gridWidth}%`, minWidth: 250, background: s.panel, display: 'flex', flexDirection: 'column', transition: isDraggingDivider ? 'none' : 'width 0.2s ease-out' }}>
              <div style={{ padding: '10px 12px', borderBottom: `1px solid ${s.border}`, display: 'flex', gap: 8, alignItems: 'center', flexWrap: 'wrap' }}>
                <button onClick={() => setShowPending(!showPending)}
                  style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 12px', background: showPending ? 'rgba(96,165,250,0.15)' : '#1f2937', color: showPending ? '#60a5fa' : s.muted, border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: s.fontSize }}>
                  <Icon name="rate_review" size={16} /> Ready ({readyCount})
                </button>
                <button onClick={() => setShowAnalyzing(!showAnalyzing)}
                  style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 12px', background: showAnalyzing ? 'rgba(251,191,36,0.15)' : '#1f2937', color: showAnalyzing ? '#fbbf24' : s.muted, border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: s.fontSize }}>
                  <Icon name="hourglass_empty" size={16} /> Analyzing ({analyzingCount})
                </button>
                <button onClick={() => setShowDone(!showDone)}
                  style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 12px', background: showDone ? 'rgba(74,222,128,0.15)' : '#1f2937', color: showDone ? '#4ade80' : s.muted, border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: s.fontSize }}>
                  <Icon name="check_circle" size={16} /> Done ({doneCount})
                </button>
                <button onClick={() => setShowHidden(!showHidden)}
                  style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 12px', background: showHidden ? 'rgba(248,113,113,0.15)' : '#1f2937', color: showHidden ? '#f87171' : s.muted, border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: s.fontSize }}>
                  <Icon name="visibility_off" size={16} /> Hidden ({hiddenCount})
                </button>
                <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: 8 }}>
                  {selectedImg && selectedImg.status !== 'pending' && selectedImg.status !== 'analyzing' && (
                    <button onClick={reanalyzeSelected} title="Re-analyze selected image"
                      style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: 32, height: 32, background: '#1f2937', color: s.muted, border: 'none', borderRadius: s.radiusSm, cursor: 'pointer' }}>
                      <Icon name="refresh" size={18} />
                    </button>
                  )}
                  <Toggle
                    checked={autoScan}
                    onChange={setAutoScan}
                    label={`Auto${pendingCount > 0 ? ` (${pendingCount})` : ''}`}
                    disabled={!geminiKey}
                  />
                  <div style={{ display: 'flex', gap: 2, background: '#1f2937', borderRadius: s.radiusSm, padding: 2 }}>
                    {['S', 'M', 'L', 'XL'].map((label, i) => (
                      <button key={label} onClick={() => setThumbSize(i)}
                        style={{ padding: '4px 10px', background: thumbSize === i ? '#374151' : 'transparent', color: thumbSize === i ? s.bright : s.muted, border: 'none', borderRadius: 4, cursor: 'pointer', fontSize: 13, fontWeight: thumbSize === i ? 500 : 400 }}>
                        {label}
                      </button>
                    ))}
                  </div>
                </div>
              </div>
              <div style={{ flex: 1, overflow: 'auto', padding: 12 }}>
                {filteredQueue.length === 0 ? (
                  <div style={{ padding: 60, textAlign: 'center', color: s.muted }}>
                    <Icon name="add_photo_alternate" size={64} style={{ opacity: 0.3, display: 'block', margin: '0 auto 16px' }} />
                    <div style={{ fontSize: s.fontSize, marginBottom: 8 }}>Drop images here</div>
                    <div style={{ fontSize: 13, color: '#4b5563' }}>Use arrow keys to navigate</div>
                  </div>
                ) : (
                  <>
                    {batchProgress && (
                      <div style={{ marginBottom: 12, background: '#1f2937', padding: 12, borderRadius: s.radius }}>
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: 8 }}>
                          <span style={{ fontSize: 13, color: s.text }}>
                            <Icon name="hourglass_empty" size={16} style={{ marginRight: 6, verticalAlign: 'middle' }} />
                            Processing batch {batchProgress.current}/{batchProgress.total}
                          </span>
                          <span style={{ fontSize: 13, color: '#fbbf24' }}>
                            {Math.round((batchProgress.current / batchProgress.total) * 100)}%
                          </span>
                        </div>
                        <div style={{ height: 4, background: '#374151', borderRadius: 2, overflow: 'hidden' }}>
                          <div style={{ height: '100%', background: '#fbbf24', width: `${(batchProgress.current / batchProgress.total) * 100}%`, transition: 'width 0.3s ease' }} />
                        </div>
                      </div>
                    )}
                    <div style={{ display: 'grid', gridTemplateColumns: `repeat(auto-fill, minmax(${currentThumbSize}px, 1fr))`, gap: 8 }}>
                      {filteredQueue.map(item => (
                        <ThumbnailImage
                          key={item.id}
                          item={item}
                          isSelected={selectedIds.includes(item.id)}
                          onSelect={handleThumbnailClick}
                          onHide={hideImage}
                          onUnhide={unhideImage}
                          thumbSize={currentThumbSize}
                        />
                      ))}
                    </div>
                  </>
                )}
              </div>
            </div>

            {/* RESIZABLE DIVIDER */}
            <div
              onMouseDown={handleDividerMouseDown}
              style={{
                width: 12,
                background: isDraggingDivider ? s.border : 'transparent',
                cursor: 'col-resize',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                flexShrink: 0,
                transition: 'background 0.15s'
              }}
              onMouseEnter={(e) => e.currentTarget.style.background = s.border}
              onMouseLeave={(e) => !isDraggingDivider && (e.currentTarget.style.background = 'transparent')}
            >
              <div style={{
                width: 4,
                height: 40,
                background: '#4b5563',
                borderRadius: 2,
                opacity: 0.6
              }} />
            </div>

            {/* CENTER - PREVIEW */}
            <div style={{ flex: 1, minWidth: 280, display: 'flex', flexDirection: 'column', background: s.bg }}>
              {selectedImg ? (
                <>
                  <div style={{ height: '35%', minHeight: 140, background: '#000', display: 'flex', alignItems: 'center', justifyContent: 'center', position: 'relative' }}>
                    <img src={selectedImg.url} style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain' }} />
                    <div style={{ position: 'absolute', bottom: 8, left: 8, background: 'rgba(0,0,0,0.85)', padding: '4px 10px', borderRadius: s.radiusSm, color: s.text, fontSize: 13, maxWidth: '85%', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                      {selectedImg.name}
                    </div>
                    {isMultiSelect && (
                      <div style={{ position: 'absolute', bottom: 8, right: 8, background: 'rgba(96,165,250,0.9)', color: '#000', padding: '6px 10px', borderRadius: s.radiusSm, fontSize: 13, fontWeight: 500, display: 'flex', alignItems: 'center', gap: 6 }}>
                        <Icon name="select_all" size={16} /> {selectedIds.length} selected
                      </div>
                    )}
                    {modified && (
                      <div style={{ position: 'absolute', top: 8, right: 8, background: '#fbbf24', color: '#000', padding: '4px 8px', borderRadius: s.radiusSm, fontSize: 12, fontWeight: 500, display: 'flex', alignItems: 'center', gap: 4 }}>
                        <Icon name="edit" size={14} /> Unsaved
                      </div>
                    )}
                    {downloadedLarger && (
                      <div style={{ position: 'absolute', top: 8, left: 8, background: '#10b981', color: '#fff', padding: '4px 8px', borderRadius: s.radiusSm, fontSize: 12, display: 'flex', alignItems: 'center', gap: 4 }}>
                        <Icon name="download" size={14} /> {(downloadedLarger.size / 1024 / 1024).toFixed(1)}MB
                      </div>
                    )}
                  </div>

                  <div style={{ flex: 1, overflow: 'auto', padding: 14 }}>
                    {selectedImg.status === 'analyzing' && (
                      <div style={{ textAlign: 'center', padding: 40, color: s.muted }}>
                        <Icon name="hourglass_empty" size={36} style={{ display: 'block', margin: '0 auto 12px', color: '#fbbf24' }} />
                        <div style={{ fontSize: s.fontSize }}>Analyzing...</div>
                      </div>
                    )}

                    {selectedImg.status === 'error' && (
                      <div style={{ textAlign: 'center', padding: 40, color: '#f87171' }}>
                        <Icon name="error" size={36} style={{ display: 'block', margin: '0 auto 12px' }} />
                        <div style={{ fontSize: s.fontSize, marginBottom: 12 }}>Analysis failed</div>
                        <button onClick={() => { setQueue(q => q.map(i => i.id === selectedImg.id ? {...i, status: 'pending'} : i)); analyzeImage({...selectedImg, status: 'pending'}); }}
                          style={{ display: 'inline-flex', alignItems: 'center', gap: 6, padding: '8px 16px', background: '#2563eb', color: 'white', border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                          <Icon name="refresh" size={16} /> Retry
                        </button>
                      </div>
                    )}

                    {(selectedImg.status === 'ready' || selectedImg.status === 'done' || selectedImg.status === 'editing' || isEditing) && (
                      <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
                        {(designer?.designer || designer?.designers?.length > 0) && (
                          <div style={{ background: 'rgba(167,139,250,0.1)', padding: '10px 12px', borderRadius: s.radius, border: '1px solid rgba(167,139,250,0.25)' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#a78bfa', fontSize: s.fontSize }}>
                              <Icon name="brush" size={18} />
                              {designer.designers?.length > 1 ? designer.designers.join(', ') : designer.designer}
                            </div>
                          </div>
                        )}

                        {similarCount > 0 && (
                          <div style={{ background: 'rgba(251,191,36,0.1)', padding: '10px 12px', borderRadius: s.radius, border: '1px solid rgba(251,191,36,0.25)' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#fbbf24', fontSize: s.fontSize }}>
                              <Icon name="link" size={18} />
                              {similarCount} similar image{similarCount > 1 ? 's' : ''} will sync
                            </div>
                          </div>
                        )}

                        {visionData?.matchingImages?.filter(m => m.type === 'full').length > 0 && (
                          <div style={{ background: 'rgba(96,165,250,0.1)', padding: '10px 12px', borderRadius: s.radius, border: '1px solid rgba(96,165,250,0.25)' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#60a5fa', fontSize: s.fontSize, marginBottom: 8 }}>
                              <Icon name="image_search" size={18} />
                              {visionData.matchingImages.filter(m => m.type === 'full').length} exact matches
                            </div>
                            <div style={{ display: 'flex', gap: 6, flexWrap: 'wrap' }}>
                              {visionData.matchingImages.filter(m => m.type === 'full').slice(0, 4).map((img, i) => {
                                const domain = new URL(img.url).hostname.replace('www.', '');
                                return (
                                  <a key={i} href={img.url} target="_blank" rel="noreferrer" style={{ color: '#60a5fa', fontSize: 12, textDecoration: 'none', padding: '4px 8px', background: 'rgba(96,165,250,0.15)', borderRadius: s.radiusSm }}>
                                    {domain}
                                  </a>
                                );
                              })}
                            </div>
                          </div>
                        )}

                        {/* REQUIRED CATEGORIES */}
                        <div style={{ background: s.panel, borderRadius: s.radius, padding: 12, border: `1px solid ${s.border}` }}>
                          <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#ec4899', marginBottom: 10, fontSize: s.fontSize, fontWeight: 500 }}>
                            <Icon name="category" size={18} />
                            Primary Category (Required)
                          </div>
                          <div style={{ display: 'flex', flexDirection: 'column', gap: 6 }}>
                            {REQUIRED_CATEGORIES.map(cat => {
                              const hasCategory = keywords.some(k => k.value === cat);
                              return (
                                <button
                                  key={cat}
                                  onClick={() => {
                                    if (hasCategory) {
                                      // Remove the category
                                      const catKeyword = keywords.find(k => k.value === cat);
                                      if (catKeyword) removeKw(catKeyword.id);
                                    } else {
                                      // Add the category
                                      const path = smartCategorize({ value: cat, type: 'keyword' });
                                      const newKw = {
                                        id: Math.random().toString(36).slice(2),
                                        value: cat,
                                        confidence: 1.0,
                                        type: 'keyword',
                                        path: path,
                                        rootCategory: path[0],
                                        source: 'manual'
                                      };
                                      setKeywords([...keywords, newKw]);
                                      setModified(true);
                                      setIsEditing(true);
                                    }
                                  }}
                                  style={{
                                    padding: '8px 12px',
                                    background: hasCategory ? '#ec489920' : 'rgba(255,255,255,0.03)',
                                    color: hasCategory ? '#ec4899' : '#9ca3af',
                                    border: hasCategory ? '1px solid #ec489950' : '1px solid #374151',
                                    borderRadius: s.radiusSm,
                                    cursor: 'pointer',
                                    fontSize: 13,
                                    fontWeight: hasCategory ? 500 : 400,
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: 8,
                                    transition: 'all 0.15s ease'
                                  }}>
                                  <Icon name={hasCategory ? "check_circle" : "radio_button_unchecked"} size={16} />
                                  {cat}
                                </button>
                              );
                            })}
                          </div>
                        </div>

                        {keywords.length > 0 && (
                          <div style={{ background: s.panel, borderRadius: s.radius, padding: 12, border: `1px solid ${s.border}` }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#4ade80', marginBottom: 10, fontSize: s.fontSize, fontWeight: 500 }}>
                              <Icon name="sell" size={18} />
                              Tagged ({keywords.length})
                            </div>

                            {/* Show "Applied to All" and "Applied to Some" sections in multi-select mode */}
                            {isMultiSelect ? (
                              <>
                                {/* DEBUG: Show what we have */}
                                {(() => {
                                  const withPartial = keywords.filter(k => k.partialCount);
                                  const withoutPartial = keywords.filter(k => !k.partialCount);
                                  console.log('[UI-RENDER] Keywords with partialCount:', withPartial.length, withPartial.map(k => k.value));
                                  console.log('[UI-RENDER] Keywords without partialCount:', withoutPartial.length, withoutPartial.map(k => k.value));
                                  return null;
                                })()}

                                {keywords.filter(k => !k.partialCount).length > 0 && (
                                  <div style={{ marginBottom: 12 }}>
                                    <div style={{ fontSize: 13, color: '#4ade80', marginBottom: 8, fontWeight: 600, display: 'flex', alignItems: 'center', gap: 6 }}>
                                      <Icon name="done_all" size={16} />
                                      Applied to All ({keywords.filter(k => !k.partialCount).length})
                                    </div>
                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6 }}>
                                      {keywords.filter(k => !k.partialCount).map(k => (
                                        <motion.span
                                          key={k.id}
                                          initial={{ opacity: 0, scale: 0.8 }}
                                          animate={{ opacity: 1, scale: 1 }}
                                          style={{ padding: '5px 10px', background: `${getColor(k.rootCategory)}15`, color: getColor(k.rootCategory), borderRadius: 20, fontSize: 13, display: 'flex', alignItems: 'center', gap: 6, border: `1px solid ${getColor(k.rootCategory)}30` }}>
                                          {k.source === 'vision' && <Icon name="image_search" size={14} />}
                                          {k.source === 'filename' && <Icon name="description" size={14} />}
                                          {k.value}
                                          <span onClick={() => removeKw(k.id)} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 2, display: 'flex' }}>
                                            <Icon name="close" size={14} />
                                          </span>
                                        </motion.span>
                                      ))}
                                    </div>
                                  </div>
                                )}

                                {keywords.filter(k => k.partialCount).length > 0 && (
                                  <div>
                                    <div style={{ fontSize: 13, color: '#fbbf24', marginBottom: 8, fontWeight: 600, display: 'flex', alignItems: 'center', gap: 6, justifyContent: 'space-between' }}>
                                      <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                                        <Icon name="content_copy" size={16} />
                                        Applied to Some ({keywords.filter(k => k.partialCount).length}) - Click to add to all
                                      </div>
                                      <button onClick={removeAllPartial} style={{ display: 'flex', alignItems: 'center', gap: 4, padding: '4px 10px', background: 'rgba(251,191,36,0.15)', color: '#fbbf24', border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: 12 }}>
                                        <Icon name="remove_circle" size={14} /> Remove All
                                      </button>
                                    </div>
                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6 }}>
                                      {keywords.filter(k => k.partialCount).map(k => (
                                        <motion.span
                                          key={k.id}
                                          initial={{ opacity: 0, scale: 0.8 }}
                                          animate={{ opacity: 1, scale: 1 }}
                                          onClick={(e) => {
                                            if (!e.target.closest('[data-action]')) {
                                              addToAll(k);
                                            }
                                          }}
                                          style={{ padding: '5px 10px', background: `${getColor(k.rootCategory)}15`, color: getColor(k.rootCategory), borderRadius: 20, fontSize: 13, display: 'flex', alignItems: 'center', gap: 6, border: `1px solid ${getColor(k.rootCategory)}30`, opacity: 0.7, cursor: 'pointer', transition: 'opacity 0.15s ease' }}
                                          onMouseEnter={(e) => e.currentTarget.style.opacity = '1'}
                                          onMouseLeave={(e) => e.currentTarget.style.opacity = '0.7'}>
                                          {k.source === 'vision' && <Icon name="image_search" size={14} />}
                                          {k.source === 'filename' && <Icon name="description" size={14} />}
                                          {k.value}
                                          <span style={{ fontSize: 11, opacity: 0.6, marginLeft: 2 }}>({k.partialCount}/{selectedIds.length})</span>
                                          <span data-action="remove" onClick={(e) => { e.stopPropagation(); removeKw(k.id); }} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 2, display: 'flex' }}>
                                            <Icon name="close" size={14} />
                                          </span>
                                        </motion.span>
                                      ))}
                                    </div>
                                  </div>
                                )}
                              </>
                            ) : (
                              <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6 }}>
                                {keywords.map(k => (
                                  <motion.span
                                    key={k.id}
                                    initial={{ opacity: 0, scale: 0.8 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    style={{ padding: '5px 10px', background: `${getColor(k.rootCategory)}15`, color: getColor(k.rootCategory), borderRadius: 20, fontSize: 13, display: 'flex', alignItems: 'center', gap: 6, border: `1px solid ${getColor(k.rootCategory)}30` }}>
                                    {k.source === 'vision' && <Icon name="image_search" size={14} />}
                                    {k.source === 'filename' && <Icon name="description" size={14} />}
                                    {k.value}
                                    <span onClick={() => removeKw(k.id)} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 2, display: 'flex' }}>
                                      <Icon name="close" size={14} />
                                    </span>
                                  </motion.span>
                                ))}
                              </div>
                            )}
                          </div>
                        )}

                        {pending.length > 0 && (
                          <div style={{ background: s.panel, borderRadius: s.radius, padding: 12, border: `1px solid ${s.border}` }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 10 }}>
                              <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: s.bright, fontSize: s.fontSize, fontWeight: 500 }}>
                                <Icon name="rate_review" size={18} />
                                {pending.length} to review
                              </div>
                              <button onClick={acceptAll} style={{ display: 'flex', alignItems: 'center', gap: 4, padding: '4px 10px', background: 'rgba(96,165,250,0.15)', color: '#60a5fa', border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: 13 }}>
                                <Icon name="done_all" size={16} /> Accept all
                              </button>
                            </div>

                            {/* Show "Recommended to All" and "Recommended to Some" sections in multi-select mode */}
                            {isMultiSelect ? (
                              <>
                                {pending.filter(k => !k.partialCount).length > 0 && (
                                  <div style={{ marginBottom: 12 }}>
                                    <div style={{ fontSize: 13, color: '#60a5fa', marginBottom: 8, fontWeight: 600, display: 'flex', alignItems: 'center', gap: 6 }}>
                                      <Icon name="recommend" size={16} />
                                      Recommended to All ({pending.filter(k => !k.partialCount).length})
                                    </div>
                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6 }}>
                                      {pending.filter(k => !k.partialCount).map(k => (
                                        <motion.span
                                          key={k.id}
                                          initial={{ opacity: 0, scale: 0.8 }}
                                          animate={{ opacity: 1, scale: 1 }}
                                          onClick={(e) => {
                                            if (!e.target.closest('[data-action]')) accept(k.id);
                                          }}
                                          style={{ padding: '5px 10px', background: `${getColor(k.rootCategory)}15`, color: getColor(k.rootCategory), borderRadius: 20, fontSize: 13, display: 'flex', alignItems: 'center', gap: 6, border: `1px solid ${getColor(k.rootCategory)}30`, cursor: 'pointer', transition: 'all 0.15s ease' }}
                                          onMouseEnter={(e) => e.currentTarget.style.transform = 'scale(1.05)'}
                                          onMouseLeave={(e) => e.currentTarget.style.transform = 'scale(1)'}>
                                          {k.source === 'vision' && <Icon name="image_search" size={14} />}
                                          {k.source === 'filename' && <Icon name="description" size={14} />}
                                          {k.value}
                                          <span data-action="block" onClick={(e) => { e.stopPropagation(); block(k.id); }} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 2, display: 'flex' }}>
                                            <Icon name="block" size={14} />
                                          </span>
                                        </motion.span>
                                      ))}
                                    </div>
                                  </div>
                                )}

                                {pending.filter(k => k.partialCount).length > 0 && (
                                  <div>
                                    <div style={{ fontSize: 13, color: '#a78bfa', marginBottom: 8, fontWeight: 600, display: 'flex', alignItems: 'center', gap: 6 }}>
                                      <Icon name="exposure" size={16} />
                                      Recommended to Some ({pending.filter(k => k.partialCount).length})
                                    </div>
                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6 }}>
                                      {pending.filter(k => k.partialCount).map(k => (
                                        <motion.span
                                          key={k.id}
                                          initial={{ opacity: 0, scale: 0.8 }}
                                          animate={{ opacity: 1, scale: 1 }}
                                          onClick={(e) => {
                                            if (!e.target.closest('[data-action]')) accept(k.id);
                                          }}
                                          style={{ padding: '5px 10px', background: `${getColor(k.rootCategory)}15`, color: getColor(k.rootCategory), borderRadius: 20, fontSize: 13, display: 'flex', alignItems: 'center', gap: 6, border: `1px solid ${getColor(k.rootCategory)}30`, opacity: 0.7, cursor: 'pointer', transition: 'all 0.15s ease' }}
                                          onMouseEnter={(e) => { e.currentTarget.style.opacity = '1'; e.currentTarget.style.transform = 'scale(1.05)'; }}
                                          onMouseLeave={(e) => { e.currentTarget.style.opacity = '0.7'; e.currentTarget.style.transform = 'scale(1)'; }}>
                                          {k.source === 'vision' && <Icon name="image_search" size={14} />}
                                          {k.source === 'filename' && <Icon name="description" size={14} />}
                                          {k.value}
                                          <span style={{ fontSize: 11, opacity: 0.6, marginLeft: 2 }}>({k.partialCount}/{selectedIds.length})</span>
                                          <span data-action="block" onClick={(e) => { e.stopPropagation(); block(k.id); }} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 2, display: 'flex' }}>
                                            <Icon name="block" size={14} />
                                          </span>
                                        </motion.span>
                                      ))}
                                    </div>
                                  </div>
                                )}
                              </>
                            ) : (
                              <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6 }}>
                                {pending.map(k => (
                                  <motion.span
                                    key={k.id}
                                    initial={{ opacity: 0, scale: 0.8 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    onClick={(e) => {
                                      if (!e.target.closest('[data-action]')) accept(k.id);
                                    }}
                                    style={{ padding: '5px 10px', background: `${getColor(k.rootCategory)}15`, color: getColor(k.rootCategory), borderRadius: 20, fontSize: 13, display: 'flex', alignItems: 'center', gap: 6, border: `1px solid ${getColor(k.rootCategory)}30`, cursor: 'pointer', transition: 'all 0.15s ease' }}
                                    onMouseEnter={(e) => e.currentTarget.style.transform = 'scale(1.05)'}
                                    onMouseLeave={(e) => e.currentTarget.style.transform = 'scale(1)'}>
                                    {k.source === 'vision' && <Icon name="image_search" size={14} />}
                                    {k.source === 'filename' && <Icon name="description" size={14} />}
                                    {k.value}
                                    <span data-action="block" onClick={(e) => { e.stopPropagation(); block(k.id); }} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 2, display: 'flex' }}>
                                      <Icon name="block" size={14} />
                                    </span>
                                  </motion.span>
                                ))}
                              </div>
                            )}
                          </div>
                        )}

                        <div style={{ display: 'flex', gap: 8 }}>
                          <input type="text" value={customInput} onChange={e => setCustomInput(e.target.value)}
                            onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); addCustom(); } }}
                            placeholder="Add custom tag..."
                            style={{ flex: 1, padding: '10px 14px', background: s.panel, border: `1px solid ${s.border}`, borderRadius: s.radius, color: s.bright, fontSize: s.fontSize, outline: 'none' }} />
                          <button onClick={addCustom} disabled={!customInput.trim()} tabIndex={-1}
                            style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: 44, background: customInput.trim() ? '#ec4899' : '#1f2937', color: customInput.trim() ? 'white' : '#4b5563', border: 'none', borderRadius: s.radius, cursor: customInput.trim() ? 'pointer' : 'default' }}>
                            <Icon name="add" size={22} />
                          </button>
                        </div>

                        <button
                          onClick={async () => {
                            // Check for required category
                            const hasRequiredCategory = keywords.some(k => REQUIRED_CATEGORIES.includes(k.value));
                            if (!hasRequiredCategory) {
                              alert('Please select at least one primary category (Industrial Design, Graphic Design, Art, Photography, or Architecture) before saving.');
                              return;
                            }
                            if (keywords.length === 0) return;
                            // Handle multi-select
                            if (selectedIds.length > 1) {
                              console.log('[SAVE BUTTON] Saving', selectedIds.length, 'selected images');
                              const selectedImages = queue.filter(q => selectedIds.includes(q.id));
                              for (const img of selectedImages) {
                                await saveImage(img, keywords, designer, true); // skipSync=true for batch
                              }
                            } else {
                              await saveImage(selectedImg, keywords, designer);
                            }
                          }}
                          disabled={keywords.length === 0 || !keywords.some(k => REQUIRED_CATEGORIES.includes(k.value))}
                          tabIndex={-1}
                          style={{
                            display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 8, padding: '12px 20px',
                            background: keywords.length > 0 && keywords.some(k => REQUIRED_CATEGORIES.includes(k.value)) ? '#2563eb' : '#1f2937',
                            color: keywords.length > 0 && keywords.some(k => REQUIRED_CATEGORIES.includes(k.value)) ? 'white' : '#4b5563',
                            border: 'none', borderRadius: s.radius,
                            cursor: keywords.length > 0 && keywords.some(k => REQUIRED_CATEGORIES.includes(k.value)) ? 'pointer' : 'default',
                            fontSize: s.fontSize, fontWeight: 500,
                            opacity: keywords.length > 0 && keywords.some(k => REQUIRED_CATEGORIES.includes(k.value)) ? 1 : 0.6
                          }}>
                          <Icon name="save" size={20} />
                          {keywords.length > 0 && keywords.some(k => REQUIRED_CATEGORIES.includes(k.value))
                            ? `Save${selectedIds.length > 1 ? ` (${selectedIds.length} images)` : similarCount > 0 ? ` + ${similarCount} similar` : ''}`
                            : keywords.length === 0 ? 'Nothing to save' : 'Select primary category'}
                        </button>
                      </div>
                    )}

                    {selectedImg.status === 'pending' && (
                      <div style={{ textAlign: 'center', padding: 40, color: s.muted }}>
                        <button onClick={() => analyzeImage(selectedImg)} tabIndex={-1}
                          style={{ display: 'inline-flex', alignItems: 'center', gap: 8, padding: '12px 24px', background: '#2563eb', color: 'white', border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize, fontWeight: 500 }}>
                          <Icon name="auto_awesome" size={20} /> Analyze
                        </button>
                      </div>
                    )}
                  </div>
                </>
              ) : (
                <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', color: s.muted }}>
                  <div style={{ textAlign: 'center' }}>
                    <Icon name="image" size={64} style={{ opacity: 0.2, display: 'block', margin: '0 auto 16px' }} />
                    <div style={{ fontSize: s.fontSize }}>Select an image</div>
                    <div style={{ fontSize: 13, marginTop: 8, color: '#4b5563' }}>Use arrow keys to navigate</div>
                  </div>
                </div>
              )}
            </div>

            {/* RIGHT - TAXONOMY */}
            <div style={{ width: 375, minWidth: 280, flexShrink: 0, background: s.panel, borderLeft: `1px solid ${s.border}`, display: 'flex', flexDirection: 'column' }}>
              <div style={{ padding: '14px 16px', borderBottom: `1px solid ${s.border}`, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: s.bright, fontSize: s.fontSize, fontWeight: 600 }}>
                    <Icon name="account_tree" size={20} />
                    Taxonomy
                  </div>
                  <div style={{ color: s.muted, fontSize: 13, marginTop: 4 }}>
                    {accepted.length} accepted · {taxInfo.allTerms.size} in dictionary{customCount > 0 ? ` · ${customCount} uncategorized` : ''}
                  </div>
                </div>
                <div style={{ display: 'flex', gap: 6 }}>
                  <button
                    onClick={handleOrganizeTaxonomy}
                    disabled={!geminiKey || isOrganizing}
                    title="Organize taxonomy - research and categorize custom keywords"
                    tabIndex={-1}
                    style={{
                      display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 4,
                      padding: '6px 10px', background: isOrganizing ? '#374151' : '#1f2937',
                      color: isOrganizing ? '#fbbf24' : '#a855f7', border: 'none',
                      borderRadius: s.radiusSm, cursor: isOrganizing ? 'default' : 'pointer',
                      fontSize: 13, opacity: geminiKey ? 1 : 0.5
                    }}
                  >
                    <Icon name={isOrganizing ? "hourglass_empty" : "auto_fix_high"} size={16} />
                    {isOrganizing ? 'Organizing...' : 'Organize'}
                  </button>
                  {customCount > 0 && showMasterTaxonomy && (
                    <button onClick={runCategorization} disabled={isCategorizing || !geminiKey} tabIndex={-1}
                      style={{ display: 'flex', alignItems: 'center', gap: 4, padding: '6px 10px', background: isCategorizing ? '#374151' : '#ec4899', color: isCategorizing ? '#9ca3af' : 'white', border: 'none', borderRadius: s.radiusSm, cursor: isCategorizing ? 'default' : 'pointer', fontSize: 13 }}>
                      <Icon name={isCategorizing ? "hourglass_empty" : "auto_fix_high"} size={16} /> {customCount}
                    </button>
                  )}
                  <button onClick={() => setShowMasterTaxonomy(!showMasterTaxonomy)} tabIndex={-1}
                    style={{ display: 'flex', alignItems: 'center', gap: 4, padding: '6px 10px', background: showMasterTaxonomy ? 'rgba(96,165,250,0.15)' : '#1f2937', color: showMasterTaxonomy ? '#60a5fa' : s.muted, border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: 13 }}>
                    <Icon name={showMasterTaxonomy ? "list" : "library_books"} size={16} />
                    {showMasterTaxonomy ? 'Session' : 'Master'}
                  </button>
                </div>
              </div>
              <div style={{ flex: 1, padding: 12, overflowY: 'auto' }}>
                {showMasterTaxonomy ? (
                  <div style={{ fontSize: 13 }}>
                    <div style={{ color: s.muted, marginBottom: 12 }}>Master dictionary ({taxInfo.allTerms.size} terms)</div>
                    {Object.entries(taxonomy).map(([name, value]) => (
                      <MasterTaxonomyNode key={name} name={name} value={value} depth={0} expanded={expanded}
                        onToggle={p => setExpanded(e => ({ ...e, [p]: e[p] === false ? true : false }))}
                        onDelete={deleteFromMasterTaxonomy} />
                    ))}
                  </div>
                ) : Object.keys(tree).length === 0 ? (
                  <div style={{ textAlign: 'center', padding: 32, color: s.muted }}>
                    <Icon name="folder_open" size={40} style={{ opacity: 0.3, display: 'block', margin: '0 auto 12px' }} />
                    <div style={{ fontSize: s.fontSize, marginBottom: 6 }}>Empty</div>
                    <div style={{ fontSize: 13, color: '#4b5563' }}>Analyze images to build taxonomy</div>
                  </div>
                ) : (
                  // Sort to put Custom/Uncategorized at top (grey), then alphabetically
                  Object.entries(tree)
                    .sort(([a], [b]) => {
                      const aIsUncategorized = a === 'Custom' || a === 'Uncategorized';
                      const bIsUncategorized = b === 'Custom' || b === 'Uncategorized';
                      if (aIsUncategorized && !bIsUncategorized) return -1;
                      if (!aIsUncategorized && bIsUncategorized) return 1;
                      return a.localeCompare(b);
                    })
                    .map(([name, node]) => (
                      <TreeNode key={name} name={name} node={node} depth={0} expanded={expanded}
                        onToggle={p => setExpanded(e => ({ ...e, [p]: e[p] === false ? true : false }))}
                        onDeleteKeyword={deleteFromTaxonomy} />
                    ))
                )}
              </div>
            </div>
          </div>

          {/* SETTINGS */}
          <AnimatePresence>
            {showSettings && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                onClick={() => setShowSettings(false)}
                style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.75)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 200 }}>
                <motion.div
                  initial={{ opacity: 0, scale: 0.95, y: 20 }}
                  animate={{ opacity: 1, scale: 1, y: 0 }}
                  exit={{ opacity: 0, scale: 0.95, y: 20 }}
                  onClick={e => e.stopPropagation()}
                  style={{ background: s.panel, borderRadius: s.radiusLg, width: 480, maxHeight: '85vh', overflow: 'auto', border: `1px solid ${s.border}`, boxShadow: '0 25px 50px -12px rgba(0,0,0,0.5)' }}>
                  <div style={{ padding: '18px 20px', borderBottom: `1px solid ${s.border}`, display: 'flex', alignItems: 'center', gap: 10 }}>
                    <Icon name="settings" size={22} style={{ color: s.muted }} />
                    <span style={{ color: s.bright, fontSize: 16, fontWeight: 600 }}>Settings</span>
                  </div>
                  <div style={{ padding: 20, display: 'flex', flexDirection: 'column', gap: 20 }}>
                    <div>
                      <div style={{ marginBottom: 8, color: s.text, fontSize: s.fontSize, fontWeight: 500 }}>Gemini API Key</div>
                      <input type="password" value={geminiKey} onChange={e => setGeminiKey(e.target.value)}
                        style={{ width: '100%', padding: '10px 14px', background: s.bg, border: `1px solid ${s.border}`, borderRadius: s.radius, color: s.bright, fontSize: s.fontSize, outline: 'none' }} />
                      <a href="https://aistudio.google.com/apikey" target="_blank" rel="noreferrer" style={{ display: 'inline-flex', alignItems: 'center', gap: 4, color: '#60a5fa', fontSize: 13, marginTop: 6, textDecoration: 'none' }}>
                        Get API key <Icon name="open_in_new" size={14} />
                      </a>
                    </div>
                    <div>
                      <div style={{ marginBottom: 8, color: s.text, fontSize: s.fontSize, fontWeight: 500 }}>Vision API Key (optional)</div>
                      <input type="password" value={visionKey} onChange={e => setVisionKey(e.target.value)}
                        style={{ width: '100%', padding: '10px 14px', background: s.bg, border: `1px solid ${s.border}`, borderRadius: s.radius, color: s.bright, fontSize: s.fontSize, outline: 'none' }} />
                      <a href="https://console.cloud.google.com/apis/library/vision.googleapis.com" target="_blank" rel="noreferrer" style={{ display: 'inline-flex', alignItems: 'center', gap: 4, color: '#60a5fa', fontSize: 13, marginTop: 6, textDecoration: 'none' }}>
                        Enable Vision API <Icon name="open_in_new" size={14} />
                      </a>
                    </div>

                    <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
                      <label style={{ display: 'flex', alignItems: 'center', gap: 12, cursor: 'pointer', padding: '10px 14px', background: s.bg, borderRadius: s.radius }}>
                        <input type="checkbox" checked={useVision} onChange={e => setUseVision(e.target.checked)} style={{ width: 18, height: 18, accentColor: '#60a5fa' }} />
                        <div>
                          <div style={{ fontSize: s.fontSize, color: s.bright }}>Use Vision API for reverse image search</div>
                          <div style={{ fontSize: 13, color: s.muted }}>Find web matches and similar images</div>
                        </div>
                      </label>
                      <label style={{ display: 'flex', alignItems: 'center', gap: 12, cursor: 'pointer', padding: '10px 14px', background: s.bg, borderRadius: s.radius }}>
                        <input type="checkbox" checked={autoDownloadLarger} onChange={e => setAutoDownloadLarger(e.target.checked)} style={{ width: 18, height: 18, accentColor: '#60a5fa' }} />
                        <div>
                          <div style={{ fontSize: s.fontSize, color: s.bright }}>Auto-download larger versions</div>
                          <div style={{ fontSize: 13, color: s.muted }}>Requires output folder to be set</div>
                        </div>
                      </label>
                    </div>

                    <div>
                      <div style={{ marginBottom: 10, color: s.text, fontSize: s.fontSize, fontWeight: 500 }}>Save Mode</div>
                      <div style={{ display: 'flex', gap: 12 }}>
                        <label style={{ flex: 1, padding: '14px 16px', border: `2px solid ${saveMode === 'embed' ? '#60a5fa' : s.border}`, background: saveMode === 'embed' ? 'rgba(96,165,250,0.1)' : 'transparent', borderRadius: s.radius, cursor: 'pointer', display: 'flex', alignItems: 'center', gap: 10 }}>
                          <input type="radio" checked={saveMode === 'embed'} onChange={() => setSaveMode('embed')} style={{ width: 18, height: 18, accentColor: '#60a5fa' }} />
                          <div>
                            <div style={{ fontSize: s.fontSize, color: s.bright }}>Embed XMP</div>
                            <div style={{ fontSize: 13, color: s.muted }}>Write metadata into file</div>
                          </div>
                        </label>
                        <label style={{ flex: 1, padding: '14px 16px', border: `2px solid ${saveMode === 'sidecar' ? '#60a5fa' : s.border}`, background: saveMode === 'sidecar' ? 'rgba(96,165,250,0.1)' : 'transparent', borderRadius: s.radius, cursor: 'pointer', display: 'flex', alignItems: 'center', gap: 10 }}>
                          <input type="radio" checked={saveMode === 'sidecar'} onChange={() => setSaveMode('sidecar')} style={{ width: 18, height: 18, accentColor: '#60a5fa' }} />
                          <div>
                            <div style={{ fontSize: s.fontSize, color: s.bright }}>Sidecar .xmp</div>
                            <div style={{ fontSize: 13, color: s.muted }}>Create separate file</div>
                          </div>
                        </label>
                      </div>
                    </div>

                    <button onClick={async () => { try { setOutputDir(await window.showDirectoryPicker({ mode: 'readwrite' })); } catch {} }}
                      style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 8, padding: '12px 16px', background: outputDir ? 'rgba(16,185,129,0.15)' : (outputDirName ? 'rgba(251,191,36,0.15)' : '#1f2937'), color: outputDir ? '#10b981' : (outputDirName ? '#fbbf24' : s.text), border: `1px solid ${outputDir ? 'rgba(16,185,129,0.3)' : (outputDirName ? 'rgba(251,191,36,0.3)' : s.border)}`, borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                      <Icon name={outputDir ? "check_circle" : (outputDirName ? "warning" : "folder_open")} size={20} />
                      {outputDir ? `Output: ${outputDir.name}` : (outputDirName ? `Re-select: ${outputDirName}` : 'Choose output folder')}
                    </button>
                  </div>
                  <div style={{ padding: '16px 20px', borderTop: `1px solid ${s.border}`, display: 'flex', justifyContent: 'flex-end' }}>
                    <button onClick={() => setShowSettings(false)} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '10px 20px', background: '#2563eb', color: 'white', border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize, fontWeight: 500 }}>
                      Done
                    </button>
                  </div>
                </motion.div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
