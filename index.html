<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Tagger Pro v8</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/framer-motion@11/dist/framer-motion.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #0a0a0a; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #111; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #444; }
    #drop-overlay { display: none; position: fixed; inset: 0; background: rgba(96,165,250,0.15); border: 3px dashed #60a5fa; z-index: 9999; align-items: center; justify-content: center; backdrop-filter: blur(4px); }
    #drop-overlay.active { display: flex; }
    .material-symbols-rounded { font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24; vertical-align: middle; }
    .material-symbols-rounded.filled { font-variation-settings: 'FILL' 1, 'wght' 400, 'GRAD' 0, 'opsz' 24; }
    button { transition: all 0.15s ease; }
    button:hover:not(:disabled) { filter: brightness(1.1); }
    button:active:not(:disabled) { transform: scale(0.98); }
  </style>
</head>
<body>
  <div id="drop-overlay"><div style="background: rgba(0,0,0,0.95); padding: 40px 72px; border-radius: 20px; color: #60a5fa; font-size: 16px; display: flex; align-items: center; gap: 16px; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);"><span class="material-symbols-rounded" style="font-size: 36px;">upload_file</span> Drop images or folder here</div></div>
  <div id="root"></div>

  <script>
    const overlay = document.getElementById('drop-overlay');
    let dragCounter = 0;
    document.addEventListener('dragenter', (e) => { e.preventDefault(); dragCounter++; overlay.classList.add('active'); });
    document.addEventListener('dragleave', (e) => { e.preventDefault(); dragCounter--; if (dragCounter === 0) overlay.classList.remove('active'); });
    document.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
    document.addEventListener('drop', async (e) => {
      e.preventDefault(); dragCounter = 0; overlay.classList.remove('active');
      const files = await extractFiles(e.dataTransfer);
      if (files.length > 0 && window.onFilesDropped) window.onFilesDropped(files);
    });

    async function extractFiles(dataTransfer) {
      const files = [];
      const entries = [];

      // First, collect all entries (must be done synchronously before promises)
      const items = dataTransfer.items;
      if (items?.length > 0) {
        for (let i = 0; i < items.length; i++) {
          const entry = items[i].webkitGetAsEntry?.();
          if (entry) entries.push(entry);
        }
      }

      console.log('[EXTRACT] Items:', items?.length, 'Entries:', entries.length);

      async function processEntry(entry) {
        if (!entry) return;
        if (entry.isFile) {
          try {
            const file = await new Promise((resolve, reject) => entry.file(resolve, reject));
            if (file.type.startsWith('image/')) {
              console.log('[EXTRACT] Found image:', file.name);
              files.push(file);
            }
          } catch (e) { console.error('[EXTRACT] Error getting file:', e); }
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          let dirEntries = [];
          while (true) {
            const batch = await new Promise((resolve) => reader.readEntries(resolve, () => resolve([])));
            if (batch.length === 0) break;
            dirEntries = dirEntries.concat(batch);
          }
          for (const e of dirEntries) await processEntry(e);
        }
      }

      // Process all entries
      for (const entry of entries) {
        await processEntry(entry);
      }

      // Fallback to dataTransfer.files if no entries worked
      if (files.length === 0 && dataTransfer.files) {
        console.log('[EXTRACT] Fallback to dataTransfer.files:', dataTransfer.files.length);
        for (let i = 0; i < dataTransfer.files.length; i++) {
          if (dataTransfer.files[i].type.startsWith('image/')) files.push(dataTransfer.files[i]);
        }
      }

      console.log('[EXTRACT] Total files:', files.length);
      return files;
    }
  </script>

  <!-- Load data and utilities (plain JS, no JSX) -->
  <script src="js/data.js"></script>
  <script src="js/utils.js"></script>
  <script src="js/api.js"></script>

  <script type="text/babel">
    const { useState, useRef, useEffect, useMemo, useCallback } = React;
    const { motion, AnimatePresence } = window.Motion;

    // Icon component for Material Symbols
    const Icon = ({ name, size = 20, filled = false, style = {} }) => (
      <span
        className={`material-symbols-rounded${filled ? ' filled' : ''}`}
        style={{ fontSize: size, ...style }}
      >{name}</span>
    );

    // Import from modules
    const { DEFAULT_TAXONOMY, ROOT_COLORS, STORAGE_KEY, TAXONOMY_KEY } = window.TaggerData;
    const {
      smartCategorize, addToTaxonomy, removeFromTaxonomy, flattenTaxonomy,
      getBrandPath, looksLikeBrand, parseEra, splitBrandModel, deduplicateKeywords,
      buildTree, countKeywords, hashFile, getBaseName, loadMemory, saveMemory,
      getCachedAnalysis, setCachedAnalysis,
      extractFromFilename, extractFromUrls, extractExistingMetadata, generateXMP,
      embedXMP, embedXMPinPNG, convertToJPEG, isRawFormat, supportsEmbedding
    } = window.TaggerUtils;
    const { analyzeWithGemini, findDesigner, categorizeKeywords, consolidateKeywords, analyzeWithVision, downloadLargerVersion } = window.TaggerAPI;

    // ============================================
    // REACT COMPONENTS (must be in Babel block for JSX)
    // ============================================
    const TreeNode = ({ name, node, depth = 0, expanded, onToggle, onDeleteKeyword }) => {
      const children = node._children || {};
      const hasChildren = Object.keys(children).length > 0;
      const keywords = node._keywords || [];
      const count = countKeywords(node);
      const pathKey = node._path?.join('>');
      const isExpanded = expanded[pathKey] !== false;
      const color = ROOT_COLORS[node._path?.[0]] || '#94a3b8';

      return (
        <div style={{ marginLeft: depth > 0 ? 16 : 0 }}>
          <div onClick={() => (hasChildren || keywords.length > 0) && onToggle(pathKey)}
            style={{ display: 'flex', alignItems: 'center', gap: 8, padding: '6px 8px', borderRadius: 6, cursor: 'pointer', background: depth === 0 ? 'rgba(255,255,255,0.03)' : 'transparent' }}>
            <Icon name={isExpanded ? "expand_more" : "chevron_right"} size={16} style={{ color: '#4b5563', opacity: (hasChildren || keywords.length > 0) ? 1 : 0 }} />
            {depth === 0 && <span style={{ width: 10, height: 10, borderRadius: 4, background: color }} />}
            <span style={{ flex: 1, color: depth === 0 ? '#f3f4f6' : '#9ca3af', fontSize: 13 }}>{name}</span>
            <span style={{ color: '#6b7280', fontSize: 12 }}>{count}</span>
          </div>
          {isExpanded && keywords.length > 0 && (
            <div style={{ marginLeft: 28, marginTop: 6, display: 'flex', flexWrap: 'wrap', gap: 6 }}>
              {keywords.map(kw => (
                <span key={kw.id} style={{ padding: '4px 10px', background: `${color}15`, color, borderRadius: 16, fontSize: 12, display: 'flex', alignItems: 'center', gap: 6, border: `1px solid ${color}25` }}>
                  {kw.value}
                  <span onClick={(e) => { e.stopPropagation(); onDeleteKeyword(kw.id); }} style={{ cursor: 'pointer', opacity: 0.6, display: 'flex' }}>
                    <Icon name="close" size={12} />
                  </span>
                </span>
              ))}
            </div>
          )}
          {isExpanded && hasChildren && Object.entries(children).map(([n, c]) => (
            <TreeNode key={n} name={n} node={c} depth={depth + 1} expanded={expanded} onToggle={onToggle} onDeleteKeyword={onDeleteKeyword} />
          ))}
        </div>
      );
    };

    const MasterTaxonomyNode = ({ name, value, path = [], depth = 0, expanded, onToggle, onDelete }) => {
      const currentPath = [...path, name];
      const pathKey = currentPath.join('>');
      const isExpanded = expanded[pathKey] !== false;
      const color = ROOT_COLORS[currentPath[0]] || '#94a3b8';

      let children = {};
      let items = [];
      if (Array.isArray(value)) {
        items = value;
      } else if (typeof value === 'object' && value !== null) {
        items = value._items || [];
        children = Object.fromEntries(Object.entries(value).filter(([k]) => k !== '_items'));
      }

      const hasChildren = Object.keys(children).length > 0;
      const hasItems = items.length > 0;
      const hasContent = hasChildren || hasItems;

      return (
        <div style={{ marginLeft: depth > 0 ? 16 : 0 }}>
          <div onClick={() => hasContent && onToggle(pathKey)}
            style={{ display: 'flex', alignItems: 'center', gap: 8, padding: '6px 8px', borderRadius: 6, cursor: hasContent ? 'pointer' : 'default', background: depth === 0 ? 'rgba(255,255,255,0.03)' : 'transparent' }}>
            <Icon name={isExpanded ? "expand_more" : "chevron_right"} size={16} style={{ color: '#4b5563', opacity: hasContent ? 1 : 0 }} />
            {depth === 0 && <span style={{ width: 10, height: 10, borderRadius: 4, background: color }} />}
            <span style={{ flex: 1, color: depth === 0 ? '#f3f4f6' : '#9ca3af', fontSize: 13 }}>{name}</span>
          </div>
          {isExpanded && hasItems && (
            <div style={{ marginLeft: 28, marginTop: 6, display: 'flex', flexWrap: 'wrap', gap: 6 }}>
              {items.map((item, idx) => (
                <span key={`${pathKey}-${item}-${idx}`} style={{ padding: '4px 10px', background: `${color}15`, color, borderRadius: 16, fontSize: 12, display: 'flex', alignItems: 'center', gap: 6, border: `1px solid ${color}25` }}>
                  {item}
                  <span onClick={(e) => { e.stopPropagation(); onDelete(currentPath, item); }} style={{ cursor: 'pointer', opacity: 0.6, display: 'flex' }}>
                    <Icon name="close" size={12} />
                  </span>
                </span>
              ))}
            </div>
          )}
          {isExpanded && hasChildren && Object.entries(children).map(([n, v]) => (
            <MasterTaxonomyNode key={n} name={n} value={v} path={currentPath} depth={depth + 1} expanded={expanded} onToggle={onToggle} onDelete={onDelete} />
          ))}
        </div>
      );
    };

    // ============================================
    // MAIN APP
    // ============================================
    function App() {
      const [geminiKey, setGeminiKey] = useState(localStorage.getItem('gemini_api_key') || '');
      const [visionKey, setVisionKey] = useState(localStorage.getItem('vision_api_key') || '');
      const [useVision, setUseVision] = useState(localStorage.getItem('use_vision') === 'true');
      const [autoDownloadLarger, setAutoDownloadLarger] = useState(localStorage.getItem('auto_download_larger') === 'true');
      const [showSettings, setShowSettings] = useState(false);
      const [saveMode, setSaveMode] = useState(localStorage.getItem('save_mode') || 'embed');
      const [outputDir, setOutputDir] = useState(null);
      const [thumbSize, setThumbSize] = useState(parseInt(localStorage.getItem('thumb_size')) || 1);

      const [taxonomy, setTaxonomy] = useState(() => {
        try { return JSON.parse(localStorage.getItem(TAXONOMY_KEY)) || DEFAULT_TAXONOMY; }
        catch { return DEFAULT_TAXONOMY; }
      });
      const taxInfo = useMemo(() => flattenTaxonomy(taxonomy), [taxonomy]);

      const [queue, setQueue] = useState([]);
      const [memory, setMemory] = useState(loadMemory);
      const [selectedId, setSelectedId] = useState(null);

      const [showDone, setShowDone] = useState(true);
      const [showHidden, setShowHidden] = useState(false);
      const [showPending, setShowPending] = useState(true);
      const [showMasterTaxonomy, setShowMasterTaxonomy] = useState(false);

      const [pending, setPending] = useState([]);
      const [keywords, setKeywords] = useState([]);
      const [ignored, setIgnored] = useState([]);
      const [designer, setDesigner] = useState(null);
      const [modified, setModified] = useState(false);
      const [visionData, setVisionData] = useState(null);
      const [downloadedLarger, setDownloadedLarger] = useState(null);
      const [isEditing, setIsEditing] = useState(false);

      const [accepted, setAccepted] = useState([]);
      const [blocked, setBlocked] = useState([]);
      const [expanded, setExpanded] = useState({});
      const [customInput, setCustomInput] = useState('');
      const [isCategorizing, setIsCategorizing] = useState(false);
      const [gridWidth, setGridWidth] = useState(() => parseInt(localStorage.getItem('grid_width')) || 50); // percentage
      const [isDraggingDivider, setIsDraggingDivider] = useState(false);

      const fileRef = useRef(null);
      const folderRef = useRef(null);
      const acceptedRef = useRef(new Set());
      const blockedRef = useRef(new Set());
      const containerRef = useRef(null);
      const mainPanelRef = useRef(null);

      useEffect(() => { acceptedRef.current = new Set(accepted.map(k => k.value.toLowerCase())); }, [accepted]);
      useEffect(() => { blockedRef.current = new Set(blocked.map(k => k.value.toLowerCase())); }, [blocked]);

      const selectedImg = queue.find(q => q.id === selectedId);

      const filteredQueue = useMemo(() => {
        return queue.filter(q => {
          if (q.hidden && !showHidden) return false;
          if (q.status === 'done' && !showDone) return false;
          if ((q.status === 'pending' || q.status === 'analyzing') && !showPending) return false;
          return true;
        });
      }, [queue, showDone, showHidden, showPending]);

      const findPath = useCallback((kwValue, kwType = 'keyword') => {
        const key = kwValue.toLowerCase().trim();
        if (taxInfo.paths[key]) return taxInfo.paths[key];
        return smartCategorize({ value: kwValue, type: kwType });
      }, [taxInfo]);

      // Keyboard navigation
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const currentIndex = filteredQueue.findIndex(q => q.id === selectedId);
            let newIndex = currentIndex;

            if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
              newIndex = currentIndex < filteredQueue.length - 1 ? currentIndex + 1 : 0;
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
              newIndex = currentIndex > 0 ? currentIndex - 1 : filteredQueue.length - 1;
            }

            if (filteredQueue[newIndex]) {
              selectImage(filteredQueue[newIndex].id);
            }
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [filteredQueue, selectedId]);

      // Save settings
      useEffect(() => {
        if (geminiKey) localStorage.setItem('gemini_api_key', geminiKey);
        if (visionKey) localStorage.setItem('vision_api_key', visionKey);
        localStorage.setItem('use_vision', useVision.toString());
        localStorage.setItem('auto_download_larger', autoDownloadLarger.toString());
        localStorage.setItem('save_mode', saveMode);
        localStorage.setItem('thumb_size', thumbSize.toString());
      }, [geminiKey, visionKey, useVision, autoDownloadLarger, saveMode, thumbSize]);

      useEffect(() => { saveMemory(memory); }, [memory]);
      useEffect(() => { localStorage.setItem(TAXONOMY_KEY, JSON.stringify(taxonomy)); }, [taxonomy]);
      useEffect(() => { localStorage.setItem('grid_width', gridWidth.toString()); }, [gridWidth]);

      // Divider drag handlers
      const handleDividerMouseDown = useCallback((e) => {
        e.preventDefault();
        setIsDraggingDivider(true);
      }, []);

      useEffect(() => {
        if (!isDraggingDivider) return;

        const handleMouseMove = (e) => {
          const container = mainPanelRef.current;
          if (!container) return;
          const rect = container.getBoundingClientRect();
          const taxonomyWidth = 375; // fixed taxonomy panel width
          const availableWidth = rect.width - taxonomyWidth;
          const mouseX = e.clientX - rect.left;
          const newGridWidth = Math.max(20, Math.min(80, (mouseX / availableWidth) * 100));
          setGridWidth(newGridWidth);
        };

        const handleMouseUp = () => {
          setIsDraggingDivider(false);
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        return () => {
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        };
      }, [isDraggingDivider]);

      const queueRef = useRef(queue);
      const memoryRef = useRef(memory);
      const geminiKeyRef = useRef(geminiKey);
      const analyzeImageRef = useRef(null);
      useEffect(() => { queueRef.current = queue; }, [queue]);
      useEffect(() => { memoryRef.current = memory; }, [memory]);
      useEffect(() => { geminiKeyRef.current = geminiKey; }, [geminiKey]);

      useEffect(() => {
        window.onFilesDropped = async (files) => { await processFilesRef.current(files); };
        return () => { window.onFilesDropped = null; };
      }, []);

      const processFilesRef = useRef(null);
      processFilesRef.current = async (files) => {
        console.log('[DROP] Received files:', files.length, files.map(f => f.name));
        const imgs = files.filter(f => f.type.startsWith('image/'));
        console.log('[DROP] Image files:', imgs.length);
        if (!imgs.length) return;

        const currentMemory = memoryRef.current;
        const newItems = await Promise.all(imgs.map(async (file) => {
          const hash = await hashFile(file);
          const mem = currentMemory[hash];
          const filenameKws = extractFromFilename(file.name);
          const existingKws = await extractExistingMetadata(file);

          console.log('[DROP] Processing:', file.name, 'hash:', hash);
          return {
            id: hash, name: file.name, file, url: URL.createObjectURL(file),
            baseName: getBaseName(file.name),
            status: mem?.exported ? 'done' : 'pending',
            hidden: mem?.hidden || false,
            keywords: mem?.keywords || [], pending: [],
            filenameKeywords: filenameKws,
            existingKeywords: existingKws,
            creator: mem?.creator || null, hash
          };
        }));

        const existingIds = new Set(queueRef.current.map(q => q.id));
        const uniqueItems = newItems.filter(item => !existingIds.has(item.id));
        console.log('[DROP] New items:', newItems.length, 'Unique:', uniqueItems.length, 'Existing IDs:', existingIds.size);

        if (uniqueItems.length > 0) {
          setQueue(prev => [...prev, ...uniqueItems]);
          // Auto-analyze pending items after a short delay to let state update
          setTimeout(() => {
            if (geminiKeyRef.current) {
              console.log('[AUTO-ANALYZE] Starting analysis of', uniqueItems.length, 'items');
              uniqueItems.filter(item => item.status === 'pending').forEach(item => {
                analyzeImageRef.current?.(item);
              });
            }
          }, 100);
        }
      };

      const handleFileInput = (e) => {
        if (e.target.files?.length) processFilesRef.current(Array.from(e.target.files));
        e.target.value = '';
      };

      // Find similar images by base name
      const getSimilarImages = useCallback((img) => {
        if (!img) return [];
        const similar = queue.filter(q =>
          q.id !== img.id &&
          q.baseName === img.baseName
        );
        if (similar.length > 0) {
          console.log(`[SIMILAR] Found ${similar.length} similar to "${img.name}" (baseName: "${img.baseName}"):`, similar.map(s => s.name));
        }
        return similar;
      }, [queue]);

      // Sync keywords to similar images and auto-save
      const syncToSimilarAndSave = useCallback(async (sourceImg, sourceKeywords, sourceDesigner) => {
        const similar = getSimilarImages(sourceImg);
        if (similar.length === 0) return;

        console.log(`[SYNC] Syncing ${sourceKeywords.length} keywords to ${similar.length} similar images`);

        for (const img of similar) {
          const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
          const newKws = sourceKeywords
            .filter(k => !existingVals.has(k.value.toLowerCase()))
            .map(k => ({ ...k, id: `sync-${Math.random().toString(36).slice(2)}` }));

          if (newKws.length > 0) {
            const updatedKeywords = [...(img.keywords || []), ...newKws];

            // Update queue
            setQueue(q => q.map(i => i.id === img.id ? {
              ...i,
              keywords: updatedKeywords,
              designer: sourceDesigner,
              status: 'done'
            } : i));

            // Save to memory
            setMemory(prev => ({
              ...prev,
              [img.hash]: { exported: true, keywords: updatedKeywords, creator: sourceDesigner?.designer, hidden: img.hidden }
            }));

            // Save file if output dir set
            if (outputDir) {
              try {
                let blob, filename = img.name;
                const creator = sourceDesigner?.designer || null;
                const isRaw = isRawFormat(img.name);
                const canEmbed = supportsEmbedding(img.file);

                if (saveMode === 'embed' && img.file.type.includes('jpeg')) {
                  blob = await embedXMP(img.file, updatedKeywords, creator);
                } else if (saveMode === 'embed' && img.file.type.includes('png')) {
                  blob = await embedXMPinPNG(img.file, updatedKeywords, creator);
                } else if (saveMode === 'embed' && !canEmbed && !isRaw) {
                  // Convert WebP/AVIF to JPEG
                  const jpegBlob = await convertToJPEG(img.file);
                  const jpegFile = new File([jpegBlob], 'temp.jpg', { type: 'image/jpeg' });
                  blob = await embedXMP(jpegFile, updatedKeywords, creator);
                  filename = filename.replace(/\.[^.]+$/, '.jpg');
                } else {
                  blob = new Blob([generateXMP(updatedKeywords, creator)], { type: 'application/rdf+xml' });
                  filename = filename.replace(/\.[^.]+$/, '') + '.xmp';
                }

                const fh = await outputDir.getFileHandle(filename, { create: true });
                const w = await fh.createWritable();
                await w.write(blob);
                await w.close();
                console.log(`[SYNC] Auto-saved: ${filename}`);

                // Copy raw file alongside XMP
                if (isRaw) {
                  const rawFh = await outputDir.getFileHandle(img.name, { create: true });
                  const rawW = await rawFh.createWritable();
                  await rawW.write(img.file);
                  await rawW.close();
                  console.log(`[SYNC] Copied raw: ${img.name}`);
                }
              } catch (e) {
                console.error('[SYNC] Save failed:', e);
              }
            }
          }
        }
      }, [queue, outputDir, saveMode, getSimilarImages]);

      // Save image - defined before selectImage to avoid stale reference
      const saveImage = useCallback(async (img, kws, des) => {
        if (!img || !kws || kws.length === 0) {
          console.log('[SAVE] Skipped - no image or keywords');
          return;
        }
        console.log('[SAVE] Saving:', img.name, 'with', kws.length, 'keywords');
        try {
          let blob, filename = img.name;
          const creator = des?.designer || null;
          const isRaw = isRawFormat(img.name);
          const canEmbed = supportsEmbedding(img.file);

          if (saveMode === 'embed' && img.file.type.includes('jpeg')) {
            blob = await embedXMP(img.file, kws, creator);
          } else if (saveMode === 'embed' && img.file.type.includes('png')) {
            blob = await embedXMPinPNG(img.file, kws, creator);
          } else if (saveMode === 'embed' && !canEmbed && !isRaw) {
            console.log('[SAVE] Converting to JPEG:', img.name);
            const jpegBlob = await convertToJPEG(img.file);
            const jpegFile = new File([jpegBlob], 'temp.jpg', { type: 'image/jpeg' });
            blob = await embedXMP(jpegFile, kws, creator);
            filename = filename.replace(/\.[^.]+$/, '.jpg');
          } else {
            blob = new Blob([generateXMP(kws, creator)], { type: 'application/rdf+xml' });
            filename = filename.replace(/\.[^.]+$/, '') + '.xmp';
          }

          const saveFile = async (data, name) => {
            if (outputDir) {
              const fh = await outputDir.getFileHandle(name, { create: true });
              const w = await fh.createWritable();
              await w.write(data);
              await w.close();
              console.log('[SAVE] Saved:', name);
            } else {
              const url = URL.createObjectURL(data);
              Object.assign(document.createElement('a'), { href: url, download: name }).click();
              URL.revokeObjectURL(url);
              console.log('[SAVE] Downloaded:', name);
            }
          };

          await saveFile(blob, filename);

          if (isRaw && outputDir) {
            await saveFile(img.file, img.name);
            console.log('[SAVE] Copied raw file:', img.name);
          }

          setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'done', keywords: kws } : i));
          setMemory(prev => ({ ...prev, [img.hash]: { exported: true, keywords: kws, creator, hidden: img.hidden } }));
          setModified(false);
          setIsEditing(false);

          await syncToSimilarAndSave(img, kws, des);
        } catch (e) { console.error('[SAVE] Failed:', e); }
      }, [saveMode, outputDir, syncToSimilarAndSave]);

      // Analysis
      const analyzeImage = useCallback(async (img) => {
        if (!geminiKey || img.status === 'analyzing' || img.status === 'ready' || img.status === 'done') return;

        setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'analyzing' } : i));
        setDownloadedLarger(null);

        try {
          // Check cache first
          const cached = getCachedAnalysis(img.hash);
          if (cached) {
            console.log('[ANALYZE] Using cached analysis for:', img.name);
            // Re-process cached keywords through the categorization logic
            const rawKws = cached.rawKeywords || [];
            const visionResult = cached.visionData || null;
            const designerInfo = cached.designer || null;

            // Process keywords (same logic as fresh analysis)
            const processedKws = rawKws.map(kw => {
              const path = smartCategorize(kw);
              return { ...kw, id: kw.id || Math.random().toString(36), path, rootCategory: path[0] };
            });
            const allKws = deduplicateKeywords(processedKws);
            const currentAccepted = acceptedRef.current;
            const currentBlocked = blockedRef.current;

            const auto = [], review = [];
            allKws.forEach(kw => {
              const key = kw.value.toLowerCase();
              if (currentBlocked.has(key)) return;
              const inMaster = taxInfo.allTerms.has(key);
              const inSession = currentAccepted.has(key);
              const isDesigner = kw.type === 'designer' || kw.rootCategory === 'Creator';
              const isBrand = kw.type === 'brand' || kw.rootCategory === 'Brand';
              const isEra = kw.type === 'era' || kw.rootCategory === 'Era' || /^\d{4}s$/.test(kw.value);
              const knownCountries = ['Germany', 'Italy', 'Japan', 'Denmark', 'Sweden', 'United States', 'United Kingdom', 'France', 'Switzerland', 'Finland', 'Netherlands', 'Norway', 'Austria', 'Belgium', 'Spain', 'Portugal', 'Brazil', 'Mexico', 'Canada', 'Australia', 'China', 'South Korea', 'India', 'Russia', 'Poland', 'Czech Republic', 'Hungary', 'Greece', 'Turkey', 'Israel', 'South Africa', 'Argentina', 'Chile', 'Colombia', 'Iceland', 'Ireland', 'Scotland', 'Wales', 'USA', 'UK'];
              const isCountry = kw.type === 'country' || (kw.path && kw.path.includes('Origin')) || knownCountries.some(c => c.toLowerCase() === kw.value.toLowerCase());
              const isModel = kw.type === 'model' || kw.rootCategory === 'Product';
              const isAllUppercase = kw.value.length > 1 && kw.value === kw.value.toUpperCase() && /[A-Z]/.test(kw.value);
              if (inMaster || inSession || isDesigner || isBrand || isEra || isCountry || isModel || isAllUppercase) {
                if (isCountry && (!kw.path || !kw.path.includes('Origin'))) {
                  kw.path = ['Style', 'Origin'];
                  kw.rootCategory = 'Style';
                  kw.type = 'country';
                }
                auto.push(kw);
              } else {
                review.push(kw);
              }
            });

            setQueue(q => q.map(i => i.id === img.id ? {
              ...i, status: 'ready', keywords: auto, pending: review,
              designer: designerInfo, visionData: visionResult
            } : i));

            if (auto.length) {
              setAccepted(prev => {
                const updated = [...prev];
                auto.forEach(kw => {
                  if (!updated.some(a => a.value.toLowerCase() === kw.value.toLowerCase())) updated.push(kw);
                });
                return updated;
              });
            }
            return;
          }

          const base64 = await new Promise((res, rej) => {
            const r = new FileReader();
            r.onload = () => res(r.result.split(',')[1]);
            r.onerror = rej;
            r.readAsDataURL(img.file);
          });

          const contextParts = [];
          if (img.filenameKeywords?.length) {
            contextParts.push(`Filename suggests: ${img.filenameKeywords.map(k => k.value).join(', ')}`);
          }
          if (img.existingKeywords?.length) {
            contextParts.push(`Existing tags: ${img.existingKeywords.map(k => k.value).join(', ')}`);
          }

          let rawKws = await analyzeWithGemini(geminiKey, base64, img.file.type, contextParts.join('. '));

          if (img.filenameKeywords) rawKws = [...img.filenameKeywords, ...rawKws];
          if (img.existingKeywords) rawKws = [...img.existingKeywords, ...rawKws];

          let visionResult = null;
          if (useVision && visionKey) {
            visionResult = await analyzeWithVision(visionKey, base64);
            if (visionResult?.keywords) {
              visionResult.keywords.forEach(vk => {
                if (!rawKws.some(k => k.value.toLowerCase() === vk.value.toLowerCase())) {
                  rawKws.push(vk);
                }
              });
            }

            if (autoDownloadLarger && visionResult?.matchingImages?.length > 0 && outputDir) {
              const fullMatch = visionResult.matchingImages.find(m => m.type === 'full');
              if (fullMatch) {
                const larger = await downloadLargerVersion(fullMatch.url, img.name);
                if (larger && larger.size > img.file.size) {
                  try {
                    const fh = await outputDir.getFileHandle(larger.filename, { create: true });
                    const w = await fh.createWritable();
                    await w.write(larger.blob);
                    await w.close();
                    setDownloadedLarger({ filename: larger.filename, size: larger.size });
                    console.log('[DOWNLOAD] Saved:', larger.filename);
                  } catch (e) {}
                }
              }
            }
          }

          let processedKws = [];
          const brandFound = [], modelFound = [];

          rawKws.forEach(k => {
            splitBrandModel(k.value).forEach(part => {
              let path = part.path;
              if (part.path[0] === 'Custom' || part.type === 'keyword') {
                path = findPath(part.value, part.type);
              }
              const kw = {
                id: `${img.id}-${Math.random().toString(36).slice(2)}`,
                value: part.value, confidence: k.confidence || 0.8,
                type: part.type, path: path, rootCategory: path[0],
                source: k.source || 'gemini'
              };
              if (part.type === 'brand') brandFound.push(kw);
              else if (part.type === 'model') modelFound.push(kw);
              processedKws.push(kw);
            });
          });

          processedKws = deduplicateKeywords(processedKws);

          let designerInfo = null;
          if (brandFound.length > 0 && modelFound.length > 0) {
            designerInfo = await findDesigner(geminiKey, `${brandFound[0].value} ${modelFound[0].value}`);
            if (designerInfo?.designers && designerInfo.designers.length > 0) {
              designerInfo.designers.forEach(name => {
                const designerPath = smartCategorize({ value: name, type: 'designer' });
                processedKws.push({
                  id: `designer-${Math.random().toString(36).slice(2)}`,
                  value: name, confidence: 0.8,
                  type: 'designer', path: designerPath, rootCategory: 'Creator'
                });
              });
            } else if (designerInfo?.designer) {
              const designerPath = smartCategorize({ value: designerInfo.designer, type: 'designer' });
              processedKws.push({
                id: `designer-${Math.random().toString(36).slice(2)}`,
                value: designerInfo.designer, confidence: 0.8,
                type: 'designer', path: designerPath, rootCategory: 'Creator'
              });
            }
          }

          const currentBlocked = blockedRef.current;
          const currentAccepted = acceptedRef.current;
          const auto = [], review = [];

          console.log(`[ANALYZE] Master taxonomy has ${taxInfo.allTerms.size} terms, session has ${currentAccepted.size} accepted`);

          processedKws.forEach(kw => {
            const key = kw.value.toLowerCase();
            if (currentBlocked.has(key)) {
              console.log(`[ANALYZE] Blocked: "${kw.value}"`);
              return;
            }
            const inMaster = taxInfo.allTerms.has(key);
            const inSession = currentAccepted.has(key);
            const isDesigner = kw.type === 'designer' || kw.rootCategory === 'Creator';
            const isBrand = kw.type === 'brand' || kw.rootCategory === 'Brand';
            const isEra = kw.type === 'era' || kw.rootCategory === 'Era' || /^\d{4}s$/.test(kw.value);
            const knownCountries = ['Germany', 'Italy', 'Japan', 'Denmark', 'Sweden', 'United States', 'United Kingdom', 'France', 'Switzerland', 'Finland', 'Netherlands', 'Norway', 'Austria', 'Belgium', 'Spain', 'Portugal', 'Brazil', 'Mexico', 'Canada', 'Australia', 'China', 'South Korea', 'India', 'Russia', 'Poland', 'Czech Republic', 'Hungary', 'Greece', 'Turkey', 'Israel', 'South Africa', 'Argentina', 'Chile', 'Colombia', 'Iceland', 'Ireland', 'Scotland', 'Wales', 'USA', 'UK'];
            const isCountry = kw.type === 'country' || (kw.path && kw.path.includes('Origin')) || knownCountries.some(c => c.toLowerCase() === kw.value.toLowerCase());
            const isModel = kw.type === 'model' || kw.rootCategory === 'Product';
            // Auto-accept all-uppercase keywords (likely model numbers, acronyms, etc.)
            const isAllUppercase = kw.value.length > 1 && kw.value === kw.value.toUpperCase() && /[A-Z]/.test(kw.value);
            if (inMaster || inSession || isDesigner || isBrand || isEra || isCountry || isModel || isAllUppercase) {
              if (isCountry && (!kw.path || !kw.path.includes('Origin'))) {
                kw.path = ['Style', 'Origin'];
                kw.rootCategory = 'Style';
                kw.type = 'country';
              }
              console.log(`[ANALYZE] Auto-accept: "${kw.value}" (master: ${inMaster}, session: ${inSession}, designer: ${isDesigner}, brand: ${isBrand}, era: ${isEra}, country: ${isCountry}, model: ${isModel}, uppercase: ${isAllUppercase})`);
              auto.push(kw);
            } else {
              review.push(kw);
            }
          });

          console.log(`[ANALYZE] Result: ${auto.length} auto-accepted, ${review.length} for review`);

          // Cache the raw analysis results
          setCachedAnalysis(img.hash, {
            rawKeywords: processedKws,
            visionData: visionResult,
            designer: designerInfo
          });

          setQueue(q => q.map(i => i.id === img.id ? {
            ...i, status: 'ready', keywords: auto, pending: review,
            designer: designerInfo, visionData: visionResult
          } : i));

          if (auto.length) {
            setAccepted(prev => {
              const updated = [...prev];
              auto.forEach(kw => {
                if (!updated.some(a => a.value.toLowerCase() === kw.value.toLowerCase())) updated.push(kw);
              });
              return updated;
            });
          }
        } catch (err) {
          console.error('[ANALYZE] Failed:', err);
          setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'error' } : i));
        }
      }, [geminiKey, visionKey, useVision, autoDownloadLarger, outputDir, taxInfo, findPath]);

      // Keep ref updated for use in processFiles
      useEffect(() => { analyzeImageRef.current = analyzeImage; }, [analyzeImage]);

      const selectImage = useCallback(async (id) => {
        if (isEditing && selectedImg && keywords.length > 0) {
          console.log('[NAV] Auto-saving before navigation:', selectedImg.name);
          await saveImage(selectedImg, keywords, designer);
        }

        const img = queue.find(q => q.id === id);
        if (!img) return;

        setSelectedId(id);
        setDownloadedLarger(null);
        setIsEditing(false);

        if (img.status === 'ready' || img.status === 'done' || img.status === 'editing') {
          setKeywords(img.keywords || []);
          setPending(img.pending || []);
          setDesigner(img.designer || null);
          setVisionData(img.visionData || null);
          setIgnored([]);
          setModified(false);
        } else if (img.status === 'pending') {
          setKeywords([]); setPending([]); setDesigner(null); setVisionData(null); setIgnored([]); setModified(false);
          analyzeImage(img);
        } else {
          setKeywords([]); setPending([]); setDesigner(null); setVisionData(null); setIgnored([]); setModified(false);
        }
      }, [queue, isEditing, selectedImg, keywords, designer, analyzeImage, saveImage]);

      const analyzeAllPending = () => {
        const pending = queue.filter(q => q.status === 'pending' && !q.hidden);
        console.log('[ANALYZE ALL] Found', pending.length, 'pending images, geminiKey:', !!geminiKey);
        pending.forEach(img => analyzeImage(img));
      };

      const [isSavingAll, setIsSavingAll] = useState(false);
      const saveAll = async () => {
        if (isSavingAll) return;
        const toSave = queue.filter(q => !q.hidden && (q.status === 'ready' || q.status === 'editing') && q.keywords?.length > 0);
        if (toSave.length === 0) return;

        setIsSavingAll(true);
        console.log(`[SAVE ALL] Saving ${toSave.length} images...`);

        for (const img of toSave) {
          try {
            await saveImage(img, img.keywords, img.designer);
          } catch (e) {
            console.error(`[SAVE ALL] Failed to save ${img.name}:`, e);
          }
        }

        setIsSavingAll(false);
        console.log('[SAVE ALL] Done!');
      };

      const readyToSaveCount = queue.filter(q => !q.hidden && (q.status === 'ready' || q.status === 'editing') && q.keywords?.length > 0).length;

      const hideImage = (id, e) => {
        e?.stopPropagation();
        setQueue(q => q.map(i => {
          if (i.id === id) {
            setMemory(prev => ({ ...prev, [i.hash]: { ...prev[i.hash], hidden: true } }));
            return { ...i, hidden: true };
          }
          return i;
        }));
        if (selectedId === id) setSelectedId(null);
      };

      const unhideImage = (id, e) => {
        e?.stopPropagation();
        setQueue(q => q.map(i => {
          if (i.id === id) {
            setMemory(prev => ({ ...prev, [i.hash]: { ...prev[i.hash], hidden: false } }));
            return { ...i, hidden: false };
          }
          return i;
        }));
      };

      const accept = (id) => {
        const kw = pending.find(k => k.id === id);
        if (kw) {
          console.log(`[ACCEPT] Accepting keyword: "${kw.value}"`);
          setPending(p => p.filter(k => k.id !== id));
          const newKeywords = [...keywords, kw];
          setKeywords(newKeywords);
          setAccepted(a => a.some(x => x.value.toLowerCase() === kw.value.toLowerCase()) ? a : [...a, kw]);
          setTaxonomy(t => addToTaxonomy(t, kw));
          setModified(true);
          setIsEditing(true);

          if (selectedImg) {
            const similar = getSimilarImages(selectedImg);
            console.log(`[ACCEPT] Similar images for sync:`, similar.length);
            if (similar.length > 0) {
              setQueue(q => q.map(img => {
                if (similar.some(s => s.id === img.id)) {
                  const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                  if (!existingVals.has(kw.value.toLowerCase())) {
                    console.log(`[ACCEPT] Syncing "${kw.value}" to "${img.name}"`);
                    const syncedKw = { ...kw, id: `sync-${Math.random().toString(36).slice(2)}` };
                    return { ...img, keywords: [...(img.keywords || []), syncedKw], status: img.status === 'pending' ? 'ready' : img.status };
                  }
                }
                return img;
              }));
            }
          }
        }
      };

      const block = (id) => {
        const kw = pending.find(k => k.id === id) || ignored.find(k => k.id === id);
        if (kw) {
          setPending(p => p.filter(k => k.id !== id));
          setIgnored(i => i.filter(k => k.id !== id));
          setBlocked(b => [...b, kw]);
          setModified(true);
          setIsEditing(true);
        }
      };

      const ignore = (id) => {
        const kw = pending.find(k => k.id === id);
        if (kw) {
          setPending(p => p.filter(k => k.id !== id));
          setIgnored(i => [...i, kw]);
          setModified(true);
          setIsEditing(true);
        }
      };

      const acceptIgnored = (id) => {
        const kw = ignored.find(k => k.id === id);
        if (kw) {
          setIgnored(i => i.filter(k => k.id !== id));
          const newKeywords = [...keywords, kw];
          setKeywords(newKeywords);
          setAccepted(a => a.some(x => x.value.toLowerCase() === kw.value.toLowerCase()) ? a : [...a, kw]);
          setModified(true);
          setIsEditing(true);

          if (selectedImg) {
            const similar = getSimilarImages(selectedImg);
            if (similar.length > 0) {
              setQueue(q => q.map(img => {
                if (similar.some(s => s.id === img.id)) {
                  const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                  if (!existingVals.has(kw.value.toLowerCase())) {
                    const syncedKw = { ...kw, id: `sync-${Math.random().toString(36).slice(2)}` };
                    return { ...img, keywords: [...(img.keywords || []), syncedKw], status: img.status === 'pending' ? 'ready' : img.status };
                  }
                }
                return img;
              }));
            }
          }
        }
      };

      const acceptAll = () => {
        const newKeywords = [...keywords, ...pending];
        pending.forEach(kw => {
          setAccepted(a => a.some(x => x.value.toLowerCase() === kw.value.toLowerCase()) ? a : [...a, kw]);
        });
        setKeywords(newKeywords);
        setPending([]);
        setModified(true);
        setIsEditing(true);

        if (selectedImg) {
          const similar = getSimilarImages(selectedImg);
          if (similar.length > 0) {
            setQueue(q => q.map(img => {
              if (similar.some(s => s.id === img.id)) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                const newKws = pending
                  .filter(kw => !existingVals.has(kw.value.toLowerCase()))
                  .map(kw => ({ ...kw, id: `sync-${Math.random().toString(36).slice(2)}` }));
                if (newKws.length > 0) {
                  return { ...img, keywords: [...(img.keywords || []), ...newKws], status: img.status === 'pending' ? 'ready' : img.status };
                }
              }
              return img;
            }));
          }
        }
      };

      const removeKw = (id) => {
        setKeywords(c => c.filter(k => k.id !== id));
        setModified(true);
        setIsEditing(true);
      };

      const deleteFromTaxonomy = (id) => {
        setAccepted(a => a.filter(k => k.id !== id));
      };

      const deleteFromMasterTaxonomy = (path, value) => {
        setTaxonomy(prevTax => {
          const newTax = JSON.parse(JSON.stringify(prevTax));
          let current = newTax;

          for (let i = 0; i < path.length - 1; i++) {
            if (!current[path[i]]) return prevTax;
            current = current[path[i]];
          }

          const leafKey = path[path.length - 1];
          if (Array.isArray(current[leafKey])) {
            current[leafKey] = current[leafKey].filter(v => v.toLowerCase() !== value.toLowerCase());
          } else if (current[leafKey]?._items) {
            current[leafKey]._items = current[leafKey]._items.filter(v => v.toLowerCase() !== value.toLowerCase());
          }
          return newTax;
        });
      };

      const addCustom = () => {
        const val = customInput.trim();
        if (!val) return;
        const newKws = [];
        splitBrandModel(val).forEach(part => {
          const path = part.path[0] === 'Custom' ? findPath(part.value, part.type) : part.path;
          const kw = { id: `custom-${Date.now()}-${Math.random().toString(36).slice(2)}`, value: part.value, confidence: 1, type: part.type, path, rootCategory: path[0] };
          newKws.push(kw);
          setKeywords(c => [...c, kw]);
          setAccepted(a => a.some(x => x.value.toLowerCase() === kw.value.toLowerCase()) ? a : [...a, kw]);
          setTaxonomy(t => addToTaxonomy(t, kw));
        });
        setCustomInput('');
        setModified(true);
        setIsEditing(true);

        if (selectedImg && newKws.length > 0) {
          const similar = getSimilarImages(selectedImg);
          if (similar.length > 0) {
            setQueue(q => q.map(img => {
              if (similar.some(s => s.id === img.id)) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                const syncKws = newKws
                  .filter(kw => !existingVals.has(kw.value.toLowerCase()))
                  .map(kw => ({ ...kw, id: `sync-${Math.random().toString(36).slice(2)}` }));
                if (syncKws.length > 0) {
                  return { ...img, keywords: [...(img.keywords || []), ...syncKws], status: img.status === 'pending' ? 'ready' : img.status };
                }
              }
              return img;
            }));
          }
        }
      };

      useEffect(() => {
        if (selectedImg && (selectedImg.status === 'ready' || selectedImg.status === 'done') && !modified && !isEditing) {
          setKeywords(selectedImg.keywords || []);
          setPending(selectedImg.pending || []);
          setDesigner(selectedImg.designer || null);
          setVisionData(selectedImg.visionData || null);
        }
      }, [selectedImg?.id, selectedImg?.status]);

      const getCustomKeywords = useCallback(() => {
        const customs = [];
        const collectCustom = (obj, path = []) => {
          for (const [key, value] of Object.entries(obj)) {
            if (key === '_items') continue;
            const currentPath = [...path, key];
            if (key === 'Custom' && Array.isArray(value)) {
              customs.push(...value);
            } else if (key === 'Custom' && value?._items) {
              customs.push(...value._items);
            } else if (typeof value === 'object' && value !== null) {
              collectCustom(value, currentPath);
            }
          }
        };
        collectCustom(taxonomy);
        return customs;
      }, [taxonomy]);

      const runCategorization = async () => {
        if (!geminiKey || isCategorizing) return;

        const customKws = getCustomKeywords();
        if (customKws.length === 0) {
          console.log('[CATEGORIZE] No custom keywords to categorize');
          return;
        }

        setIsCategorizing(true);
        console.log(`[CATEGORIZE] Categorizing ${customKws.length} custom keywords...`);

        try {
          const batchSize = 20;
          for (let i = 0; i < customKws.length; i += batchSize) {
            const batch = customKws.slice(i, i + batchSize);
            const results = await categorizeKeywords(geminiKey, batch);

            if (results.length > 0) {
              setTaxonomy(prevTax => {
                let newTax = JSON.parse(JSON.stringify(prevTax));

                results.forEach(result => {
                  if (!result.path || result.path.length === 0 || result.path[0] === 'Custom') return;

                  if (Array.isArray(newTax.Custom)) {
                    newTax.Custom = newTax.Custom.filter(k => k.toLowerCase() !== result.keyword.toLowerCase());
                  } else if (newTax.Custom?._items) {
                    newTax.Custom._items = newTax.Custom._items.filter(k => k.toLowerCase() !== result.keyword.toLowerCase());
                  }

                  let current = newTax;
                  for (let j = 0; j < result.path.length; j++) {
                    const key = result.path[j];
                    if (j === result.path.length - 1) {
                      if (Array.isArray(current[key])) {
                        if (!current[key].some(k => k.toLowerCase() === result.keyword.toLowerCase())) {
                          current[key].push(result.keyword);
                        }
                      } else if (typeof current[key] === 'object' && current[key] !== null) {
                        if (!current[key]._items) current[key]._items = [];
                        if (!current[key]._items.some(k => k.toLowerCase() === result.keyword.toLowerCase())) {
                          current[key]._items.push(result.keyword);
                        }
                      } else if (current[key] === undefined) {
                        current[key] = [result.keyword];
                      }
                    } else {
                      if (current[key] === undefined) {
                        current[key] = {};
                      } else if (Array.isArray(current[key])) {
                        current[key] = { _items: current[key] };
                      }
                      current = current[key];
                    }
                  }

                  console.log(`[CATEGORIZE] Moved "${result.keyword}" to ${result.path.join(' > ')}`);
                });

                return newTax;
              });
            }
          }
          console.log('[CATEGORIZE] Done!');
        } catch (e) {
          console.error('[CATEGORIZE] Error:', e);
        } finally {
          setIsCategorizing(false);
        }
      };

      const customCount = getCustomKeywords().length;

      // Auto-run categorization when custom keywords accumulate
      const autoCategorizeTimeoutRef = useRef(null);
      useEffect(() => {
        if (customCount > 0 && geminiKey && !isCategorizing) {
          // Clear any pending timeout
          if (autoCategorizeTimeoutRef.current) {
            clearTimeout(autoCategorizeTimeoutRef.current);
          }
          // Schedule auto-categorization after 3 seconds of inactivity
          autoCategorizeTimeoutRef.current = setTimeout(() => {
            console.log('[AUTO-CATEGORIZE] Triggering auto-categorization for', customCount, 'custom keywords');
            runCategorization();
          }, 3000);
        }
        return () => {
          if (autoCategorizeTimeoutRef.current) {
            clearTimeout(autoCategorizeTimeoutRef.current);
          }
        };
      }, [customCount, geminiKey, isCategorizing]);

      // Auto-consolidate pending keywords to master taxonomy synonyms
      const [isConsolidating, setIsConsolidating] = useState(false);
      const consolidateTimeoutRef = useRef(null);

      useEffect(() => {
        if (pending.length > 0 && geminiKey && !isConsolidating && taxInfo.allTerms.size > 0) {
          if (consolidateTimeoutRef.current) {
            clearTimeout(consolidateTimeoutRef.current);
          }
          consolidateTimeoutRef.current = setTimeout(async () => {
            setIsConsolidating(true);
            try {
              const reviewKws = pending.map(k => k.value);
              const masterTerms = Array.from(taxInfo.allTerms);
              console.log('[CONSOLIDATE] Checking', reviewKws.length, 'keywords against', masterTerms.length, 'master terms');

              const matches = await consolidateKeywords(geminiKey, reviewKws, masterTerms);
              console.log('[CONSOLIDATE] Found', matches.length, 'matches');

              if (matches.length > 0) {
                // For each match, find the pending keyword and auto-accept it with the master term
                matches.forEach(match => {
                  const pendingKw = pending.find(k => k.value.toLowerCase() === match.review.toLowerCase());
                  if (pendingKw && match.confidence >= 0.8) {
                    console.log(`[CONSOLIDATE] Replacing "${pendingKw.value}" with master term "${match.master}"`);
                    // Update the keyword value to match master taxonomy
                    const consolidatedKw = { ...pendingKw, value: match.master, consolidated: true };
                    const path = smartCategorize(consolidatedKw);
                    consolidatedKw.path = path;
                    consolidatedKw.rootCategory = path[0];

                    // Auto-accept it
                    setPending(p => p.filter(k => k.id !== pendingKw.id));
                    setKeywords(kws => [...kws, consolidatedKw]);
                    setAccepted(a => a.some(x => x.value.toLowerCase() === consolidatedKw.value.toLowerCase()) ? a : [...a, consolidatedKw]);
                    setModified(true);
                    setIsEditing(true);
                  }
                });
              }
            } catch (e) {
              console.error('[CONSOLIDATE] Error:', e);
            } finally {
              setIsConsolidating(false);
            }
          }, 2000);
        }
        return () => {
          if (consolidateTimeoutRef.current) {
            clearTimeout(consolidateTimeoutRef.current);
          }
        };
      }, [pending, geminiKey, taxInfo.allTerms]);

      const tree = buildTree(accepted);
      const getColor = (r) => ROOT_COLORS[r] || '#94a3b8';

      const totalCount = queue.length;
      const hiddenCount = queue.filter(q => q.hidden).length;
      const doneCount = queue.filter(q => q.status === 'done').length;
      const readyCount = queue.filter(q => (q.status === 'ready' || q.status === 'editing') && !q.hidden).length;
      const analyzingCount = queue.filter(q => q.status === 'analyzing').length;
      const pendingCount = queue.filter(q => q.status === 'pending' && !q.hidden).length;
      const editingCount = queue.filter(q => q.status === 'editing' && !q.hidden).length;
      const similarCount = selectedImg ? getSimilarImages(selectedImg).length : 0;

      const thumbSizes = [60, 90, 130, 180];
      const currentThumbSize = thumbSizes[thumbSize];

      // Unified style system
      const s = {
        bg: '#0a0a0a',
        panel: '#111',
        panelHover: '#1a1a1a',
        border: '#222',
        text: '#9ca3af',
        bright: '#f3f4f6',
        muted: '#6b7280',
        fontSize: 14,
        radius: 8,
        radiusSm: 6,
        radiusLg: 12
      };

      return (
        <div ref={containerRef} tabIndex={0} style={{ display: 'flex', flexDirection: 'column', height: '100vh', width: '100vw', fontSize: s.fontSize, lineHeight: 1.5, background: s.bg, color: s.text, outline: 'none' }}>
          <input ref={fileRef} type="file" accept="image/*" multiple onChange={handleFileInput} style={{ display: 'none' }} />
          <input ref={folderRef} type="file" accept="image/*" multiple webkitdirectory="" onChange={handleFileInput} style={{ display: 'none' }} />

          {/* TOOLBAR */}
          <div style={{ height: 56, background: s.panel, display: 'flex', alignItems: 'center', padding: '0 16px', gap: 12, borderBottom: `1px solid ${s.border}`, flexShrink: 0 }}>
            {/* Left side - Import buttons */}
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <button onClick={() => fileRef.current?.click()} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '8px 14px', background: '#1f2937', color: s.bright, border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                <Icon name="add_photo_alternate" size={18} /> Files
              </button>
              <button onClick={() => folderRef.current?.click()} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '8px 14px', background: '#1f2937', color: s.bright, border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                <Icon name="folder_open" size={18} /> Folder
              </button>
            </div>

            <div style={{ width: 1, height: 24, background: s.border }} />

            {/* Logo & Status */}
            <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
              <div style={{ width: 20, height: 20, background: 'linear-gradient(135deg, #8b5cf6, #3b82f6)', borderRadius: 5 }} />
              <span style={{ color: s.bright, fontWeight: 600, fontSize: s.fontSize }}>Tagger</span>
            </div>

            <span style={{ color: s.muted, fontSize: s.fontSize }}>
              {filteredQueue.length}/{totalCount}
              {analyzingCount > 0 && <span style={{ color: '#fbbf24' }}>  {analyzingCount} analyzing</span>}
              {readyCount > 0 && <span style={{ color: '#60a5fa' }}>  {readyCount} ready</span>}
            </span>

            {/* Right side - Actions */}
            <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: 10 }}>
              {pendingCount > 0 && (
                <button onClick={analyzeAllPending} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '8px 16px', background: '#2563eb', color: 'white', border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize, fontWeight: 500 }}>
                  <Icon name="auto_awesome" size={18} /> Analyze All ({pendingCount})
                </button>
              )}
              {readyToSaveCount > 0 && (
                <button onClick={saveAll} disabled={isSavingAll} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '8px 16px', background: isSavingAll ? '#374151' : '#10b981', color: isSavingAll ? '#9ca3af' : 'white', border: 'none', borderRadius: s.radius, cursor: isSavingAll ? 'default' : 'pointer', fontSize: s.fontSize, fontWeight: 500 }}>
                  <Icon name={isSavingAll ? "hourglass_empty" : "save"} size={18} /> {isSavingAll ? 'Saving...' : `Save All (${readyToSaveCount})`}
                </button>
              )}
              {outputDir && (
                <div style={{ display: 'flex', alignItems: 'center', gap: 4, color: '#10b981', fontSize: s.fontSize }}>
                  <Icon name="check_circle" size={16} filled /> Auto-save
                </div>
              )}
              <button onClick={() => setShowSettings(true)} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: 40, height: 40, background: 'transparent', color: s.muted, border: 'none', borderRadius: s.radius, cursor: 'pointer' }}>
                <Icon name="settings" size={22} />
              </button>
            </div>
          </div>

          {/* MAIN */}
          <div ref={mainPanelRef} style={{ flex: 1, display: 'flex', overflow: 'hidden', width: '100%', cursor: isDraggingDivider ? 'col-resize' : 'default' }}>

            {/* LEFT - GRID */}
            <div style={{ width: `${gridWidth}%`, minWidth: 250, background: s.panel, display: 'flex', flexDirection: 'column' }}>
              <div style={{ padding: '10px 12px', borderBottom: `1px solid ${s.border}`, display: 'flex', gap: 8, alignItems: 'center', flexWrap: 'wrap' }}>
                <button onClick={() => setShowPending(!showPending)}
                  style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 12px', background: showPending ? 'rgba(251,191,36,0.15)' : '#1f2937', color: showPending ? '#fbbf24' : s.muted, border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: s.fontSize }}>
                  <Icon name="pending" size={16} /> Pending ({pendingCount})
                </button>
                <button onClick={() => setShowDone(!showDone)}
                  style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 12px', background: showDone ? 'rgba(74,222,128,0.15)' : '#1f2937', color: showDone ? '#4ade80' : s.muted, border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: s.fontSize }}>
                  <Icon name="check_circle" size={16} /> Done ({doneCount})
                </button>
                <button onClick={() => setShowHidden(!showHidden)}
                  style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 12px', background: showHidden ? 'rgba(248,113,113,0.15)' : '#1f2937', color: showHidden ? '#f87171' : s.muted, border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: s.fontSize }}>
                  <Icon name="visibility_off" size={16} /> Hidden ({hiddenCount})
                </button>
                <div style={{ marginLeft: 'auto', display: 'flex', gap: 2, background: '#1f2937', borderRadius: s.radiusSm, padding: 2 }}>
                  {['S', 'M', 'L', 'XL'].map((label, i) => (
                    <button key={label} onClick={() => setThumbSize(i)}
                      style={{ padding: '4px 10px', background: thumbSize === i ? '#374151' : 'transparent', color: thumbSize === i ? s.bright : s.muted, border: 'none', borderRadius: 4, cursor: 'pointer', fontSize: 13, fontWeight: thumbSize === i ? 500 : 400 }}>
                      {label}
                    </button>
                  ))}
                </div>
              </div>
              <div style={{ flex: 1, overflow: 'auto', padding: 12 }}>
                {filteredQueue.length === 0 ? (
                  <div style={{ padding: 60, textAlign: 'center', color: s.muted }}>
                    <Icon name="add_photo_alternate" size={64} style={{ opacity: 0.3, display: 'block', margin: '0 auto 16px' }} />
                    <div style={{ fontSize: s.fontSize, marginBottom: 8 }}>Drop images here</div>
                    <div style={{ fontSize: 13, color: '#4b5563' }}>Use arrow keys to navigate</div>
                  </div>
                ) : (
                  <div style={{ display: 'grid', gridTemplateColumns: `repeat(auto-fill, minmax(${currentThumbSize}px, 1fr))`, gap: 8 }}>
                    {filteredQueue.map(item => {
                      const isSelected = item.id === selectedId;
                      const statusColor = item.status === 'done' ? '#4ade80' : item.status === 'editing' ? '#4ade80' : item.status === 'ready' ? '#60a5fa' : item.status === 'analyzing' ? '#fbbf24' : item.status === 'error' ? '#f87171' : '#6b7280';
                      return (
                        <motion.div
                          key={item.id}
                          initial={{ opacity: 0, scale: 0.9 }}
                          animate={{ opacity: 1, scale: 1 }}
                          transition={{ duration: 0.2 }}
                          onClick={() => selectImage(item.id)}
                          style={{ position: 'relative', borderRadius: s.radius, overflow: 'hidden', cursor: 'pointer',
                            border: `2px solid ${isSelected ? '#60a5fa' : 'transparent'}`,
                            boxShadow: isSelected ? '0 0 0 2px rgba(96,165,250,0.3)' : 'none',
                            opacity: item.hidden ? 0.4 : item.status === 'done' ? 0.7 : 1 }}>
                          <div style={{ aspectRatio: '1', background: `url(${item.url}) center/cover` }}>
                            <div style={{ position: 'absolute', top: 6, left: 6, width: 10, height: 10, borderRadius: 5, background: statusColor, boxShadow: '0 1px 3px rgba(0,0,0,0.4)' }} />
                            {item.status === 'analyzing' && (
                              <div style={{ position: 'absolute', inset: 0, background: 'rgba(0,0,0,0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                <Icon name="hourglass_empty" size={28} style={{ color: '#fbbf24' }} />
                              </div>
                            )}
                            {item.status === 'done' && (
                              <div style={{ position: 'absolute', top: 6, right: 6, background: '#4ade80', color: '#000', padding: '3px 6px', borderRadius: s.radiusSm, fontSize: 12, fontWeight: 600, display: 'flex', alignItems: 'center' }}>
                                <Icon name="check" size={14} />
                              </div>
                            )}
                            {item.status === 'editing' && (
                              <div style={{ position: 'absolute', top: 6, right: 6, background: '#60a5fa', color: '#000', padding: '3px 6px', borderRadius: s.radiusSm, fontSize: 12, fontWeight: 600, display: 'flex', alignItems: 'center' }}>
                                <Icon name="edit" size={14} />
                              </div>
                            )}
                            {item.hidden && (
                              <div style={{ position: 'absolute', top: 6, right: 6, background: '#f87171', color: '#fff', padding: '3px 6px', borderRadius: s.radiusSm, fontSize: 12, display: 'flex', alignItems: 'center' }}>
                                <Icon name="visibility_off" size={14} />
                              </div>
                            )}
                          </div>
                          <button onClick={(e) => item.hidden ? unhideImage(item.id, e) : hideImage(item.id, e)} tabIndex={-1}
                            style={{ position: 'absolute', bottom: 6, right: 6, background: 'rgba(0,0,0,0.8)', border: 'none', color: '#9ca3af', cursor: 'pointer', padding: 4, borderRadius: s.radiusSm, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                            <Icon name={item.hidden ? "visibility" : "close"} size={16} />
                          </button>
                        </motion.div>
                      );
                    })}
                  </div>
                )}
              </div>
            </div>

            {/* RESIZABLE DIVIDER */}
            <div
              onMouseDown={handleDividerMouseDown}
              style={{
                width: 12,
                background: isDraggingDivider ? s.border : 'transparent',
                cursor: 'col-resize',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                flexShrink: 0,
                transition: 'background 0.15s'
              }}
              onMouseEnter={(e) => e.currentTarget.style.background = s.border}
              onMouseLeave={(e) => !isDraggingDivider && (e.currentTarget.style.background = 'transparent')}
            >
              <div style={{
                width: 4,
                height: 40,
                background: '#4b5563',
                borderRadius: 2,
                opacity: 0.6
              }} />
            </div>

            {/* CENTER - PREVIEW */}
            <div style={{ flex: 1, minWidth: 280, display: 'flex', flexDirection: 'column', background: s.bg }}>
              {selectedImg ? (
                <>
                  <div style={{ height: '35%', minHeight: 140, background: '#000', display: 'flex', alignItems: 'center', justifyContent: 'center', position: 'relative' }}>
                    <img src={selectedImg.url} style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain' }} />
                    <div style={{ position: 'absolute', bottom: 8, left: 8, background: 'rgba(0,0,0,0.85)', padding: '4px 10px', borderRadius: s.radiusSm, color: s.text, fontSize: 13, maxWidth: '85%', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                      {selectedImg.name}
                    </div>
                    {modified && (
                      <div style={{ position: 'absolute', top: 8, right: 8, background: '#fbbf24', color: '#000', padding: '4px 8px', borderRadius: s.radiusSm, fontSize: 12, fontWeight: 500, display: 'flex', alignItems: 'center', gap: 4 }}>
                        <Icon name="edit" size={14} /> Unsaved
                      </div>
                    )}
                    {downloadedLarger && (
                      <div style={{ position: 'absolute', top: 8, left: 8, background: '#10b981', color: '#fff', padding: '4px 8px', borderRadius: s.radiusSm, fontSize: 12, display: 'flex', alignItems: 'center', gap: 4 }}>
                        <Icon name="download" size={14} /> {(downloadedLarger.size / 1024 / 1024).toFixed(1)}MB
                      </div>
                    )}
                  </div>

                  <div style={{ flex: 1, overflow: 'auto', padding: 14 }}>
                    {selectedImg.status === 'analyzing' && (
                      <div style={{ textAlign: 'center', padding: 40, color: s.muted }}>
                        <Icon name="hourglass_empty" size={36} style={{ display: 'block', margin: '0 auto 12px', color: '#fbbf24' }} />
                        <div style={{ fontSize: s.fontSize }}>Analyzing...</div>
                      </div>
                    )}

                    {selectedImg.status === 'error' && (
                      <div style={{ textAlign: 'center', padding: 40, color: '#f87171' }}>
                        <Icon name="error" size={36} style={{ display: 'block', margin: '0 auto 12px' }} />
                        <div style={{ fontSize: s.fontSize, marginBottom: 12 }}>Analysis failed</div>
                        <button onClick={() => { setQueue(q => q.map(i => i.id === selectedImg.id ? {...i, status: 'pending'} : i)); analyzeImage({...selectedImg, status: 'pending'}); }}
                          style={{ display: 'inline-flex', alignItems: 'center', gap: 6, padding: '8px 16px', background: '#2563eb', color: 'white', border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                          <Icon name="refresh" size={16} /> Retry
                        </button>
                      </div>
                    )}

                    {(selectedImg.status === 'ready' || selectedImg.status === 'done' || selectedImg.status === 'editing' || isEditing) && (
                      <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
                        {(designer?.designer || designer?.designers?.length > 0) && (
                          <div style={{ background: 'rgba(167,139,250,0.1)', padding: '10px 12px', borderRadius: s.radius, border: '1px solid rgba(167,139,250,0.25)' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#a78bfa', fontSize: s.fontSize }}>
                              <Icon name="brush" size={18} />
                              {designer.designers?.length > 1 ? designer.designers.join(', ') : designer.designer}
                            </div>
                          </div>
                        )}

                        {similarCount > 0 && (
                          <div style={{ background: 'rgba(251,191,36,0.1)', padding: '10px 12px', borderRadius: s.radius, border: '1px solid rgba(251,191,36,0.25)' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#fbbf24', fontSize: s.fontSize }}>
                              <Icon name="link" size={18} />
                              {similarCount} similar image{similarCount > 1 ? 's' : ''} will sync
                            </div>
                          </div>
                        )}

                        {visionData?.matchingImages?.length > 0 && (
                          <div style={{ background: 'rgba(96,165,250,0.1)', padding: '10px 12px', borderRadius: s.radius, border: '1px solid rgba(96,165,250,0.25)' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#60a5fa', fontSize: s.fontSize, marginBottom: 8 }}>
                              <Icon name="image_search" size={18} />
                              {visionData.matchingImages.length} web matches
                            </div>
                            <div style={{ display: 'flex', gap: 6, flexWrap: 'wrap' }}>
                              {visionData.matchingImages.slice(0, 4).map((img, i) => (
                                <a key={i} href={img.url} target="_blank" rel="noreferrer" style={{ color: '#60a5fa', fontSize: 12, textDecoration: 'none', padding: '4px 8px', background: 'rgba(96,165,250,0.15)', borderRadius: s.radiusSm }}>
                                  {img.type}
                                </a>
                              ))}
                            </div>
                          </div>
                        )}

                        {keywords.length > 0 && (
                          <div style={{ background: s.panel, borderRadius: s.radius, padding: 12, border: `1px solid ${s.border}` }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#4ade80', marginBottom: 10, fontSize: s.fontSize, fontWeight: 500 }}>
                              <Icon name="sell" size={18} />
                              Tagged ({keywords.length})
                            </div>
                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6 }}>
                              {keywords.map(k => (
                                <motion.span
                                  key={k.id}
                                  initial={{ opacity: 0, scale: 0.8 }}
                                  animate={{ opacity: 1, scale: 1 }}
                                  style={{ padding: '5px 10px', background: `${getColor(k.rootCategory)}15`, color: getColor(k.rootCategory), borderRadius: 20, fontSize: 13, display: 'flex', alignItems: 'center', gap: 6, border: `1px solid ${getColor(k.rootCategory)}30` }}>
                                  {k.source === 'vision' && <Icon name="image_search" size={14} />}
                                  {k.source === 'filename' && <Icon name="description" size={14} />}
                                  {k.value}
                                  <span onClick={() => removeKw(k.id)} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 2, display: 'flex' }}>
                                    <Icon name="close" size={14} />
                                  </span>
                                </motion.span>
                              ))}
                            </div>
                          </div>
                        )}

                        {pending.length > 0 && (
                          <div style={{ background: s.panel, borderRadius: s.radius, padding: 12, border: `1px solid ${s.border}` }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 10 }}>
                              <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: s.bright, fontSize: s.fontSize, fontWeight: 500 }}>
                                <Icon name="rate_review" size={18} />
                                {pending.length} to review
                              </div>
                              <button onClick={acceptAll} style={{ display: 'flex', alignItems: 'center', gap: 4, padding: '4px 10px', background: 'rgba(96,165,250,0.15)', color: '#60a5fa', border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: 13 }}>
                                <Icon name="done_all" size={16} /> Accept all
                              </button>
                            </div>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                              {pending.map(k => (
                                <motion.div
                                  key={k.id}
                                  initial={{ opacity: 0, x: -10 }}
                                  animate={{ opacity: 1, x: 0 }}
                                  style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 8px', background: 'rgba(255,255,255,0.03)', borderRadius: s.radiusSm }}>
                                  <button onClick={() => block(k.id)} tabIndex={-1} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: 28, height: 28, background: 'rgba(248,113,113,0.15)', color: '#f87171', border: 'none', borderRadius: s.radiusSm, cursor: 'pointer' }}>
                                    <Icon name="block" size={16} />
                                  </button>
                                  <button onClick={() => accept(k.id)} tabIndex={-1} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: 28, height: 28, background: 'rgba(74,222,128,0.15)', color: '#4ade80', border: 'none', borderRadius: s.radiusSm, cursor: 'pointer' }}>
                                    <Icon name="check" size={16} />
                                  </button>
                                  <span style={{ width: 6, height: 6, borderRadius: 3, background: getColor(k.rootCategory), flexShrink: 0 }} />
                                  <span style={{ color: s.bright, fontSize: s.fontSize, flex: 1, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{k.value}</span>
                                </motion.div>
                              ))}
                            </div>
                          </div>
                        )}

                        <div style={{ display: 'flex', gap: 8 }}>
                          <input type="text" value={customInput} onChange={e => setCustomInput(e.target.value)}
                            onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); addCustom(); } }}
                            placeholder="Add custom tag..."
                            style={{ flex: 1, padding: '10px 14px', background: s.panel, border: `1px solid ${s.border}`, borderRadius: s.radius, color: s.bright, fontSize: s.fontSize, outline: 'none' }} />
                          <button onClick={addCustom} disabled={!customInput.trim()} tabIndex={-1}
                            style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: 44, background: customInput.trim() ? '#ec4899' : '#1f2937', color: customInput.trim() ? 'white' : '#4b5563', border: 'none', borderRadius: s.radius, cursor: customInput.trim() ? 'pointer' : 'default' }}>
                            <Icon name="add" size={22} />
                          </button>
                        </div>

                        <button
                          onClick={() => modified && keywords.length > 0 && saveImage(selectedImg, keywords, designer)}
                          disabled={!modified || keywords.length === 0}
                          tabIndex={-1}
                          style={{
                            display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 8, padding: '12px 20px',
                            background: modified && keywords.length > 0 ? '#2563eb' : '#1f2937',
                            color: modified && keywords.length > 0 ? 'white' : '#4b5563',
                            border: 'none', borderRadius: s.radius,
                            cursor: modified && keywords.length > 0 ? 'pointer' : 'default',
                            fontSize: s.fontSize, fontWeight: 500,
                            opacity: modified && keywords.length > 0 ? 1 : 0.6
                          }}>
                          <Icon name="save" size={20} />
                          {modified && keywords.length > 0
                            ? `Save${similarCount > 0 ? ` + ${similarCount} similar` : ''}`
                            : 'Nothing to save'}
                        </button>
                      </div>
                    )}

                    {selectedImg.status === 'pending' && (
                      <div style={{ textAlign: 'center', padding: 40, color: s.muted }}>
                        <button onClick={() => analyzeImage(selectedImg)} tabIndex={-1}
                          style={{ display: 'inline-flex', alignItems: 'center', gap: 8, padding: '12px 24px', background: '#2563eb', color: 'white', border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize, fontWeight: 500 }}>
                          <Icon name="auto_awesome" size={20} /> Analyze
                        </button>
                      </div>
                    )}
                  </div>
                </>
              ) : (
                <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', color: s.muted }}>
                  <div style={{ textAlign: 'center' }}>
                    <Icon name="image" size={64} style={{ opacity: 0.2, display: 'block', margin: '0 auto 16px' }} />
                    <div style={{ fontSize: s.fontSize }}>Select an image</div>
                    <div style={{ fontSize: 13, marginTop: 8, color: '#4b5563' }}>Use arrow keys to navigate</div>
                  </div>
                </div>
              )}
            </div>

            {/* RIGHT - TAXONOMY */}
            <div style={{ width: 375, minWidth: 280, flexShrink: 0, background: s.panel, borderLeft: `1px solid ${s.border}`, display: 'flex', flexDirection: 'column' }}>
              <div style={{ padding: '14px 16px', borderBottom: `1px solid ${s.border}`, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: s.bright, fontSize: s.fontSize, fontWeight: 600 }}>
                    <Icon name="account_tree" size={20} />
                    Taxonomy
                  </div>
                  <div style={{ color: s.muted, fontSize: 13, marginTop: 4 }}>
                    {accepted.length} accepted  {taxInfo.allTerms.size} in dictionary{customCount > 0 ? `  ${customCount} uncategorized` : ''}
                  </div>
                </div>
                <div style={{ display: 'flex', gap: 6 }}>
                  {customCount > 0 && showMasterTaxonomy && (
                    <button onClick={runCategorization} disabled={isCategorizing || !geminiKey} tabIndex={-1}
                      style={{ display: 'flex', alignItems: 'center', gap: 4, padding: '6px 10px', background: isCategorizing ? '#374151' : '#ec4899', color: isCategorizing ? '#9ca3af' : 'white', border: 'none', borderRadius: s.radiusSm, cursor: isCategorizing ? 'default' : 'pointer', fontSize: 13 }}>
                      <Icon name={isCategorizing ? "hourglass_empty" : "auto_fix_high"} size={16} /> {customCount}
                    </button>
                  )}
                  <button onClick={() => setShowMasterTaxonomy(!showMasterTaxonomy)} tabIndex={-1}
                    style={{ display: 'flex', alignItems: 'center', gap: 4, padding: '6px 10px', background: showMasterTaxonomy ? 'rgba(96,165,250,0.15)' : '#1f2937', color: showMasterTaxonomy ? '#60a5fa' : s.muted, border: 'none', borderRadius: s.radiusSm, cursor: 'pointer', fontSize: 13 }}>
                    <Icon name={showMasterTaxonomy ? "list" : "library_books"} size={16} />
                    {showMasterTaxonomy ? 'Session' : 'Master'}
                  </button>
                </div>
              </div>
              <div style={{ flex: 1, padding: 12, overflowY: 'auto' }}>
                {showMasterTaxonomy ? (
                  <div style={{ fontSize: 13 }}>
                    <div style={{ color: s.muted, marginBottom: 12 }}>Master dictionary ({taxInfo.allTerms.size} terms)</div>
                    {Object.entries(taxonomy).map(([name, value]) => (
                      <MasterTaxonomyNode key={name} name={name} value={value} depth={0} expanded={expanded}
                        onToggle={p => setExpanded(e => ({ ...e, [p]: e[p] === false ? true : false }))}
                        onDelete={deleteFromMasterTaxonomy} />
                    ))}
                  </div>
                ) : Object.keys(tree).length === 0 ? (
                  <div style={{ textAlign: 'center', padding: 32, color: s.muted }}>
                    <Icon name="folder_open" size={40} style={{ opacity: 0.3, display: 'block', margin: '0 auto 12px' }} />
                    <div style={{ fontSize: s.fontSize, marginBottom: 6 }}>Empty</div>
                    <div style={{ fontSize: 13, color: '#4b5563' }}>Analyze images to build taxonomy</div>
                  </div>
                ) : (
                  Object.entries(tree).map(([name, node]) => (
                    <TreeNode key={name} name={name} node={node} depth={0} expanded={expanded}
                      onToggle={p => setExpanded(e => ({ ...e, [p]: e[p] === false ? true : false }))}
                      onDeleteKeyword={deleteFromTaxonomy} />
                  ))
                )}
              </div>
            </div>
          </div>

          {/* SETTINGS */}
          <AnimatePresence>
            {showSettings && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                onClick={() => setShowSettings(false)}
                style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.75)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 200 }}>
                <motion.div
                  initial={{ opacity: 0, scale: 0.95, y: 20 }}
                  animate={{ opacity: 1, scale: 1, y: 0 }}
                  exit={{ opacity: 0, scale: 0.95, y: 20 }}
                  onClick={e => e.stopPropagation()}
                  style={{ background: s.panel, borderRadius: s.radiusLg, width: 480, maxHeight: '85vh', overflow: 'auto', border: `1px solid ${s.border}`, boxShadow: '0 25px 50px -12px rgba(0,0,0,0.5)' }}>
                  <div style={{ padding: '18px 20px', borderBottom: `1px solid ${s.border}`, display: 'flex', alignItems: 'center', gap: 10 }}>
                    <Icon name="settings" size={22} style={{ color: s.muted }} />
                    <span style={{ color: s.bright, fontSize: 16, fontWeight: 600 }}>Settings</span>
                  </div>
                  <div style={{ padding: 20, display: 'flex', flexDirection: 'column', gap: 20 }}>
                    <div>
                      <div style={{ marginBottom: 8, color: s.text, fontSize: s.fontSize, fontWeight: 500 }}>Gemini API Key</div>
                      <input type="password" value={geminiKey} onChange={e => setGeminiKey(e.target.value)}
                        style={{ width: '100%', padding: '10px 14px', background: s.bg, border: `1px solid ${s.border}`, borderRadius: s.radius, color: s.bright, fontSize: s.fontSize, outline: 'none' }} />
                      <a href="https://aistudio.google.com/apikey" target="_blank" rel="noreferrer" style={{ display: 'inline-flex', alignItems: 'center', gap: 4, color: '#60a5fa', fontSize: 13, marginTop: 6, textDecoration: 'none' }}>
                        Get API key <Icon name="open_in_new" size={14} />
                      </a>
                    </div>
                    <div>
                      <div style={{ marginBottom: 8, color: s.text, fontSize: s.fontSize, fontWeight: 500 }}>Vision API Key (optional)</div>
                      <input type="password" value={visionKey} onChange={e => setVisionKey(e.target.value)}
                        style={{ width: '100%', padding: '10px 14px', background: s.bg, border: `1px solid ${s.border}`, borderRadius: s.radius, color: s.bright, fontSize: s.fontSize, outline: 'none' }} />
                      <a href="https://console.cloud.google.com/apis/library/vision.googleapis.com" target="_blank" rel="noreferrer" style={{ display: 'inline-flex', alignItems: 'center', gap: 4, color: '#60a5fa', fontSize: 13, marginTop: 6, textDecoration: 'none' }}>
                        Enable Vision API <Icon name="open_in_new" size={14} />
                      </a>
                    </div>

                    <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
                      <label style={{ display: 'flex', alignItems: 'center', gap: 12, cursor: 'pointer', padding: '10px 14px', background: s.bg, borderRadius: s.radius }}>
                        <input type="checkbox" checked={useVision} onChange={e => setUseVision(e.target.checked)} style={{ width: 18, height: 18, accentColor: '#60a5fa' }} />
                        <div>
                          <div style={{ fontSize: s.fontSize, color: s.bright }}>Use Vision API for reverse image search</div>
                          <div style={{ fontSize: 13, color: s.muted }}>Find web matches and similar images</div>
                        </div>
                      </label>
                      <label style={{ display: 'flex', alignItems: 'center', gap: 12, cursor: 'pointer', padding: '10px 14px', background: s.bg, borderRadius: s.radius }}>
                        <input type="checkbox" checked={autoDownloadLarger} onChange={e => setAutoDownloadLarger(e.target.checked)} style={{ width: 18, height: 18, accentColor: '#60a5fa' }} />
                        <div>
                          <div style={{ fontSize: s.fontSize, color: s.bright }}>Auto-download larger versions</div>
                          <div style={{ fontSize: 13, color: s.muted }}>Requires output folder to be set</div>
                        </div>
                      </label>
                    </div>

                    <div>
                      <div style={{ marginBottom: 10, color: s.text, fontSize: s.fontSize, fontWeight: 500 }}>Save Mode</div>
                      <div style={{ display: 'flex', gap: 12 }}>
                        <label style={{ flex: 1, padding: '14px 16px', border: `2px solid ${saveMode === 'embed' ? '#60a5fa' : s.border}`, background: saveMode === 'embed' ? 'rgba(96,165,250,0.1)' : 'transparent', borderRadius: s.radius, cursor: 'pointer', display: 'flex', alignItems: 'center', gap: 10 }}>
                          <input type="radio" checked={saveMode === 'embed'} onChange={() => setSaveMode('embed')} style={{ width: 18, height: 18, accentColor: '#60a5fa' }} />
                          <div>
                            <div style={{ fontSize: s.fontSize, color: s.bright }}>Embed XMP</div>
                            <div style={{ fontSize: 13, color: s.muted }}>Write metadata into file</div>
                          </div>
                        </label>
                        <label style={{ flex: 1, padding: '14px 16px', border: `2px solid ${saveMode === 'sidecar' ? '#60a5fa' : s.border}`, background: saveMode === 'sidecar' ? 'rgba(96,165,250,0.1)' : 'transparent', borderRadius: s.radius, cursor: 'pointer', display: 'flex', alignItems: 'center', gap: 10 }}>
                          <input type="radio" checked={saveMode === 'sidecar'} onChange={() => setSaveMode('sidecar')} style={{ width: 18, height: 18, accentColor: '#60a5fa' }} />
                          <div>
                            <div style={{ fontSize: s.fontSize, color: s.bright }}>Sidecar .xmp</div>
                            <div style={{ fontSize: 13, color: s.muted }}>Create separate file</div>
                          </div>
                        </label>
                      </div>
                    </div>

                    <button onClick={async () => { try { setOutputDir(await window.showDirectoryPicker({ mode: 'readwrite' })); } catch {} }}
                      style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 8, padding: '12px 16px', background: outputDir ? 'rgba(16,185,129,0.15)' : '#1f2937', color: outputDir ? '#10b981' : s.text, border: `1px solid ${outputDir ? 'rgba(16,185,129,0.3)' : s.border}`, borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                      <Icon name={outputDir ? "check_circle" : "folder_open"} size={20} />
                      {outputDir ? 'Output folder set' : 'Choose output folder'}
                    </button>
                  </div>
                  <div style={{ padding: '16px 20px', borderTop: `1px solid ${s.border}`, display: 'flex', justifyContent: 'flex-end' }}>
                    <button onClick={() => setShowSettings(false)} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '10px 20px', background: '#2563eb', color: 'white', border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize, fontWeight: 500 }}>
                      Done
                    </button>
                  </div>
                </motion.div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
