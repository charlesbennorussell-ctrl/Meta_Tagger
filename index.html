<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MegaTagger</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/framer-motion@11/dist/framer-motion.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #1D1D1D; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; font-size: 13px; color: #A4A4A4; }
    ::-webkit-scrollbar { width: 12px; height: 12px; }
    ::-webkit-scrollbar-track { background: #1D1D1D; }
    ::-webkit-scrollbar-thumb { background: #3A3A3A; border-radius: 10px; border: 3px solid #1D1D1D; }
    ::-webkit-scrollbar-thumb:hover { background: #777777; }
    #drop-overlay { display: none; position: fixed; inset: 0; background: rgba(128,128,128,0.15); border: 2px dashed #1D1D1D; z-index: 9999; align-items: center; justify-content: center; backdrop-filter: blur(4px); }
    #drop-overlay.active { display: flex; }
    .material-symbols-rounded { font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24; vertical-align: middle; }
    .material-symbols-rounded.filled { font-variation-settings: 'FILL' 1, 'wght' 400, 'GRAD' 0, 'opsz' 24; }
    button { transition: all 0.15s ease; }
    button:hover:not(:disabled):not(.no-hover) { filter: brightness(1.15); }
    button:active:not(:disabled) { transform: scale(0.98); }
  </style>
</head>
<body>
  <div id="drop-overlay"><div style="background: #2D2D2D; padding: 40px 72px; border-radius: 4px; color: #A4A4A4; font-size: 13px; display: flex; align-items: center; gap: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 2px solid #0F0F0F;"><span class="material-symbols-rounded" style="font-size: 32px; color: #A4A4A4;">upload_file</span> Drop images or folder here</div></div>
  <div id="root"></div>

  <script>
    const overlay = document.getElementById('drop-overlay');
    let dragCounter = 0;
    document.addEventListener('dragenter', (e) => { e.preventDefault(); dragCounter++; overlay.classList.add('active'); });
    document.addEventListener('dragleave', (e) => { e.preventDefault(); dragCounter--; if (dragCounter === 0) overlay.classList.remove('active'); });
    document.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
    document.addEventListener('drop', async (e) => {
      e.preventDefault(); dragCounter = 0; overlay.classList.remove('active');
      const files = await extractFiles(e.dataTransfer);
      if (files.length > 0 && window.onFilesDropped) window.onFilesDropped(files);
    });

    async function extractFiles(dataTransfer) {
      const files = [];
      const entries = [];

      // First, collect all entries (must be done synchronously before promises)
      const items = dataTransfer.items;
      if (items?.length > 0) {
        for (let i = 0; i < items.length; i++) {
          const entry = items[i].webkitGetAsEntry?.();
          if (entry) entries.push(entry);
        }
      }

      console.log('[EXTRACT] Items:', items?.length, 'Entries:', entries.length);

      async function processEntry(entry) {
        if (!entry) return;
        if (entry.isFile) {
          try {
            const file = await new Promise((resolve, reject) => entry.file(resolve, reject));
            if (file.type.startsWith('image/')) {
              console.log('[EXTRACT] Found image:', file.name);
              files.push(file);
            }
          } catch (e) { console.error('[EXTRACT] Error getting file:', e); }
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          let dirEntries = [];
          while (true) {
            const batch = await new Promise((resolve) => reader.readEntries(resolve, () => resolve([])));
            if (batch.length === 0) break;
            dirEntries = dirEntries.concat(batch);
          }
          for (const e of dirEntries) await processEntry(e);
        }
      }

      // Process all entries
      for (const entry of entries) {
        await processEntry(entry);
      }

      // Fallback to dataTransfer.files if no entries worked
      if (files.length === 0 && dataTransfer.files) {
        console.log('[EXTRACT] Fallback to dataTransfer.files:', dataTransfer.files.length);
        for (let i = 0; i < dataTransfer.files.length; i++) {
          if (dataTransfer.files[i].type.startsWith('image/')) files.push(dataTransfer.files[i]);
        }
      }

      console.log('[EXTRACT] Total files:', files.length);
      return files;
    }
  </script>

  <!-- Load data and utilities (plain JS, no JSX) -->
  <script src="js/data.js"></script>
  <script src="js/utils.js"></script>
  <script src="js/api.js"></script>
  <script src="js/performance.js"></script>

  <script type="text/babel">
    const { useState, useRef, useEffect, useMemo, useCallback, memo, Fragment } = React;
    const { motion, AnimatePresence } = window.Motion;

    // Import performance utilities
    const { generateThumbnail, resizeForAPI, storeThumbnail, getThumbnail, storeAnalysis, getAnalysis, deleteAnalysis, BatchProcessor, LazyLoader, throttle, debounce, getMemoryUsage, saveOutputDirectory, loadOutputDirectory } = window.TaggerPerformance;

    // Icon component for Material Symbols
    const Icon = ({ name, size = 20, filled = false, style = {} }) => (
      <span
        className={`material-symbols-rounded${filled ? ' filled' : ''}`}
        style={{ fontSize: size, ...style }}
      >{name}</span>
    );

    // Claude-style Toggle Switch component (segmented control style)
    const Toggle = ({ checked, onChange, label, disabled = false, offLabel = 'Off', onLabel = 'On', s }) => (
      <div
        style={{
          display: 'inline-flex',
          background: s.bgMid,
          borderRadius: 20,
          padding: 4,
          gap: 0
        }}
      >
        <button
          onClick={() => !disabled && onChange(false)}
          disabled={disabled}
          style={{
            padding: '8px 32px',
            background: !checked ? s.bgMid : 'transparent',
            color: !checked ? '#FFFFFF' : s.textMuted,
            border: 'none',
            borderRadius: 16,
            cursor: disabled ? 'not-allowed' : 'pointer',
            opacity: disabled ? 0.5 : 1,
            fontSize: s.fontSize,
            fontWeight: s.fontWeight,
            transition: 'all 0.2s ease',
            whiteSpace: 'nowrap'
          }}
        >
          {offLabel}
        </button>
        <button
          onClick={() => !disabled && onChange(true)}
          disabled={disabled}
          style={{
            padding: '8px 32px',
            background: checked ? s.bgMid : 'transparent',
            color: checked ? '#FFFFFF' : s.textMuted,
            border: 'none',
            borderRadius: 16,
            cursor: disabled ? 'not-allowed' : 'pointer',
            opacity: disabled ? 0.5 : 1,
            fontSize: s.fontSize,
            fontWeight: s.fontWeight,
            transition: 'all 0.2s ease',
            whiteSpace: 'nowrap'
          }}
        >
          {onLabel}
        </button>
      </div>
    );

    // Optimized thumbnail component with lazy loading
    const ThumbnailImage = memo(({ item, isSelected, onSelect, onHide, onUnhide, thumbSize, showPending, showDone, showAnalyzing, s }) => {
      const [thumbUrl, setThumbUrl] = useState(null);
      const [isLoading, setIsLoading] = useState(true);
      const imgRef = useRef(null);

      useEffect(() => {
        let mounted = true;
        let objectUrl = null;

        const loadThumbnail = async () => {
          try {
            // Try to get cached thumbnail first
            const cachedThumb = await getThumbnail(item.hash);
            if (cachedThumb && mounted) {
              objectUrl = URL.createObjectURL(cachedThumb);
              setThumbUrl(objectUrl);
              setIsLoading(false);
              return;
            }

            // Generate and cache thumbnail (2x for retina, but cap at 600px to avoid excessive memory)
            const thumb = await generateThumbnail(item.file, Math.min(thumbSize * 2, 600));
            if (thumb && mounted) {
              await storeThumbnail(item.hash, thumb);
              objectUrl = URL.createObjectURL(thumb);
              setThumbUrl(objectUrl);
              setIsLoading(false);
            }
          } catch (e) {
            console.error('[THUMB] Load failed:', e);
            // Fallback to original URL
            if (mounted) {
              setThumbUrl(item.url);
              setIsLoading(false);
            }
          }
        };

        // Use IntersectionObserver for lazy loading
        const observer = new IntersectionObserver(
          (entries) => {
            if (entries[0].isIntersecting) {
              loadThumbnail();
              observer.disconnect();
            }
          },
          { rootMargin: '400px' }
        );

        if (imgRef.current) {
          observer.observe(imgRef.current);
        }

        return () => {
          mounted = false;
          if (objectUrl) URL.revokeObjectURL(objectUrl);
          observer.disconnect();
        };
      }, [item.hash, item.file, thumbSize]);

      const statusColor = item.status === 'done' ? '#68B757' : item.status === 'editing' ? '#4147FF' : item.status === 'ready' ? '#4147FF' : item.status === 'analyzing' ? '#fbbf24' : item.status === 'error' ? '#ef4444' : s.textMuted;
      const selectionColor = showDone ? '#68B757' : showPending ? '#4147FF' : showAnalyzing ? '#fbbf24' : s.text;

      return (
        <motion.div
          ref={imgRef}
          layout
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.15, layout: { duration: 0.1, ease: 'easeOut' } }}
          onClick={(e) => onSelect(item.id, e)}
          title={item.status === 'error' ? item.errorMessage || 'Analysis failed - click to retry' : ''}
          style={{
            position: 'relative', borderRadius: 0, overflow: 'hidden', cursor: 'pointer',
            border: `2px solid ${isSelected ? selectionColor : 'transparent'}`,
            boxShadow: 'none',
            opacity: item.hidden ? 0.4 : item.status === 'done' ? 0.7 : 1,
            backgroundColor: '#2B2B2B'
          }}
        >
          <div style={{ aspectRatio: '1', background: thumbUrl && !isLoading ? `url(${thumbUrl}) center/cover` : '#2B2B2B', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            {isLoading && <Icon name="image" size={24} style={{ color: s.textMuted }} />}
            <div style={{ position: 'absolute', top: 6, left: 6, width: 10, height: 10, borderRadius: 5, background: statusColor, boxShadow: '0 1px 3px rgba(0,0,0,0.4)' }} />
            {item.status === 'analyzing' && (
              <div style={{ position: 'absolute', inset: 0, background: 'rgba(251,191,36,0.3)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                <Icon name="hourglass_empty" size={28} style={{ color: '#fbbf24' }} />
              </div>
            )}
            {item.status === 'error' && (
              <div style={{ position: 'absolute', inset: 0, background: 'rgba(0,0,0,0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                <Icon name="error" size={28} style={{ color: s.textMuted }} />
              </div>
            )}
            {item.hidden && (
              <div style={{ position: 'absolute', top: 6, right: 6, background: s.textMuted, color: '#000', padding: '3px 6px', borderRadius: 6, fontSize: s.fontSize, display: 'flex', alignItems: 'center' }}>
                <Icon name="visibility_off" size={14} />
              </div>
            )}
          </div>
          <button
            onClick={(e) => item.hidden ? onUnhide(item.id, e) : onHide(item.id, e)}
            tabIndex={-1}
            style={{ position: 'absolute', bottom: 6, right: 6, background: 'rgba(0,0,0,0.8)', border: 'none', color: s.text, cursor: 'pointer', padding: 4, borderRadius: 6, display: 'flex', alignItems: 'center', justifyContent: 'center' }}
          >
            <Icon name={item.hidden ? "visibility" : "close"} size={16} />
          </button>
        </motion.div>
      );
    });

    // Import from modules
    const { DEFAULT_TAXONOMY, ROOT_COLORS, STORAGE_KEY, TAXONOMY_KEY, REQUIRED_CATEGORIES } = window.TaggerData;
    const {
      smartCategorize, addToTaxonomy, removeFromTaxonomy, flattenTaxonomy,
      getBrandPath, looksLikeBrand, parseEra, splitBrandModel, deduplicateKeywords,
      buildTree, countKeywords, hashFile, getBaseName, loadMemory, saveMemory,
      getCachedAnalysis, setCachedAnalysis,
      extractFromFilename, extractFromUrls, extractExistingMetadata, generateXMP,
      embedXMP, embedXMPinPNG, convertToJPEG, isRawFormat, supportsEmbedding,
      autoAssignRequiredCategory
    } = window.TaggerUtils;
    const { analyzeWithGemini, findDesigner, categorizeKeywords, analyzeWithVision, extractCreatorsFromWebMatches, downloadLargerVersion, organizeTaxonomy, researchKeyword } = window.TaggerAPI;

    // ============================================
    // REACT COMPONENTS (must be in Babel block for JSX)
    // ============================================
    const TreeNode = ({ name, node, depth = 0, expanded, onToggle, onDeleteKeyword, s }) => {
      const children = node._children || {};
      const hasChildren = Object.keys(children).length > 0;
      const keywords = node._keywords || [];
      const count = countKeywords(node);
      const pathKey = node._path?.join('>');
      const isExpanded = true; // Always expanded
      const color = ROOT_COLORS[node._path?.[0]] || s.text;

      return (
        <div style={{ marginLeft: depth > 0 ? 16 : 0 }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 8, padding: '6px 8px', borderRadius: depth === 0 ? 20 : 6, background: depth === 0 ? 'rgba(255,255,255,0.03)' : 'transparent' }}>
            {depth > 0 && <span style={{ color: s.textMuted, fontSize: s.fontSize, marginRight: 4 }}>└</span>}
            <span style={{ flex: 1, color: depth === 0 ? '#777777' : '#777777', fontSize: s.fontSize }}>{name}</span>
            <span style={{ color: s.text, fontSize: s.fontSize }}>{count}</span>
          </div>
          {isExpanded && keywords.length > 0 && (
            <div style={{ marginLeft: depth > 0 ? 48 : 28, color: s.text, fontSize: s.fontSize, lineHeight: s.lineHeight }}>
              {keywords.map((kw, idx) => (
                <span key={kw.id} style={{ display: 'inline-block', whiteSpace: 'nowrap' }}>
                  <span>{kw.value}</span>
                  <span onClick={(e) => { e.stopPropagation(); onDeleteKeyword(kw.id); }} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 4, display: 'inline-flex', verticalAlign: 'middle' }}>
                    <Icon name="close" size={12} />
                  </span>
                  {idx < keywords.length - 1 && <span style={{ margin: '0 8px', opacity: 0.5 }}>·</span>}
                </span>
              ))}
            </div>
          )}
          {isExpanded && hasChildren && Object.entries(children).map(([n, c]) => (
            <TreeNode key={n} name={n} node={c} depth={depth + 1} expanded={expanded} onToggle={onToggle} onDeleteKeyword={onDeleteKeyword} s={s} />
          ))}
        </div>
      );
    };

    const MasterTaxonomyNode = ({ name, value, path = [], depth = 0, expanded, onToggle, onDelete, s }) => {
      const currentPath = [...path, name];
      const pathKey = currentPath.join('>');
      const isExpanded = true; // Always expanded
      const color = ROOT_COLORS[currentPath[0]] || s.text;

      let children = {};
      let items = [];
      if (Array.isArray(value)) {
        items = value;
      } else if (typeof value === 'object' && value !== null) {
        items = value._items || [];
        children = Object.fromEntries(Object.entries(value).filter(([k]) => k !== '_items'));
      }

      const hasChildren = Object.keys(children).length > 0;
      const hasItems = items.length > 0;
      const hasContent = hasChildren || hasItems;

      return (
        <div style={{ marginLeft: depth > 0 ? 16 : 0 }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 8, padding: '6px 8px', borderRadius: depth === 0 ? 20 : 6, background: depth === 0 ? 'rgba(255,255,255,0.03)' : 'transparent' }}>
            {depth > 0 && <span style={{ color: s.textMuted, fontSize: s.fontSize, marginRight: 4 }}>└</span>}
            <span style={{ flex: 1, color: depth === 0 ? '#777777' : '#777777', fontSize: s.fontSize }}>{name}</span>
          </div>
          {isExpanded && hasItems && (
            <div style={{ marginLeft: depth > 0 ? 48 : 28, color: s.text, fontSize: s.fontSize, lineHeight: s.lineHeight }}>
              {items.map((item, idx) => (
                <span key={`${pathKey}-${item}-${idx}`} style={{ display: 'inline-block', whiteSpace: 'nowrap' }}>
                  <span>{item}</span>
                  <span onClick={(e) => { e.stopPropagation(); onDelete(currentPath, item); }} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 4, display: 'inline-flex', verticalAlign: 'middle' }}>
                    <Icon name="close" size={12} />
                  </span>
                  {idx < items.length - 1 && <span style={{ margin: '0 8px', opacity: 0.5 }}>·</span>}
                </span>
              ))}
            </div>
          )}
          {isExpanded && hasChildren && Object.entries(children).map(([n, v]) => (
            <MasterTaxonomyNode key={n} name={n} value={v} path={currentPath} depth={depth + 1} expanded={expanded} onToggle={onToggle} onDelete={onDelete} s={s} />
          ))}
        </div>
      );
    };

    // ============================================
    // MAIN APP
    // ============================================
    function App() {
      const [geminiKey, setGeminiKey] = useState(localStorage.getItem('gemini_api_key') || '');
      const [visionKey, setVisionKey] = useState(localStorage.getItem('vision_api_key') || '');
      const [useVision, setUseVision] = useState(localStorage.getItem('use_vision') === 'true');
      const [autoDownloadLarger, setAutoDownloadLarger] = useState(localStorage.getItem('auto_download_larger') === 'true');
      const [showSettings, setShowSettings] = useState(false);
      const [saveMode, setSaveMode] = useState(localStorage.getItem('save_mode') || 'embed');
      const [outputDir, setOutputDir] = useState(null);
      const [outputDirName, setOutputDirName] = useState(localStorage.getItem('output_dir_name') || '');
      const [thumbSize, setThumbSize] = useState(parseInt(localStorage.getItem('thumb_size')) || 1);
      const [continuousSaveEnabled, setContinuousSaveEnabled] = useState(false);

      const [taxonomy, setTaxonomy] = useState(() => {
        try { return JSON.parse(localStorage.getItem(TAXONOMY_KEY)) || DEFAULT_TAXONOMY; }
        catch { return DEFAULT_TAXONOMY; }
      });
      const taxInfo = useMemo(() => flattenTaxonomy(taxonomy), [taxonomy]);
      // Master taxonomy terms - only from DEFAULT_TAXONOMY, not user additions
      const masterTerms = useMemo(() => {
        const result = flattenTaxonomy(DEFAULT_TAXONOMY);
        console.log('[MASTER] Built', result.allTerms.size, 'master terms');
        return result.allTerms;
      }, []);

      const [queue, setQueue] = useState([]);
      const [memory, setMemory] = useState({});
      const [selectedId, setSelectedId] = useState(null);
      const [selectedIds, setSelectedIds] = useState([]); // Multi-select support
      const [lastClickedId, setLastClickedId] = useState(null); // For shift-click range selection

      // Load memory from browser storage on mount, then from folder when available
      useEffect(() => {
        // Load saved output directory first
        loadOutputDirectory().then(handle => {
          if (handle) {
            setOutputDir(handle);
            setOutputDirName(handle.name);
            console.log('[INIT] Restored output directory:', handle.name);

            // Load memory from folder
            loadMemory(handle).then(m => {
              if (m && Object.keys(m).length > 0) {
                setMemory(m);
              }
            }).catch(e => {
              console.error('[INIT] Failed to load memory from folder:', e);
            });
          } else {
            // No folder, load from browser storage
            loadMemory(null).then(m => {
              if (m && Object.keys(m).length > 0) {
                setMemory(m);
              }
            }).catch(e => {
              console.error('[INIT] Failed to load memory:', e);
            });
          }
        }).catch(e => {
          console.error('[INIT] Failed to restore output directory:', e);
          // Load from browser storage if no folder
          loadMemory(null).then(m => {
            if (m && Object.keys(m).length > 0) {
              setMemory(m);
            }
          });
        });
      }, []);

      const [showDone, setShowDone] = useState(false);
      const [showHidden, setShowHidden] = useState(false);
      const [showPending, setShowPending] = useState(true);
      const [showAnalyzing, setShowAnalyzing] = useState(false);
      const [showMasterTaxonomy, setShowMasterTaxonomy] = useState(false);

      const [pending, setPending] = useState([]);
      const [keywords, setKeywords] = useState([]);
      const [ignored, setIgnored] = useState([]);
      const [designer, setDesigner] = useState(null);
      const [modified, setModified] = useState(false);
      const [visionData, setVisionData] = useState(null);
      const [downloadedLarger, setDownloadedLarger] = useState(null);
      const [isEditing, setIsEditing] = useState(false);

      const [accepted, setAccepted] = useState([]);
      const [blocked, setBlocked] = useState([]);
      const [expanded, setExpanded] = useState({});
      const [customInput, setCustomInput] = useState('');
      const [isCategorizing, setIsCategorizing] = useState(false);
      const [isOrganizing, setIsOrganizing] = useState(false);
      const [organizeProgress, setOrganizeProgress] = useState(null);
      const [gridWidth, setGridWidth] = useState(() => parseInt(localStorage.getItem('grid_width')) || 50); // percentage
      const [isDraggingDivider, setIsDraggingDivider] = useState(false);
      const [autoScan, setAutoScan] = useState(true); // Auto-scan toggle (default: paused)
      const [batchProgress, setBatchProgress] = useState(null); // Batch processing progress

      const fileRef = useRef(null);
      const folderRef = useRef(null);
      const acceptedRef = useRef(new Set());
      const blockedRef = useRef(new Set());
      const containerRef = useRef(null);
      const mainPanelRef = useRef(null);

      // Batch processor for analysis
      const analysisBatchRef = useRef(null);
      useEffect(() => {
        if (!analysisBatchRef.current) {
          analysisBatchRef.current = new BatchProcessor(
            async (img) => {
              await analyzeImageRef.current?.(img);
            },
            { batchSize: 3, delayMs: 400 } // Process 3 images at a time with 400ms delay to avoid rate limits
          );
        }
      }, []);

      useEffect(() => { acceptedRef.current = new Set(accepted.map(k => k.value.toLowerCase())); }, [accepted]);
      useEffect(() => { blockedRef.current = new Set(blocked.map(k => k.value.toLowerCase())); }, [blocked]);

      const selectedImg = queue.find(q => q.id === selectedId);
      const selectedImgs = queue.filter(q => selectedIds.includes(q.id));
      const isMultiSelect = selectedIds.length > 1;

      const filteredQueue = useMemo(() => {
        return queue.filter(q => {
          // Hidden items only show when showHidden is true (exclusive filter)
          if (q.hidden) return showHidden;
          // Non-hidden items filter by status
          if (q.status === 'done') return showDone;
          if (q.status === 'analyzing') return showAnalyzing;
          // showPending button actually means "Ready" view - only show ready/editing, not actual pending
          if (showPending) {
            return q.status === 'ready' || q.status === 'editing';
          }
          return false;
        });
      }, [queue, showDone, showHidden, showPending, showAnalyzing]);

      const findPath = useCallback((kwValue, kwType = 'keyword') => {
        const key = kwValue.toLowerCase().trim();
        if (taxInfo.paths[key]) return taxInfo.paths[key];
        return smartCategorize({ value: kwValue, type: kwType });
      }, [taxInfo]);

      // Keyboard navigation
      useEffect(() => {
        const handleKeyDown = async (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          // X key - hide current image and advance to next
          if (e.key === 'x' || e.key === 'X') {
            e.preventDefault();
            const img = selectedImgRef.current;
            if (img) {
              console.log('[KEYBOARD] X pressed - hiding:', img.name);
              // Hide the image
              setQueue(q => q.map(i => i.id === img.id ? { ...i, hidden: true } : i));
              setMemory(prev => ({ ...prev, [img.hash]: { ...prev[img.hash], hidden: true } }));

              // Advance to next image
              const currentIndex = filteredQueue.findIndex(q => q.id === img.id);
              const nextFiltered = filteredQueue.filter(q => q.id !== img.id); // Re-filter without hidden
              if (nextFiltered.length > 0) {
                const nextIndex = currentIndex < nextFiltered.length ? currentIndex : 0;
                const nextId = nextFiltered[nextIndex].id;
                setSelectedIds([nextId]);
                setLastClickedId(nextId);
                selectImage(nextId);
              }
            }
            return;
          }

          // Enter key - save current image(s) and advance to next
          // Alt+Ctrl+R - Clear thumbnail cache and re-import folder
          if (e.ctrlKey && e.altKey && e.key === 'r') {
            e.preventDefault();

            // Clear IndexedDB thumbnail cache
            if (window.TaggerPerformance && window.TaggerPerformance.initDB) {
              window.TaggerPerformance.initDB().then(async db => {
                const tx = db.transaction('thumbnails', 'readwrite');
                const store = tx.objectStore('thumbnails');
                await store.clear();
                console.log('[REBUILD] Thumbnail cache cleared');

                // Prompt user to re-select the source folder
                alert('Thumbnail cache cleared!\n\nNow re-import your folder to rebuild thumbnails with the latest file versions (e.g., after Dropbox finished syncing).');

                // Trigger folder picker by clicking the folder button
                const folderButton = document.querySelector('button[onclick*="showDirectoryPicker"]');
                if (folderButton) {
                  folderButton.click();
                } else {
                  console.warn('[REBUILD] Could not find folder button to trigger');
                }
              }).catch(e => console.error('[REBUILD] Failed:', e));
            }
            return;
          }

          if (e.key === 'Enter') {
            e.preventDefault();
            const img = selectedImgRef.current;
            const kws = keywordsRef.current;
            const currentSelectedIds = selectedIdsRef.current;

            if (img && kws.length > 0 && saveImageRef.current) {
              // Check for required category
              const hasRequiredCategory = kws.some(k => REQUIRED_CATEGORIES.includes(k.value));
              if (!hasRequiredCategory) {
                alert('Please select at least one primary category (Industrial Design, Graphic Design, Art, Photography, or Architecture) before saving.');
                return;
              }

              // Check if multi-select is active
              if (currentSelectedIds.length > 1) {
                console.log('[KEYBOARD] Enter pressed - saving', currentSelectedIds.length, 'selected images');
                // Save all selected images with the CURRENT keywords from the primary selection (skip sync to avoid cascade)
                const selectedImages = queueRef.current.filter(q => currentSelectedIds.includes(q.id));
                for (const selectedImg of selectedImages) {
                  // Apply current keywords to ALL selected images
                  console.log('[KEYBOARD] Saving:', selectedImg.name, 'with', kws.length, 'keywords');
                  await saveImageRef.current(selectedImg, kws, designerRef.current, true); // skipSync=true
                }

                // Clear multi-select and advance to next
                const nextFiltered = filteredQueue.filter(q => !currentSelectedIds.includes(q.id));
                if (nextFiltered.length > 0) {
                  const nextId = nextFiltered[0].id;
                  setSelectedIds([nextId]);
                  setLastClickedId(nextId);
                  selectImage(nextId);
                }
              } else {
                // Single selection - save with sync
                console.log('[KEYBOARD] Enter pressed - saving:', img.name);
                await saveImageRef.current(img, kws, designerRef.current, false); // skipSync=false

                // Advance to next image
                const currentIndex = filteredQueue.findIndex(q => q.id === img.id);
                if (currentIndex !== -1 && filteredQueue.length > 1) {
                  const nextIndex = currentIndex < filteredQueue.length - 1 ? currentIndex + 1 : 0;
                  const nextId = filteredQueue[nextIndex].id;
                  setSelectedIds([nextId]);
                  setLastClickedId(nextId);
                  selectImage(nextId);
                }
              }
            }
            return;
          }

          if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const currentIndex = filteredQueue.findIndex(q => q.id === selectedId);
            let newIndex = currentIndex;

            if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
              newIndex = currentIndex < filteredQueue.length - 1 ? currentIndex + 1 : 0;
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
              newIndex = currentIndex > 0 ? currentIndex - 1 : filteredQueue.length - 1;
            }

            if (filteredQueue[newIndex]) {
              const newId = filteredQueue[newIndex].id;
              setSelectedIds([newId]); // Update blue outline to follow arrow navigation
              setLastClickedId(newId);
              selectImage(newId);
            }
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [filteredQueue, selectedId]);

      // Save settings
      useEffect(() => {
        if (geminiKey) localStorage.setItem('gemini_api_key', geminiKey);
        if (visionKey) localStorage.setItem('vision_api_key', visionKey);
        localStorage.setItem('use_vision', useVision.toString());
        localStorage.setItem('auto_download_larger', autoDownloadLarger.toString());
        localStorage.setItem('save_mode', saveMode);
        localStorage.setItem('thumb_size', thumbSize.toString());
      }, [geminiKey, visionKey, useVision, autoDownloadLarger, saveMode, thumbSize]);

      // Auto-save memory to folder or IndexedDB (debounced to avoid excessive writes)
      useEffect(() => {
        const timeoutId = setTimeout(() => {
          if (Object.keys(memory).length > 0) {
            saveMemory(memory, outputDir).catch(e => console.error('[MEMORY] Save failed:', e));
          }
        }, 1000); // Debounce 1 second
        return () => clearTimeout(timeoutId);
      }, [memory, outputDir]);
      useEffect(() => { localStorage.setItem(TAXONOMY_KEY, JSON.stringify(taxonomy)); }, [taxonomy]);
      useEffect(() => { localStorage.setItem('grid_width', gridWidth.toString()); }, [gridWidth]);

      // Divider drag handlers
      const handleDividerMouseDown = useCallback((e) => {
        e.preventDefault();
        setIsDraggingDivider(true);
      }, []);

      useEffect(() => {
        if (!isDraggingDivider) return;

        const handleMouseMove = (e) => {
          const container = mainPanelRef.current;
          if (!container) return;
          const rect = container.getBoundingClientRect();
          const taxonomyWidth = 375; // fixed taxonomy panel width
          const dividerWidth = 12;
          const availableWidth = rect.width - taxonomyWidth - dividerWidth;
          const mouseX = e.clientX - rect.left;
          // Calculate as percentage of available width (excluding taxonomy)
          const newGridWidth = Math.max(20, Math.min(80, (mouseX / availableWidth) * 100));
          setGridWidth(Math.round(newGridWidth));
        };

        const handleMouseUp = () => {
          setIsDraggingDivider(false);
        };

        // Add cursor style to body during drag for consistent cursor
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        return () => {
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        };
      }, [isDraggingDivider]);

      const queueRef = useRef(queue);
      const memoryRef = useRef(memory);
      const geminiKeyRef = useRef(geminiKey);
      const autoScanRef = useRef(autoScan);
      const analyzeImageRef = useRef(null);
      const saveImageRef = useRef(null);
      const selectedImgRef = useRef(null);
      const selectedIdsRef = useRef([]);
      const keywordsRef = useRef([]);
      const designerRef = useRef(null);
      useEffect(() => { queueRef.current = queue; }, [queue]);
      useEffect(() => { memoryRef.current = memory; }, [memory]);
      useEffect(() => { geminiKeyRef.current = geminiKey; }, [geminiKey]);
      useEffect(() => { autoScanRef.current = autoScan; }, [autoScan]);
      useEffect(() => { keywordsRef.current = keywords; }, [keywords]);
      useEffect(() => { designerRef.current = designer; }, [designer]);

      useEffect(() => {
        window.onFilesDropped = async (files) => { await processFilesRef.current(files); };
        return () => { window.onFilesDropped = null; };
      }, []);

      // Restore output directory on mount if we have a saved name
      useEffect(() => {
        if (outputDirName && !outputDir) {
          // Show a hint that output folder needs to be re-selected
          console.log('[OUTPUT] Previous output folder was:', outputDirName);
        }
      }, []);

      // Save output dir to IndexedDB when it changes and load memory from the new folder
      const outputDirRef = useRef(null);
      useEffect(() => {
        if (outputDir && outputDir !== outputDirRef.current) {
          const previousDir = outputDirRef.current;
          outputDirRef.current = outputDir;

          localStorage.setItem('output_dir_name', outputDir.name); // Keep for backward compatibility
          setOutputDirName(outputDir.name);
          // Save the actual handle to IndexedDB for persistence
          saveOutputDirectory(outputDir).catch(e => {
            console.error('[SETTINGS] Failed to save output directory:', e);
          });

          // If switching folders (not initial load), save current memory first
          if (previousDir && Object.keys(memory).length > 0) {
            console.log('[FOLDER] Saving current memory before switching folders');
            saveMemory(memory, previousDir).catch(e => {
              console.error('[FOLDER] Failed to save to previous folder:', e);
            });
          }

          // Load memory from the newly selected folder
          loadMemory(outputDir).then(m => {
            if (m && Object.keys(m).length > 0) {
              setMemory(m);
              console.log('[FOLDER] Loaded memory from folder:', Object.keys(m).length, 'items');
            } else {
              console.log('[FOLDER] No existing data in folder, starting fresh');
              // If no data in folder but we have current memory, keep it (user might be setting up a new folder)
              if (Object.keys(memory).length === 0) {
                setMemory({});
              }
            }
          }).catch(e => {
            console.error('[FOLDER] Failed to load memory from folder:', e);
          });
        }
      }, [outputDir, memory]);

      // Clear cache and re-analyze non-done images
      const refreshAnalysis = useCallback(() => {
        const cacheKey = 'tagger_analysis_cache';
        const nonDoneImages = queue.filter(q => q.status !== 'done' && !q.hidden);

        console.log('[REFRESH] Clearing cache for', nonDoneImages.length, 'non-done images');

        // Clear cache entries for non-done images
        try {
          const cache = JSON.parse(localStorage.getItem(cacheKey) || '{}');
          nonDoneImages.forEach(img => {
            delete cache[img.hash];
          });
          localStorage.setItem(cacheKey, JSON.stringify(cache));
        } catch (e) {
          console.error('[REFRESH] Cache clear failed:', e);
        }

        // Reset status to pending and trigger re-analysis
        setQueue(q => q.map(item => {
          if (item.status !== 'done' && !item.hidden) {
            return { ...item, status: 'pending', keywords: [], pending: [] };
          }
          return item;
        }));

        // Trigger analysis after state update
        setTimeout(() => {
          if (geminiKey) {
            nonDoneImages.forEach(img => {
              analyzeImageRef.current?.({ ...img, status: 'pending' });
            });
          }
        }, 100);
      }, [queue, geminiKey]);

      // Organize taxonomy - research and categorize custom keywords
      const handleOrganizeTaxonomy = useCallback(async () => {
        if (!geminiKey || isOrganizing) return;

        setIsOrganizing(true);
        setOrganizeProgress({ phase: 'init', message: 'Starting...' });

        try {
          const result = await organizeTaxonomy(geminiKey, taxonomy, (progress) => {
            setOrganizeProgress(progress);
          });

          if (result.changes.length > 0) {
            setTaxonomy(result.taxonomy);
            localStorage.setItem(TAXONOMY_KEY, JSON.stringify(result.taxonomy));
            console.log('[ORGANIZE] Applied', result.changes.length, 'changes');
          } else {
            console.log('[ORGANIZE] No changes needed');
          }
        } catch (e) {
          console.error('[ORGANIZE] Error:', e);
        } finally {
          setIsOrganizing(false);
          setOrganizeProgress(null);
        }
      }, [geminiKey, isOrganizing, taxonomy]);

      const processFilesRef = useRef(null);
      processFilesRef.current = async (files) => {
        console.log('[DROP] Received files:', files.length, files.map(f => f.name));
        const imgs = files.filter(f => f.type.startsWith('image/'));
        console.log('[DROP] Image files:', imgs.length);
        if (!imgs.length) return;

        const currentMemory = memoryRef.current;
        const newItems = await Promise.all(imgs.map(async (file) => {
          const hash = await hashFile(file);
          const mem = currentMemory[hash];
          const filenameKws = extractFromFilename(file.name);
          const existingKws = await extractExistingMetadata(file);
          const calculatedBaseName = getBaseName(file.name);

          // Check if we have cached analysis in IndexedDB
          const cachedAnalysis = await getAnalysis(hash);

          // Determine status: done if exported, pending if needs analysis
          let status = 'pending';
          let keywords = [];
          let pending = [];

          if (mem?.exported) {
            status = 'done';
            keywords = mem.keywords || [];
            pending = mem.pending || [];
          } else if (mem?.keywords && mem.keywords.length > 0) {
            // Has keywords in memory but not exported - mark as ready
            status = 'ready';
            keywords = mem.keywords || [];
            pending = mem.pending || [];
          }
          // If cachedAnalysis exists but no keywords in memory, leave as pending
          // and let analyzeImage process the cache to set it to ready

          console.log('[DROP] Processing:', file.name, 'hash:', hash, 'baseName:', calculatedBaseName, 'status:', status, 'cachedAnalysis:', !!cachedAnalysis);
          return {
            id: hash, name: file.name, file, url: URL.createObjectURL(file),
            baseName: calculatedBaseName,
            status,
            hidden: mem?.hidden || false,
            keywords, pending,
            filenameKeywords: filenameKws,
            existingKeywords: existingKws,
            creator: mem?.creator || null, hash
          };
        }));

        const existingIds = new Set(queueRef.current.map(q => q.id));
        const uniqueItems = newItems.filter(item => !existingIds.has(item.id));
        console.log('[DROP] New items:', newItems.length, 'Unique:', uniqueItems.length, 'Existing IDs:', existingIds.size);

        if (uniqueItems.length > 0) {
          setQueue(prev => [...prev, ...uniqueItems]);

          setTimeout(async () => {
            if (geminiKeyRef.current) {
              // First, check for items with cached analysis that need processing
              const cachedItems = [];
              for (const item of uniqueItems) {
                if (item.status === 'pending' && !item.hidden) {
                  const cached = await getAnalysis(item.hash);
                  if (cached) {
                    cachedItems.push(item);
                  }
                }
              }

              // Always process cached items (they're instant)
              if (cachedItems.length > 0) {
                console.log('[AUTO-ANALYZE] Processing', cachedItems.length, 'cached items');
                cachedItems.forEach(item => {
                  analyzeImageRef.current?.(item);
                });
              }

              // Only auto-analyze NEW items if autoScan is enabled
              if (autoScanRef.current) {
                const toAnalyze = uniqueItems.filter(item => item.status === 'pending' && !item.hidden && !cachedItems.includes(item));
                console.log('[AUTO-ANALYZE] Auto-scan ON - batch analyzing', toAnalyze.length, 'new items');

                // Use batch processor for large sets
                if (toAnalyze.length > 10) {
                  setBatchProgress({ current: 0, total: toAnalyze.length });
                  analysisBatchRef.current.addBatch(toAnalyze);

                  // Monitor batch progress
                  const checkProgress = setInterval(() => {
                    const pending = analysisBatchRef.current.pending;
                    const processed = toAnalyze.length - pending;
                    setBatchProgress({ current: processed, total: toAnalyze.length });

                    if (pending === 0) {
                      clearInterval(checkProgress);
                      setTimeout(() => setBatchProgress(null), 2000);
                    }
                  }, 500);
                } else {
                  // Small batch, process directly
                  toAnalyze.forEach(item => {
                    analyzeImageRef.current?.(item);
                  });
                }
              } else if (cachedItems.length === 0) {
                console.log('[AUTO-ANALYZE] Auto-scan OFF - skipping new analysis');
              }
            }
          }, 100);
        }
      };

      const handleFileInput = (e) => {
        if (e.target.files?.length) processFilesRef.current(Array.from(e.target.files));
        e.target.value = '';
      };

      // Find similar images using multi-criteria scoring
      // Memoize similar images to prevent excessive recalculation
      const similarImagesCache = useRef(new Map());
      const queueLengthRef = useRef(queue.length);

      // Clear cache when queue length changes (items added/removed)
      useEffect(() => {
        if (queueLengthRef.current !== queue.length) {
          similarImagesCache.current.clear();
          queueLengthRef.current = queue.length;
        }
      }, [queue.length]);

      const getSimilarImages = useCallback((img) => {
        if (!img) return [];

        // Check cache first
        const cacheKey = `${img.id}-${queue.length}`;
        if (similarImagesCache.current.has(cacheKey)) {
          return similarImagesCache.current.get(cacheKey);
        }

        console.log(`[SIMILAR] Called for "${img.name}" with baseName: "${img.baseName}" (length: ${img.baseName?.length || 0})`);

        // Minimum baseName length check (lowered to 3 to support IMG_XXXX patterns)
        if (!img.baseName || img.baseName.length < 3) {
          console.log(`[SIMILAR] Rejected: baseName too short or missing`);
          return [];
        }

        // Helper: Extract sequence number from filename
        const getSequenceNumber = (filename) => {
          const noExt = filename.replace(/\.[^.]+$/, '');
          const match = noExt.match(/[-_](\d{1,3})$/);
          return match ? parseInt(match[1], 10) : null;
        };

        // Helper: Calculate keyword similarity (0-1)
        const getKeywordSimilarity = (kw1, kw2) => {
          if (!kw1 || !kw2 || kw1.length === 0 || kw2.length === 0) return 0;
          const set1 = new Set(kw1.map(k => k.value.toLowerCase()));
          const set2 = new Set(kw2.map(k => k.value.toLowerCase()));
          const intersection = new Set([...set1].filter(k => set2.has(k)));
          const union = new Set([...set1, ...set2]);
          return intersection.size / union.size; // Jaccard similarity
        };

        // Score each potential match using combined criteria
        const candidates = queue
          .filter(q => q.id !== img.id && q.baseName === img.baseName)
          .map(q => {
            const reasons = [];
            let isMatch = false;

            const name1 = img.name.toLowerCase().replace(/\.[^.]+$/, '');
            const name2 = q.name.toLowerCase().replace(/\.[^.]+$/, '');

            // Calculate all match criteria
            // 1. Filename prefix similarity
            const minLen = Math.min(name1.length, name2.length);
            const maxLen = Math.max(name1.length, name2.length);
            let commonPrefixLen = 0;
            for (let i = 0; i < minLen; i++) {
              if (name1[i] === name2[i]) commonPrefixLen++;
              else break;
            }
            const prefixMatch = (commonPrefixLen / maxLen) >= 0.7;

            // 2. Sequential filename numbers
            const seq1 = getSequenceNumber(img.name);
            const seq2 = getSequenceNumber(q.name);
            const seqDiff = (seq1 !== null && seq2 !== null) ? Math.abs(seq1 - seq2) : Infinity;
            const isSequential = seqDiff <= 10;

            // 3. File timestamp proximity
            let timeMatch = false;
            let timeWithinTwoDays = false;
            if (img.file && q.file) {
              const time1 = img.file.lastModified || 0;
              const time2 = q.file.lastModified || 0;
              const timeDiff = Math.abs(time1 - time2);
              const oneHour = 60 * 60 * 1000;
              const oneDay = 24 * oneHour;
              const twoDays = 2 * oneDay;

              if (timeDiff < oneHour) {
                reasons.push('time: <1h');
                timeMatch = true;
                timeWithinTwoDays = true;
              } else if (timeDiff < oneDay) {
                reasons.push('time: <1d');
                timeWithinTwoDays = true;
              } else if (timeDiff < twoDays) {
                reasons.push('time: <2d');
                timeWithinTwoDays = true;
              }
            }

            // 4. Keyword similarity
            const kwSim = getKeywordSimilarity(img.keywords || [], q.keywords || []);
            const keywordsMatch = kwSim >= 0.5;

            // Match logic: Combined criteria to prevent false matches
            // IMPORTANT: Disable prefix-only matching for very short baseNames (like "img")
            // to prevent false matches across different photo sessions
            const baseNameTooShort = img.baseName.length <= 4;

            if (prefixMatch && !baseNameTooShort) {
              // Prefix match only works for longer baseNames
              reasons.push(`prefix: ${Math.round((commonPrefixLen / maxLen) * 100)}%`);
              isMatch = true;
            } else if (isSequential && (timeWithinTwoDays || keywordsMatch)) {
              // Sequential numbers + time proximity OR keyword match
              reasons.push(`seq: ${seq1}→${seq2} (Δ${seqDiff})`);
              if (keywordsMatch) reasons.push(`keywords: ${Math.round(kwSim * 100)}%`);
              isMatch = true;
            } else if (timeMatch && (isSequential || keywordsMatch)) {
              // Time match MUST be combined with sequential numbers OR keywords
              // to prevent matching all files dropped at the same time
              if (isSequential) reasons.push(`seq: ${seq1}→${seq2} (Δ${seqDiff})`);
              if (keywordsMatch) reasons.push(`keywords: ${Math.round(kwSim * 100)}%`);
              isMatch = true;
            } else if (keywordsMatch && kwSim >= 0.7) {
              // High keyword similarity (70%+) can stand alone
              reasons.push(`keywords: ${Math.round(kwSim * 100)}%`);
              isMatch = true;
            }

            return { img: q, isMatch, reasons };
          });

        // Debug: Log all candidates
        if (candidates.length > 0) {
          console.log(`[SIMILAR] Checking candidates for "${img.name}" (baseName: "${img.baseName}"):`);
          candidates.forEach(c => {
            const status = c.isMatch ? '✓' : '✗';
            console.log(`  ${status} ${c.img.name}: [${c.reasons.join(', ')}]`);
          });
        }

        // Filter: only include matches where isMatch is true
        const similar = candidates
          .filter(c => c.isMatch)
          .map(c => c.img);

        if (similar.length > 0) {
          console.log(`[SIMILAR] ✓ Matched ${similar.length} images using OR logic`);
        } else if (candidates.length > 0) {
          console.log(`[SIMILAR] ✗ No matches found`);
        }

        // Cache the result
        similarImagesCache.current.set(cacheKey, similar);

        // Keep cache size reasonable (last 100 entries)
        if (similarImagesCache.current.size > 100) {
          const firstKey = similarImagesCache.current.keys().next().value;
          similarImagesCache.current.delete(firstKey);
        }

        return similar;
      }, [queue]);

      // Sync keywords to similar images and auto-save
      const syncToSimilarAndSave = useCallback(async (sourceImg, sourceKeywords, sourceDesigner) => {
        const similar = getSimilarImages(sourceImg);
        if (similar.length === 0) return;

        console.log(`[SYNC] Syncing ${sourceKeywords.length} keywords to ${similar.length} similar images`);

        for (const img of similar) {
          const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
          const newKws = sourceKeywords
            .filter(k => !existingVals.has(k.value.toLowerCase()))
            .map(k => ({ ...k, id: `sync-${Math.random().toString(36).slice(2)}` }));

          if (newKws.length > 0) {
            const updatedKeywords = [...(img.keywords || []), ...newKws];

            // Update queue
            setQueue(q => q.map(i => i.id === img.id ? {
              ...i,
              keywords: updatedKeywords,
              designer: sourceDesigner,
              status: 'done'
            } : i));

            // Save to memory
            setMemory(prev => ({
              ...prev,
              [img.hash]: { exported: true, keywords: updatedKeywords, creator: sourceDesigner?.designer, hidden: img.hidden }
            }));

            // Save file if output dir set
            if (outputDir) {
              try {
                let blob, filename = img.name;
                const creator = sourceDesigner?.designer || null;
                const isRaw = isRawFormat(img.name);
                const canEmbed = supportsEmbedding(img.file);

                if (saveMode === 'embed' && img.file.type.includes('jpeg')) {
                  blob = await embedXMP(img.file, updatedKeywords, creator);
                } else if (saveMode === 'embed' && img.file.type.includes('png')) {
                  blob = await embedXMPinPNG(img.file, updatedKeywords, creator);
                } else if (saveMode === 'embed' && !canEmbed && !isRaw) {
                  // Convert WebP/AVIF to JPEG
                  const jpegBlob = await convertToJPEG(img.file);
                  const jpegFile = new File([jpegBlob], 'temp.jpg', { type: 'image/jpeg' });
                  blob = await embedXMP(jpegFile, updatedKeywords, creator);
                  filename = filename.replace(/\.[^.]+$/, '.jpg');
                } else {
                  blob = new Blob([generateXMP(updatedKeywords, creator)], { type: 'application/rdf+xml' });
                  filename = filename.replace(/\.[^.]+$/, '') + '.xmp';
                }

                const fh = await outputDir.getFileHandle(filename, { create: true });
                const w = await fh.createWritable();
                await w.write(blob);
                await w.close();
                console.log(`[SYNC] Auto-saved: ${filename}`);

                // Copy raw file alongside XMP
                if (isRaw) {
                  const rawFh = await outputDir.getFileHandle(img.name, { create: true });
                  const rawW = await rawFh.createWritable();
                  await rawW.write(img.file);
                  await rawW.close();
                  console.log(`[SYNC] Copied raw: ${img.name}`);
                }
              } catch (e) {
                console.error('[SYNC] Save failed:', e);
              }
            }
          }
        }
      }, [queue, outputDir, saveMode, getSimilarImages]);

      // Save image - defined before selectImage to avoid stale reference
      const saveImage = useCallback(async (img, kws, des, skipSync = false) => {
        if (!img || !kws || kws.length === 0) {
          console.log('[SAVE] Skipped - no image or keywords', { img: img?.name, kwsLength: kws?.length });
          return;
        }

        // Require output directory to be set for batch operations
        if (!outputDir && skipSync) {
          console.error('[SAVE] ❌ Cannot batch save without output directory set. Please select an output folder in settings.');
          console.error('[SAVE] Image:', img.name, 'Keywords:', kws.length, 'outputDir:', !!outputDir, 'skipSync:', skipSync);
          return;
        }

        console.log('[SAVE] ✅ Saving:', img.name, 'with', kws.length, 'keywords', 'skipSync:', skipSync, 'outputDir:', !!outputDir);
        try {
          let blob, filename = img.name;
          const creator = des?.designer || null;
          const isRaw = isRawFormat(img.name);
          const canEmbed = supportsEmbedding(img.file);

          if (saveMode === 'embed' && img.file.type.includes('jpeg')) {
            blob = await embedXMP(img.file, kws, creator);
          } else if (saveMode === 'embed' && img.file.type.includes('png')) {
            blob = await embedXMPinPNG(img.file, kws, creator);
          } else if (saveMode === 'embed' && !canEmbed && !isRaw) {
            console.log('[SAVE] Converting to JPEG:', img.name);
            const jpegBlob = await convertToJPEG(img.file);
            const jpegFile = new File([jpegBlob], 'temp.jpg', { type: 'image/jpeg' });
            blob = await embedXMP(jpegFile, kws, creator);
            filename = filename.replace(/\.[^.]+$/, '.jpg');
          } else {
            blob = new Blob([generateXMP(kws, creator)], { type: 'application/rdf+xml' });
            filename = filename.replace(/\.[^.]+$/, '') + '.xmp';
          }

          const saveFile = async (data, name) => {
            if (outputDir) {
              const fh = await outputDir.getFileHandle(name, { create: true });
              const w = await fh.createWritable();
              await w.write(data);
              await w.close();
              console.log('[SAVE] Saved:', name);
            } else {
              const url = URL.createObjectURL(data);
              Object.assign(document.createElement('a'), { href: url, download: name }).click();
              URL.revokeObjectURL(url);
              console.log('[SAVE] Downloaded:', name);
            }
          };

          await saveFile(blob, filename);

          if (isRaw && outputDir) {
            await saveFile(img.file, img.name);
            console.log('[SAVE] Copied raw file:', img.name);
          }

          // Preserve pending keywords so they show when re-selecting done images
          const currentPending = pending.length > 0 ? pending : (img.pending || []);
          setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'done', keywords: kws, pending: currentPending } : i));
          setMemory(prev => ({ ...prev, [img.hash]: { exported: true, keywords: kws, pending: currentPending, creator, hidden: img.hidden } }));
          setModified(false);
          setIsEditing(false);

          // Auto-select next image if current becomes filtered out
          setTimeout(() => {
            const currentQueue = queueRef.current;
            const currentFiltered = currentQueue.filter(q => {
              if (q.hidden) return showHidden;
              if (q.status === 'done') return showDone;
              if (q.status === 'analyzing') return showAnalyzing;
              return showPending;
            });

            // If current image is no longer visible in filtered view, select next
            if (!currentFiltered.find(q => q.id === img.id)) {
              const currentIndex = currentFiltered.findIndex(q => q.id === selectedId);
              if (currentFiltered.length > 0) {
                const nextIndex = currentIndex >= 0 && currentIndex < currentFiltered.length ? currentIndex : 0;
                selectImage(currentFiltered[nextIndex].id, true); // Skip auto-save to prevent cascade
              } else {
                setSelectedId(null);
              }
            }
          }, 100);

          // Only sync to similar images if not explicitly skipped (to avoid cascades in multi-select)
          if (!skipSync) {
            await syncToSimilarAndSave(img, kws, des);
          }
        } catch (e) { console.error('[SAVE] Failed:', e); }
      }, [saveMode, outputDir, syncToSimilarAndSave, showHidden, showDone, showAnalyzing, showPending, selectedId]);

      // Analysis
      const analyzeImage = useCallback(async (img) => {
        if (!geminiKey || img.status === 'analyzing' || img.status === 'ready' || img.status === 'done') return;

        setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'analyzing' } : i));
        setDownloadedLarger(null);

        try {
          // Check IndexedDB cache first
          const cached = await getAnalysis(img.hash);
          if (cached) {
            console.log('[ANALYZE] Using cached analysis from IndexedDB for:', img.name);
            // Re-process cached keywords through the categorization logic
            const rawKws = cached.rawKeywords || [];
            const visionResult = cached.visionData || null;
            const designerInfo = cached.designer || null;

            // Process keywords (same logic as fresh analysis)
            const processedKws = rawKws.map(kw => {
              const path = smartCategorize(kw);
              return { ...kw, id: kw.id || Math.random().toString(36), path, rootCategory: path[0] };
            });
            const allKws = deduplicateKeywords(processedKws);
            const currentAccepted = acceptedRef.current;
            const currentBlocked = blockedRef.current;

            const auto = [], review = [];
            allKws.forEach(kw => {
              const key = kw.value.toLowerCase().trim();
              if (currentBlocked.has(key)) return;
              // Auto-accept if:
              // - In master taxonomy
              // - From embedded XMP metadata (user's own tags)
              // - Identified as brand, creator, or country of origin
              const inMaster = masterTerms.has(key);
              const isEmbedded = kw.source === 'xmp' || kw.source === 'existing';
              const isBrandOrCreator = ['brand', 'designer', 'artist', 'photographer', 'architect', 'creator'].includes(kw.type);
              const isCountry = kw.type === 'country' || (kw.path && kw.path.includes('Origin'));
              if (inMaster || isEmbedded || isBrandOrCreator || isCountry) {
                auto.push(kw);
              } else {
                review.push(kw);
              }
            });
            console.log(`[CACHE] ${auto.length} auto-accepted, ${review.length} for review`);

            // Auto-assign required category if not present
            const autoWithRequired = autoAssignRequiredCategory(auto);

            setQueue(q => q.map(i => i.id === img.id ? {
              ...i, status: 'ready', keywords: autoWithRequired, pending: review,
              designer: designerInfo, visionData: visionResult
            } : i));

            if (autoWithRequired.length) {
              setAccepted(prev => {
                const updated = [...prev];
                autoWithRequired.forEach(kw => {
                  if (!updated.some(a => a.value.toLowerCase() === kw.value.toLowerCase())) updated.push(kw);
                });
                return updated;
              });
            }
            return;
          }

          // Resize image for API if necessary (max 1600px) to reduce payload and improve response times
          const base64 = await resizeForAPI(img.file, 1600);

          const contextParts = [];
          if (img.filenameKeywords?.length) {
            contextParts.push(`Filename suggests: ${img.filenameKeywords.map(k => k.value).join(', ')}`);
          }
          if (img.existingKeywords?.length) {
            contextParts.push(`Existing tags: ${img.existingKeywords.map(k => k.value).join(', ')}`);
          }

          let rawKws = await analyzeWithGemini(geminiKey, base64, img.file.type, contextParts.join('. '));

          if (img.filenameKeywords) rawKws = [...img.filenameKeywords, ...rawKws];
          if (img.existingKeywords) rawKws = [...img.existingKeywords, ...rawKws];

          let visionResult = null;
          if (useVision && visionKey) {
            visionResult = await analyzeWithVision(visionKey, base64);
            if (visionResult?.keywords) {
              visionResult.keywords.forEach(vk => {
                if (!rawKws.some(k => k.value.toLowerCase() === vk.value.toLowerCase())) {
                  rawKws.push(vk);
                }
              });
            }

            // Use Gemini with grounding to extract creator info from web matches
            if (visionResult?.matchingImages?.length > 0) {
              const productContext = rawKws.filter(k => k.type === 'brand' || k.type === 'model').map(k => k.value).join(' ');
              const webCreators = await extractCreatorsFromWebMatches(geminiKey, visionResult.matchingImages, productContext);
              webCreators.forEach(wc => {
                if (!rawKws.some(k => k.value.toLowerCase() === wc.value.toLowerCase())) {
                  rawKws.push(wc);
                }
              });
            }

            if (autoDownloadLarger && visionResult?.matchingImages?.length > 0 && outputDir) {
              const fullMatch = visionResult.matchingImages.find(m => m.type === 'full');
              if (fullMatch) {
                const larger = await downloadLargerVersion(fullMatch.url, img.name);
                if (larger && larger.size > img.file.size) {
                  try {
                    const fh = await outputDir.getFileHandle(larger.filename, { create: true });
                    const w = await fh.createWritable();
                    await w.write(larger.blob);
                    await w.close();
                    setDownloadedLarger({ filename: larger.filename, size: larger.size });
                    console.log('[DOWNLOAD] Saved:', larger.filename);
                  } catch (e) {}
                }
              }
            }
          }

          let processedKws = [];
          const brandFound = [], modelFound = [];

          rawKws.forEach(k => {
            splitBrandModel(k.value).forEach(part => {
              // Always use smartCategorize for better accuracy, unless it's an explicitly known brand/model with good path
              let path = part.path;
              const needsRecategorization = part.path[0] === 'Custom' || part.type === 'keyword' ||
                (part.path.length === 1 && part.path[0] === 'Brand' && part.type !== 'brand');

              if (needsRecategorization) {
                path = findPath(part.value, part.type);
              }

              const kw = {
                id: `${img.id}-${Math.random().toString(36).slice(2)}`,
                value: part.value, confidence: k.confidence || 0.8,
                type: part.type, path: path, rootCategory: path[0],
                source: k.source || 'gemini'
              };
              if (part.type === 'brand') brandFound.push(kw);
              else if (part.type === 'model') modelFound.push(kw);
              processedKws.push(kw);
            });
          });

          processedKws = deduplicateKeywords(processedKws);

          let designerInfo = null;
          if (brandFound.length > 0 && modelFound.length > 0) {
            designerInfo = await findDesigner(geminiKey, `${brandFound[0].value} ${modelFound[0].value}`);
            if (designerInfo?.designers && designerInfo.designers.length > 0) {
              designerInfo.designers.forEach(name => {
                const designerPath = smartCategorize({ value: name, type: 'designer' });
                processedKws.push({
                  id: `designer-${Math.random().toString(36).slice(2)}`,
                  value: name, confidence: 0.8,
                  type: 'designer', path: designerPath, rootCategory: 'Creator'
                });
              });
            } else if (designerInfo?.designer) {
              const designerPath = smartCategorize({ value: designerInfo.designer, type: 'designer' });
              processedKws.push({
                id: `designer-${Math.random().toString(36).slice(2)}`,
                value: designerInfo.designer, confidence: 0.8,
                type: 'designer', path: designerPath, rootCategory: 'Creator'
              });
            }
          }

          const currentBlocked = blockedRef.current;
          const currentAccepted = acceptedRef.current;
          const auto = [], review = [];

          console.log(`[ANALYZE] Master taxonomy has ${masterTerms.size} terms, session has ${currentAccepted.size} accepted`);

          processedKws.forEach(kw => {
            const key = kw.value.toLowerCase().trim();
            if (currentBlocked.has(key)) return;
            // Auto-accept if:
            // - In master taxonomy
            // - From embedded XMP metadata (user's own tags)
            // - Identified as brand, creator, or country of origin
            const inMaster = masterTerms.has(key);
            const isEmbedded = kw.source === 'xmp' || kw.source === 'existing';
            const isBrandOrCreator = ['brand', 'designer', 'artist', 'photographer', 'architect', 'creator'].includes(kw.type);
            const isCountry = kw.type === 'country' || (kw.path && kw.path.includes('Origin'));
            if (inMaster || isEmbedded || isBrandOrCreator || isCountry) {
              auto.push(kw);
            } else {
              review.push(kw);
            }
          });

          console.log(`[ANALYZE] ${auto.length} auto-accepted, ${review.length} for review`);

          // Auto-assign required category if not present
          const autoWithRequired = autoAssignRequiredCategory(auto);

          // Cache the raw analysis results in IndexedDB
          await storeAnalysis(img.hash, {
            rawKeywords: processedKws,
            visionData: visionResult,
            designer: designerInfo
          });

          setQueue(q => q.map(i => i.id === img.id ? {
            ...i, status: 'ready', keywords: autoWithRequired, pending: review,
            designer: designerInfo, visionData: visionResult
          } : i));

          if (autoWithRequired.length) {
            setAccepted(prev => {
              const updated = [...prev];
              autoWithRequired.forEach(kw => {
                if (!updated.some(a => a.value.toLowerCase() === kw.value.toLowerCase())) updated.push(kw);
              });
              return updated;
            });
          }
        } catch (err) {
          console.error('[ANALYZE] Failed:', err.message || err);
          setQueue(q => q.map(i => i.id === img.id ? {
            ...i,
            status: 'error',
            errorMessage: err.message || 'Analysis failed'
          } : i));
        }
      }, [geminiKey, visionKey, useVision, autoDownloadLarger, outputDir, taxInfo, masterTerms, findPath]);

      // Keep ref updated for use in processFiles
      useEffect(() => { analyzeImageRef.current = analyzeImage; }, [analyzeImage]);
      useEffect(() => { saveImageRef.current = saveImage; }, [saveImage]);
      useEffect(() => { selectedImgRef.current = selectedImg; }, [selectedImg]);
      useEffect(() => { selectedIdsRef.current = selectedIds; }, [selectedIds]);
      useEffect(() => { keywordsRef.current = keywords; }, [keywords]);
      useEffect(() => { designerRef.current = designer; }, [designer]);

      const selectImage = useCallback(async (id, skipAutoSave = false) => {
        // Only auto-save if actually modified and not skipped
        if (!skipAutoSave && isEditing && modified && selectedImg && keywords.length > 0) {
          // Check if multi-select is active - save ALL selected images
          if (selectedIds.length > 1) {
            console.log('[NAV] Auto-saving', selectedIds.length, 'selected images before navigation');
            const selectedImages = queue.filter(q => selectedIds.includes(q.id));
            for (const img of selectedImages) {
              // Use the current keywords for all selected images
              await saveImage(img, keywords, designer, true); // skipSync=true for batch
            }
          } else {
            console.log('[NAV] Auto-saving before navigation:', selectedImg.name);
            await saveImage(selectedImg, keywords, designer);
          }
        }

        const img = queue.find(q => q.id === id);
        if (!img) return;

        setSelectedId(id);
        setDownloadedLarger(null);
        setIsEditing(false);

        // Only update keywords/pending if NOT in multi-select mode
        // Multi-select mode uses aggregated data from the useEffect below
        if (selectedIds.length <= 1) {
          if (img.status === 'ready' || img.status === 'done' || img.status === 'editing') {
            setKeywords(img.keywords || []);
            setPending(img.pending || []);
            setDesigner(img.designer || null);
            setVisionData(img.visionData || null);
            setIgnored([]);
            setModified(false);
          } else if (img.status === 'pending') {
            setKeywords([]); setPending([]); setDesigner(null); setVisionData(null); setIgnored([]); setModified(false);
            analyzeImage(img);
          } else {
            setKeywords([]); setPending([]); setDesigner(null); setVisionData(null); setIgnored([]); setModified(false);
          }
        }
      }, [queue, isEditing, modified, selectedImg, selectedIds, keywords, designer, analyzeImage, saveImage]);

      // Multi-select handler with Ctrl-click and Shift-click support
      const handleThumbnailClick = useCallback((id, event) => {
        const isCtrlClick = event?.ctrlKey || event?.metaKey; // Ctrl on Windows/Linux, Cmd on Mac
        const isShiftClick = event?.shiftKey;

        if (isCtrlClick) {
          // Ctrl-click: Toggle individual selection
          if (selectedIds.includes(id)) {
            // Deselect
            const newSelection = selectedIds.filter(sid => sid !== id);
            setSelectedIds(newSelection);
            if (newSelection.length === 0) {
              setSelectedId(null);
            } else if (selectedId === id) {
              // If we deselected the primary, make the first remaining selection primary
              setSelectedId(newSelection[0]);
            }
          } else {
            // Add to selection
            setSelectedIds(prev => [...prev, id]);
            setSelectedId(id); // This becomes the new primary selection
          }
          setLastClickedId(id);
        } else if (isShiftClick && lastClickedId) {
          // Shift-click: Select range between last clicked and current
          const currentIndex = filteredQueue.findIndex(q => q.id === id);
          const lastIndex = filteredQueue.findIndex(q => q.id === lastClickedId);

          if (currentIndex !== -1 && lastIndex !== -1) {
            const start = Math.min(currentIndex, lastIndex);
            const end = Math.max(currentIndex, lastIndex);
            const rangeIds = filteredQueue.slice(start, end + 1).map(q => q.id);

            // Merge with existing selection
            const newSelection = Array.from(new Set([...selectedIds, ...rangeIds]));
            setSelectedIds(newSelection);
            setSelectedId(id); // This becomes the new primary selection
          }
        } else {
          // Normal click: Single selection
          // Auto-save multi-select before changing selection
          if (selectedIds.length > 1 && isEditing && modified) {
            const selectedImages = queue.filter(q => selectedIds.includes(q.id));
            // Filter to only images that have keywords to save
            const imagesToSave = selectedImages.filter(img => img.keywords && img.keywords.length > 0);

            console.log('[MULTI-SELECT] Auto-save triggered:', {
              selectedCount: selectedIds.length,
              isEditing,
              modified,
              aggregatedKeywordsCount: keywords.length,
              imagesToSaveCount: imagesToSave.length,
              imagesWithKeywords: selectedImages.map(i => ({ name: i.name, kwCount: (i.keywords || []).length }))
            });

            if (imagesToSave.length > 0) {
              // Save each image with its OWN keywords (deduplicated), not the aggregated keywords
              Promise.all(imagesToSave.map(img => {
                const deduped = deduplicateKeywords(img.keywords);
                if (deduped.length !== img.keywords.length) {
                  console.log('[MULTI-SELECT] Deduped', img.name, 'from', img.keywords.length, 'to', deduped.length, 'keywords');
                  // Update the queue with deduplicated keywords
                  setQueue(q => q.map(item => item.id === img.id ? { ...item, keywords: deduped } : item));
                }
                console.log('[MULTI-SELECT] Saving', img.name, 'with', deduped.length, 'keywords');
                return saveImage(img, deduped, img.designer || designer, true);
              }))
                .then(() => {
                  console.log('[MULTI-SELECT] Auto-save complete - saved', imagesToSave.length, 'images');
                  setModified(false);
                  setIsEditing(false);
                })
                .catch(err => console.error('[MULTI-SELECT] Auto-save failed:', err));
            } else {
              console.log('[MULTI-SELECT] No images with keywords to save');
            }
          } else {
            console.log('[MULTI-SELECT] Auto-save skipped:', {
              selectedCount: selectedIds.length,
              isEditing,
              modified,
              keywordsCount: keywords.length
            });
          }

          setSelectedIds([id]);
          setLastClickedId(id);
          selectImage(id, true); // skipAutoSave=true since we already handled it above
        }
      }, [selectedIds, selectedId, lastClickedId, filteredQueue, selectImage, isEditing, modified, keywords, designer, queue, saveImage]);

      // Deduplicate keywords in an image (keep first occurrence of each value)
      const deduplicateKeywords = useCallback((keywords) => {
        const seen = new Set();
        return keywords.filter(kw => {
          const key = kw.value.toLowerCase();
          if (seen.has(key)) {
            console.warn('[DEDUP] Removing duplicate keyword:', kw.value);
            return false;
          }
          seen.add(key);
          return true;
        });
      }, []);

      // Aggregate keywords and pending tags when multi-select is active
      useEffect(() => {
        if (selectedIds.length > 1) {
          const selectedImages = queue.filter(q => selectedIds.includes(q.id));
          console.log('[MULTI-SELECT] Aggregating tags from', selectedImages.length, 'images');

          // Deduplicate keywords in all selected images first
          const deduplicatedImages = selectedImages.map(img => ({
            ...img,
            keywords: deduplicateKeywords(img.keywords || [])
          }));

          // Update queue with deduplicated keywords if any duplicates were found
          const hasDuplicates = selectedImages.some((img, idx) =>
            (img.keywords || []).length !== (deduplicatedImages[idx].keywords || []).length
          );
          if (hasDuplicates) {
            console.log('[MULTI-SELECT] Found duplicates - deduplicating queue');
            setQueue(q => q.map(img => {
              const deduped = deduplicatedImages.find(d => d.id === img.id);
              return deduped || img;
            }));
          }

          // Use deduplicated images for aggregation
          const imagesToAggregate = deduplicatedImages;

          // Build keyword occurrence map for accepted keywords
          const keywordOccurrences = new Map(); // Map<lowercaseValue, { keyword, count }>
          imagesToAggregate.forEach((img, idx) => {
            console.log(`[MULTI-SELECT] Image ${idx + 1}/${selectedImages.length} (${img.name}) has ${(img.keywords || []).length} keywords:`, (img.keywords || []).map(k => k.value).join(', '));
            (img.keywords || []).forEach(kw => {
              const key = kw.value.toLowerCase();
              if (keywordOccurrences.has(key)) {
                keywordOccurrences.get(key).count++;
              } else {
                keywordOccurrences.set(key, { keyword: kw, count: 1 });
              }
            });
          });

          console.log('[MULTI-SELECT] Keyword occurrences:', Array.from(keywordOccurrences.entries()).map(([key, {count}]) => `${key}: ${count}/${selectedImages.length}`));

          // Separate into "all" (in every image) and "some" (in some images)
          const allKeywords = [];
          const someKeywords = [];
          keywordOccurrences.forEach(({ keyword, count }) => {
            console.log(`[MULTI-SELECT] Keyword "${keyword.value}": count=${count}, totalImages=${selectedImages.length}, isAll=${count === selectedImages.length}`);
            if (count === selectedImages.length) {
              allKeywords.push(keyword);
            } else {
              someKeywords.push({ ...keyword, partialCount: count });
            }
          });

          // Build pending occurrence map
          const pendingOccurrences = new Map();
          imagesToAggregate.forEach((img, idx) => {
            console.log(`[MULTI-SELECT] Image ${idx + 1}/${imagesToAggregate.length} (${img.name}) has ${(img.pending || []).length} pending:`, (img.pending || []).map(k => k.value).join(', '));
            (img.pending || []).forEach(kw => {
              const key = kw.value.toLowerCase();
              if (pendingOccurrences.has(key)) {
                pendingOccurrences.get(key).count++;
              } else {
                pendingOccurrences.set(key, { keyword: kw, count: 1 });
              }
            });
          });

          console.log('[MULTI-SELECT] Pending occurrences:', Array.from(pendingOccurrences.entries()).map(([key, {count}]) => `${key}: ${count}/${imagesToAggregate.length}`));

          // Separate pending into "all" and "some"
          const allPending = [];
          const somePending = [];
          pendingOccurrences.forEach(({ keyword, count }) => {
            console.log(`[MULTI-SELECT] Pending "${keyword.value}": count=${count}, totalImages=${imagesToAggregate.length}, isAll=${count === imagesToAggregate.length}`);
            if (count === imagesToAggregate.length) {
              allPending.push(keyword);
            } else {
              somePending.push({ ...keyword, partialCount: count });
            }
          });

          console.log('[MULTI-SELECT] All:', allKeywords.length, 'Some:', someKeywords.length, 'Pending All:', allPending.length, 'Pending Some:', somePending.length);
          console.log('[MULTI-SELECT] Some keywords:', someKeywords.map(k => `${k.value} (${k.partialCount}/${selectedImages.length})`));
          console.log('[MULTI-SELECT] Some pending:', somePending.map(k => `${k.value} (${k.partialCount}/${selectedImages.length})`));

          // Verify partialCount is set correctly
          const combinedKeywords = [...allKeywords, ...someKeywords];
          const combinedPending = [...allPending, ...somePending];
          console.log('[MULTI-SELECT] Combined keywords with partialCount:', combinedKeywords.filter(k => k.partialCount).map(k => `${k.value} (${k.partialCount})`));
          console.log('[MULTI-SELECT] Combined pending with partialCount:', combinedPending.filter(k => k.partialCount).map(k => `${k.value} (${k.partialCount})`));

          // Store aggregated keywords - combine all and some for now, UI will display separately
          setKeywords(combinedKeywords);
          setPending(combinedPending);
          setModified(false);
          setIsEditing(false);
        }
      }, [selectedIds, queue, deduplicateKeywords]);

      const analyzeAllPending = () => {
        const pendingImgs = queue.filter(q => q.status === 'pending' && !q.hidden);
        console.log('[ANALYZE ALL] Found', pendingImgs.length, 'pending images, geminiKey:', !!geminiKey);
        pendingImgs.forEach(img => analyzeImage(img));
      };

      // When autoScan is toggled ON, start analyzing pending non-hidden images
      useEffect(() => {
        if (autoScan && geminiKey) {
          const pendingImgs = queue.filter(q => q.status === 'pending' && !q.hidden);
          if (pendingImgs.length > 0) {
            console.log('[AUTO-SCAN] Toggled ON - starting analysis of', pendingImgs.length, 'pending items');
            pendingImgs.forEach(img => analyzeImage(img));
          }
        }
      }, [autoScan]); // Only trigger when autoScan changes

      const reanalyzeSelected = async () => {
        if (!selectedImg || !geminiKey) return;
        // Clear IndexedDB cache for this image
        try {
          await deleteAnalysis(selectedImg.hash);
          console.log('[REANALYZE] Cleared cache for:', selectedImg.name);
        } catch (e) { console.error('[REANALYZE] Cache clear failed:', e); }
        // Reset to pending and re-analyze
        setQueue(q => q.map(i => i.id === selectedImg.id ? { ...i, status: 'pending', keywords: [], pending: [] } : i));
        setKeywords([]);
        setPending([]);
        analyzeImage({ ...selectedImg, status: 'pending' });
      };

      const [isSavingAll, setIsSavingAll] = useState(false);
      const saveAll = async () => {
        if (isSavingAll) return;
        // Only export images from the current view (Done view = only done images)
        const toSave = queue.filter(q => !q.hidden && q.status === 'done' && q.keywords?.length > 0);
        if (toSave.length === 0) return;

        // Always prompt for save directory
        try {
          const dir = await window.showDirectoryPicker({ mode: 'readwrite' });
          setOutputDir(dir);
          setOutputDirName(dir.name);
          localStorage.setItem('output_dir_name', dir.name);
          await saveOutputDirectory(dir);
          console.log('[SAVE ALL] Output directory selected:', dir.name);
        } catch (e) {
          console.log('[SAVE ALL] Directory selection cancelled');
          return;
        }

        setIsSavingAll(true);
        console.log(`[SAVE ALL] Saving ${toSave.length} images...`);

        for (const img of toSave) {
          try {
            // Skip sync when batch saving to avoid cascade
            await saveImage(img, img.keywords, img.designer, true);
          } catch (e) {
            console.error(`[SAVE ALL] Failed to save ${img.name}:`, e);
          }
        }

        setIsSavingAll(false);
        console.log('[SAVE ALL] Done!');
      };

      // Count only done images for export (since Export All button only shows in Done view)
      const readyToSaveCount = queue.filter(q => !q.hidden && q.status === 'done' && q.keywords?.length > 0).length;

      const hideImage = (id, e) => {
        e?.stopPropagation();

        // Find next image to select before hiding
        if (selectedIds.includes(id)) {
          const currentFiltered = queue.filter(q => {
            if (q.hidden) return showHidden;
            if (q.status === 'done') return showDone;
            if (q.status === 'analyzing') return showAnalyzing;
            return showPending;
          });

          const currentIndex = currentFiltered.findIndex(q => q.id === id);
          if (currentIndex !== -1 && currentFiltered.length > 1) {
            const nextIndex = currentIndex < currentFiltered.length - 1 ? currentIndex + 1 : currentIndex - 1;
            const nextImg = currentFiltered[nextIndex];
            if (nextImg && nextImg.id !== id) {
              setSelectedIds([nextImg.id]);
              setLastClickedId(nextImg.id);
              selectImage(nextImg.id, true);
            }
          } else {
            setSelectedIds([]);
            setSelectedId(null);
          }
        }

        setQueue(q => q.map(i => {
          if (i.id === id) {
            setMemory(prev => ({ ...prev, [i.hash]: { ...prev[i.hash], hidden: true } }));
            return { ...i, hidden: true };
          }
          return i;
        }));
      };

      const unhideImage = (id, e) => {
        e?.stopPropagation();
        setQueue(q => q.map(i => {
          if (i.id === id) {
            setMemory(prev => ({ ...prev, [i.hash]: { ...prev[i.hash], hidden: false } }));
            return { ...i, hidden: false };
          }
          return i;
        }));
      };

      const accept = async (id) => {
        const kw = pending.find(k => k.id === id);
        if (kw) {
          console.log(`[ACCEPT] Accepting keyword: "${kw.value}"`);
          setPending(p => p.filter(k => k.id !== id));

          // If it's a partial recommendation in multi-select mode, remove partialCount to apply to all
          const fullKw = (isMultiSelect && kw.partialCount) ? { ...kw } : kw;
          if (isMultiSelect && kw.partialCount) {
            delete fullKw.partialCount;
            console.log(`[ACCEPT] Removed partialCount - will apply to all ${selectedImgs.length} images`);
          }

          // Accept immediately with current categorization (non-blocking)
          const newKeywords = [...keywords, fullKw];
          setKeywords(newKeywords);
          setAccepted(a => a.some(x => x.value.toLowerCase() === fullKw.value.toLowerCase()) ? a : [...a, fullKw]);
          setTaxonomy(t => addToTaxonomy(t, fullKw));
          setModified(true);
          setIsEditing(true);

          // Apply to all selected images (multi-select support) - optimized for performance
          const targetImgs = isMultiSelect ? selectedImgs : [selectedImg];
          console.log(`[ACCEPT] Applying to ${targetImgs.length} selected image(s)`);

          // Build a Set of target IDs for O(1) lookups
          const targetIds = new Set(targetImgs.filter(t => t).map(t => t.id));

          // Get similar images once
          const similarIds = selectedImg ? new Set(getSimilarImages(selectedImg).map(s => s.id)) : new Set();

          setQueue(q => {
            // Only update if we have targets
            if (targetIds.size === 0 && similarIds.size === 0) return q;

            return q.map(img => {
              const isTarget = targetIds.has(img.id);
              const isSimilar = similarIds.has(img.id);

              if (isTarget) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                if (!existingVals.has(fullKw.value.toLowerCase())) {
                  const syncedKw = img.id === selectedImg?.id ? fullKw : { ...fullKw, id: `sync-${Math.random().toString(36).slice(2)}` };
                  return {
                    ...img,
                    keywords: [...(img.keywords || []), syncedKw],
                    pending: img.id === selectedImg?.id ? pending.filter(k => k.id !== id) : img.pending,
                    status: img.status === 'pending' ? 'ready' : (img.id === selectedImg?.id ? 'editing' : img.status)
                  };
                } else if (img.id === selectedImg?.id) {
                  return { ...img, pending: pending.filter(k => k.id !== id) };
                }
              } else if (isSimilar) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                if (!existingVals.has(fullKw.value.toLowerCase())) {
                  const syncedKw = { ...fullKw, id: `sync-${Math.random().toString(36).slice(2)}` };
                  return { ...img, keywords: [...(img.keywords || []), syncedKw], status: img.status === 'pending' ? 'ready' : img.status };
                }
              }
              return img;
            });
          });

          // Background categorization for Custom keywords (non-blocking)
          if (fullKw.path?.[0] === 'Custom' && geminiKey) {
            setTimeout(async () => {
              try {
                const results = await categorizeKeywords(geminiKey, [fullKw.value]);
                if (results.length > 0 && results[0].path) {
                  const categorizedPath = results[0].path;
                  const categorizedType = results[0].type || fullKw.type;
                  console.log(`[ACCEPT] Background categorized "${fullKw.value}" as:`, categorizedPath);

                  // Update the keyword with better categorization
                  setKeywords(current => current.map(k =>
                    k.id === fullKw.id ? { ...k, path: categorizedPath, rootCategory: categorizedPath[0], type: categorizedType } : k
                  ));
                  setAccepted(current => current.map(k =>
                    k.id === fullKw.id ? { ...k, path: categorizedPath, rootCategory: categorizedPath[0], type: categorizedType } : k
                  ));
                }
              } catch (e) {
                console.error('[ACCEPT] Background categorization failed:', e);
              }
            }, 100);
          }
        }
      };

      const block = (id) => {
        const kw = pending.find(k => k.id === id) || ignored.find(k => k.id === id);
        if (kw) {
          setPending(p => p.filter(k => k.id !== id));
          setIgnored(i => i.filter(k => k.id !== id));
          setBlocked(b => [...b, kw]);
          setModified(true);
          setIsEditing(true);
        }
      };

      const ignore = (id) => {
        const kw = pending.find(k => k.id === id);
        if (kw) {
          setPending(p => p.filter(k => k.id !== id));
          setIgnored(i => [...i, kw]);
          setModified(true);
          setIsEditing(true);
        }
      };

      const acceptIgnored = (id) => {
        const kw = ignored.find(k => k.id === id);
        if (kw) {
          setIgnored(i => i.filter(k => k.id !== id));
          const newKeywords = [...keywords, kw];
          setKeywords(newKeywords);
          setAccepted(a => a.some(x => x.value.toLowerCase() === kw.value.toLowerCase()) ? a : [...a, kw]);
          setModified(true);
          setIsEditing(true);

          if (selectedImg) {
            const similar = getSimilarImages(selectedImg);

            // Update both the selected image AND similar images in the queue
            setQueue(q => q.map(img => {
              // Update the current selected image
              if (img.id === selectedImg.id) {
                return { ...img, keywords: newKeywords };
              }
              // Update similar images
              if (similar.some(s => s.id === img.id)) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                if (!existingVals.has(kw.value.toLowerCase())) {
                  const syncedKw = { ...kw, id: `sync-${Math.random().toString(36).slice(2)}` };
                  return { ...img, keywords: [...(img.keywords || []), syncedKw], status: img.status === 'pending' ? 'ready' : img.status };
                }
              }
              return img;
            }));
          }
        }
      };

      const acceptAll = () => {
        const newKeywords = [...keywords, ...pending];

        // Batch update accepted keywords once
        setAccepted(a => {
          const existing = new Set(a.map(x => x.value.toLowerCase()));
          const toAdd = pending.filter(kw => !existing.has(kw.value.toLowerCase()));
          return [...a, ...toAdd];
        });

        setKeywords(newKeywords);
        setPending([]);
        setModified(true);
        setIsEditing(true);

        // Apply to all selected images (multi-select support) - optimized for performance
        const targetImgs = isMultiSelect ? selectedImgs : [selectedImg];
        console.log(`[ACCEPT ALL] Applying to ${targetImgs.length} selected image(s)`);

        // Build a Set of target IDs for O(1) lookups
        const targetIds = new Set(targetImgs.filter(t => t).map(t => t.id));

        // Get similar images once
        const similarIds = selectedImg ? new Set(getSimilarImages(selectedImg).map(s => s.id)) : new Set();

        setQueue(q => {
          // Only update if we have targets
          if (targetIds.size === 0 && similarIds.size === 0) return q;

          return q.map(img => {
            const isTarget = targetIds.has(img.id);
            const isSimilar = similarIds.has(img.id);

            if (isTarget) {
              const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
              const newKws = pending
                .filter(kw => !existingVals.has(kw.value.toLowerCase()))
                .map(kw => img.id === selectedImg?.id ? kw : { ...kw, id: `sync-${Math.random().toString(36).slice(2)}` });
              if (newKws.length > 0 || img.id === selectedImg?.id) {
                return {
                  ...img,
                  keywords: img.id === selectedImg?.id ? newKeywords : [...(img.keywords || []), ...newKws],
                  pending: img.id === selectedImg?.id ? [] : img.pending,
                  status: img.status === 'pending' ? 'ready' : (img.id === selectedImg?.id ? 'editing' : img.status)
                };
              }
            } else if (isSimilar) {
              const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
              const newKws = pending
                .filter(kw => !existingVals.has(kw.value.toLowerCase()))
                .map(kw => ({ ...kw, id: `sync-${Math.random().toString(36).slice(2)}` }));
              if (newKws.length > 0) {
                return { ...img, keywords: [...(img.keywords || []), ...newKws], status: img.status === 'pending' ? 'ready' : img.status };
              }
            }
            return img;
          });
        });
      };

      const removeKw = (id) => {
        // Find the keyword being removed
        const kw = keywords.find(k => k.id === id);
        if (kw) {
          // Move it back to pending (recommendations) instead of deleting
          // Check if it already exists in pending to avoid duplicates
          setPending(p => {
            const exists = p.some(existing => existing.value.toLowerCase() === kw.value.toLowerCase());
            return exists ? p : [...p, kw];
          });
        }
        setKeywords(c => c.filter(k => k.id !== id));
        setModified(true);
        setIsEditing(true);
      };

      // Add a partial keyword to all selected images
      const addToAll = (kw) => {
        console.log(`[ADD-TO-ALL] Adding "${kw.value}" to all ${selectedImgs.length} selected images`);
        console.log('[ADD-TO-ALL] Keyword:', kw);

        // Remove partialCount to make it a full keyword
        const fullKw = { ...kw };
        delete fullKw.partialCount;

        // Update local keywords state
        setKeywords(current => current.map(k =>
          k.id === kw.id ? fullKw : k
        ));

        // Apply to all selected images in the queue
        const targetIds = new Set(selectedImgs.filter(t => t).map(t => t.id));
        console.log('[ADD-TO-ALL] Target IDs:', Array.from(targetIds));

        let addedCount = 0;
        let skippedCount = 0;

        setQueue(q => q.map(img => {
          if (!targetIds.has(img.id)) return img;

          // Check if keyword already exists
          const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
          if (existingVals.has(kw.value.toLowerCase())) {
            console.log(`[ADD-TO-ALL] Skipping ${img.name} - already has "${kw.value}"`);
            skippedCount++;
            return img;
          }

          // Add keyword with unique ID
          const syncedKw = { ...fullKw, id: `sync-${Math.random().toString(36).slice(2)}` };
          console.log(`[ADD-TO-ALL] Adding to ${img.name} - keyword count: ${(img.keywords || []).length} -> ${(img.keywords || []).length + 1}`);
          addedCount++;
          return {
            ...img,
            keywords: [...(img.keywords || []), syncedKw],
            status: img.status === 'pending' ? 'ready' : img.status
          };
        }));

        console.log(`[ADD-TO-ALL] Complete - added to ${addedCount} images, skipped ${skippedCount} images`);

        setModified(true);
        setIsEditing(true);
      };

      // Remove a keyword from all selected images
      const removeFromAll = (kw) => {
        console.log(`[REMOVE-FROM-ALL] Removing "${kw.value}" from all ${selectedImgs.length} selected images`);
        console.log('[REMOVE-FROM-ALL] Keyword:', kw);

        // Remove from local keywords state
        setKeywords(current => current.filter(k => k.id !== kw.id));

        // Move it back to pending (recommendations) instead of deleting
        setPending(p => {
          const exists = p.some(existing => existing.value.toLowerCase() === kw.value.toLowerCase());
          return exists ? p : [...p, kw];
        });

        // Remove from all selected images in the queue
        const targetIds = new Set(selectedImgs.filter(t => t).map(t => t.id));
        console.log('[REMOVE-FROM-ALL] Target IDs:', Array.from(targetIds));

        let removedCount = 0;
        let skippedCount = 0;

        setQueue(q => q.map(img => {
          if (!targetIds.has(img.id)) return img;

          // Check if keyword exists in this image
          const hasKeyword = (img.keywords || []).some(k => k.value.toLowerCase() === kw.value.toLowerCase());
          if (!hasKeyword) {
            console.log(`[REMOVE-FROM-ALL] Skipping ${img.name} - doesn't have "${kw.value}"`);
            skippedCount++;
            return img;
          }

          // Remove keyword
          const updatedKeywords = (img.keywords || []).filter(k => k.value.toLowerCase() !== kw.value.toLowerCase());
          console.log(`[REMOVE-FROM-ALL] Removing from ${img.name} - keyword count: ${(img.keywords || []).length} -> ${updatedKeywords.length}`);
          removedCount++;
          return {
            ...img,
            keywords: updatedKeywords,
            status: img.status === 'done' ? 'editing' : img.status
          };
        }));

        console.log(`[REMOVE-FROM-ALL] Complete - removed from ${removedCount} images, skipped ${skippedCount} images`);

        setModified(true);
        setIsEditing(true);
      };

      const removeAllPartial = () => {
        const partialKeywords = keywords.filter(k => k.partialCount);
        console.log(`[REMOVE-ALL-PARTIAL] Removing ${partialKeywords.length} partial keywords from accepted and moving to pending`);

        // Remove all partial keywords from the keywords list
        setKeywords(current => current.filter(k => !k.partialCount));

        // Add them to pending (as recommendations)
        const newPending = partialKeywords.map(k => {
          const kw = { ...k };
          delete kw.partialCount; // Remove the partial count
          return kw;
        });
        setPending(current => [...current, ...newPending]);

        // Remove from all selected images in the queue
        const targetIds = new Set(selectedImgs.filter(t => t).map(t => t.id));
        const kwValues = new Set(partialKeywords.map(k => k.value.toLowerCase()));

        setQueue(q => q.map(img => {
          if (!targetIds.has(img.id)) return img;

          // Filter out the partial keywords
          const filteredKeywords = (img.keywords || []).filter(k => !kwValues.has(k.value.toLowerCase()));

          // Add to pending for this image
          const imgPending = img.pending || [];
          const existingPendingVals = new Set(imgPending.map(p => p.value.toLowerCase()));
          const newImgPending = [...imgPending, ...newPending.filter(k => !existingPendingVals.has(k.value.toLowerCase()))];

          return {
            ...img,
            keywords: filteredKeywords,
            pending: newImgPending
          };
        }));

        setModified(true);
        setIsEditing(true);
      };

      const deleteFromTaxonomy = (id) => {
        setAccepted(a => a.filter(k => k.id !== id));
      };

      const deleteFromMasterTaxonomy = (path, value) => {
        setTaxonomy(prevTax => {
          const newTax = JSON.parse(JSON.stringify(prevTax));
          let current = newTax;

          for (let i = 0; i < path.length - 1; i++) {
            if (!current[path[i]]) return prevTax;
            current = current[path[i]];
          }

          const leafKey = path[path.length - 1];
          if (Array.isArray(current[leafKey])) {
            current[leafKey] = current[leafKey].filter(v => v.toLowerCase() !== value.toLowerCase());
          } else if (current[leafKey]?._items) {
            current[leafKey]._items = current[leafKey]._items.filter(v => v.toLowerCase() !== value.toLowerCase());
          }
          return newTax;
        });
      };

      const addCustom = async () => {
        const val = customInput.trim();
        if (!val) return;
        const newKws = [];
        const uncategorizedKws = [];

        // Build all keywords first (non-blocking)
        splitBrandModel(val).forEach(part => {
          const path = part.path[0] === 'Custom' ? findPath(part.value, part.type) : part.path;
          const kw = { id: `custom-${Date.now()}-${Math.random().toString(36).slice(2)}`, value: part.value, confidence: 1, type: part.type, path, rootCategory: path[0] };
          newKws.push(kw);

          // Track uncategorized keywords for background research
          if (path[0] === 'Custom' && geminiKey) {
            uncategorizedKws.push(kw);
          }
        });

        // Batch update state once (much faster than multiple updates)
        setKeywords(c => [...c, ...newKws]);
        setAccepted(a => {
          const existing = new Set(a.map(x => x.value.toLowerCase()));
          const toAdd = newKws.filter(kw => !existing.has(kw.value.toLowerCase()));
          return [...a, ...toAdd];
        });
        setTaxonomy(t => {
          let updatedTax = t;
          newKws.forEach(kw => {
            updatedTax = addToTaxonomy(updatedTax, kw);
          });
          return updatedTax;
        });

        setCustomInput('');
        setModified(true);
        setIsEditing(true);

        // Apply to all selected images (multi-select support) - optimized for performance
        if (newKws.length > 0) {
          const targetImgs = isMultiSelect ? selectedImgs : [selectedImg];
          console.log(`[ADD CUSTOM] Applying to ${targetImgs.length} selected image(s)`);

          // Build a Set of target IDs for O(1) lookups
          const targetIds = new Set(targetImgs.filter(t => t).map(t => t.id));

          // Get similar images once
          const similarIds = selectedImg ? new Set(getSimilarImages(selectedImg).map(s => s.id)) : new Set();

          setQueue(q => {
            // Only update if we have targets
            if (targetIds.size === 0 && similarIds.size === 0) return q;

            return q.map(img => {
              const isTarget = targetIds.has(img.id);
              const isSimilar = similarIds.has(img.id);
              const isPrimary = img.id === selectedImg?.id;

              if (isTarget || isSimilar) {
                const existingVals = new Set((img.keywords || []).map(k => k.value.toLowerCase()));
                const syncKws = newKws
                  .filter(kw => !existingVals.has(kw.value.toLowerCase()))
                  .map(kw => isPrimary ? kw : { ...kw, id: `sync-${Math.random().toString(36).slice(2)}` });

                if (syncKws.length > 0) {
                  return { ...img, keywords: [...(img.keywords || []), ...syncKws], status: img.status === 'pending' ? 'ready' : img.status };
                }
              }
              return img;
            });
          });
        }

        // Background research for uncategorized keywords
        if (uncategorizedKws.length > 0 && geminiKey) {
          setTimeout(async () => {
            for (const kw of uncategorizedKws) {
              const result = await researchKeyword(geminiKey, kw.value);
              if (result && result.path && result.path.length > 0 && result.path[0] !== 'Custom') {
                console.log(`[AUTO-CATEGORIZE] ${kw.value} -> ${result.path.join(' > ')}`);
                // Update the keyword's path in taxonomy
                setTaxonomy(prevTax => {
                  const newTax = JSON.parse(JSON.stringify(prevTax));
                  // Remove from Custom
                  if (newTax.Custom) {
                    if (Array.isArray(newTax.Custom)) {
                      newTax.Custom = newTax.Custom.filter(v => v.toLowerCase() !== kw.value.toLowerCase());
                    } else if (newTax.Custom._items) {
                      newTax.Custom._items = newTax.Custom._items.filter(v => v.toLowerCase() !== kw.value.toLowerCase());
                    }
                  }
                  // Add to new path
                  let current = newTax;
                  for (let i = 0; i < result.path.length; i++) {
                    const segment = result.path[i];
                    if (!current[segment]) current[segment] = i === result.path.length - 1 ? [] : {};
                    if (i === result.path.length - 1) {
                      if (Array.isArray(current[segment])) {
                        if (!current[segment].includes(kw.value)) current[segment].push(kw.value);
                      } else {
                        if (!current[segment]._items) current[segment]._items = [];
                        if (!current[segment]._items.includes(kw.value)) current[segment]._items.push(kw.value);
                      }
                    } else {
                      current = current[segment];
                    }
                  }
                  localStorage.setItem(TAXONOMY_KEY, JSON.stringify(newTax));
                  return newTax;
                });
                // Update keyword in current keywords list
                setKeywords(prev => prev.map(k =>
                  k.value.toLowerCase() === kw.value.toLowerCase()
                    ? { ...k, path: result.path, rootCategory: result.path[0], type: result.type || k.type }
                    : k
                ));
              }
            }
          }, 100);
        }
      };

      useEffect(() => {
        // Skip this in multi-select mode - the multi-select aggregation useEffect handles it
        if (selectedIds.length > 1) return;

        if (selectedImg && (selectedImg.status === 'ready' || selectedImg.status === 'done') && !modified && !isEditing) {
          setKeywords(selectedImg.keywords || []);
          setPending(selectedImg.pending || []);
          setDesigner(selectedImg.designer || null);
          setVisionData(selectedImg.visionData || null);
        }
      }, [selectedImg?.id, selectedImg?.status, selectedIds.length]);

      const getCustomKeywords = useCallback(() => {
        const customs = [];
        const collectCustom = (obj, path = []) => {
          for (const [key, value] of Object.entries(obj)) {
            if (key === '_items') continue;
            const currentPath = [...path, key];
            if (key === 'Custom' && Array.isArray(value)) {
              customs.push(...value);
            } else if (key === 'Custom' && value?._items) {
              customs.push(...value._items);
            } else if (typeof value === 'object' && value !== null) {
              collectCustom(value, currentPath);
            }
          }
        };
        collectCustom(taxonomy);
        return customs;
      }, [taxonomy]);

      const runCategorization = async () => {
        if (!geminiKey || isCategorizing) return;

        const customKws = getCustomKeywords();
        if (customKws.length === 0) {
          console.log('[CATEGORIZE] No custom keywords to categorize');
          return;
        }

        setIsCategorizing(true);
        console.log(`[CATEGORIZE] Categorizing ${customKws.length} custom keywords...`);

        try {
          const batchSize = 20;
          for (let i = 0; i < customKws.length; i += batchSize) {
            const batch = customKws.slice(i, i + batchSize);
            const results = await categorizeKeywords(geminiKey, batch);

            if (results.length > 0) {
              setTaxonomy(prevTax => {
                let newTax = JSON.parse(JSON.stringify(prevTax));

                results.forEach(result => {
                  if (!result.path || result.path.length === 0 || result.path[0] === 'Custom') return;

                  if (Array.isArray(newTax.Custom)) {
                    newTax.Custom = newTax.Custom.filter(k => k.toLowerCase() !== result.keyword.toLowerCase());
                  } else if (newTax.Custom?._items) {
                    newTax.Custom._items = newTax.Custom._items.filter(k => k.toLowerCase() !== result.keyword.toLowerCase());
                  }

                  let current = newTax;
                  for (let j = 0; j < result.path.length; j++) {
                    const key = result.path[j];
                    if (j === result.path.length - 1) {
                      if (Array.isArray(current[key])) {
                        if (!current[key].some(k => k.toLowerCase() === result.keyword.toLowerCase())) {
                          current[key].push(result.keyword);
                        }
                      } else if (typeof current[key] === 'object' && current[key] !== null) {
                        if (!current[key]._items) current[key]._items = [];
                        if (!current[key]._items.some(k => k.toLowerCase() === result.keyword.toLowerCase())) {
                          current[key]._items.push(result.keyword);
                        }
                      } else if (current[key] === undefined) {
                        current[key] = [result.keyword];
                      }
                    } else {
                      if (current[key] === undefined) {
                        current[key] = {};
                      } else if (Array.isArray(current[key])) {
                        current[key] = { _items: current[key] };
                      }
                      current = current[key];
                    }
                  }

                  console.log(`[CATEGORIZE] Moved "${result.keyword}" to ${result.path.join(' > ')}`);
                });

                return newTax;
              });
            }
          }
          console.log('[CATEGORIZE] Done!');
        } catch (e) {
          console.error('[CATEGORIZE] Error:', e);
        } finally {
          setIsCategorizing(false);
        }
      };

      const customCount = getCustomKeywords().length;

      // Auto-run categorization when custom keywords accumulate
      const autoCategorizeTimeoutRef = useRef(null);
      useEffect(() => {
        if (customCount > 0 && geminiKey && !isCategorizing) {
          // Clear any pending timeout
          if (autoCategorizeTimeoutRef.current) {
            clearTimeout(autoCategorizeTimeoutRef.current);
          }
          // Schedule auto-categorization after 3 seconds of inactivity
          autoCategorizeTimeoutRef.current = setTimeout(() => {
            console.log('[AUTO-CATEGORIZE] Triggering auto-categorization for', customCount, 'custom keywords');
            runCategorization();
          }, 3000);
        }
        return () => {
          if (autoCategorizeTimeoutRef.current) {
            clearTimeout(autoCategorizeTimeoutRef.current);
          }
        };
      }, [customCount, geminiKey, isCategorizing]);

      // Auto-consolidation disabled - was causing false matches
      const [isConsolidating, setIsConsolidating] = useState(false);

      const tree = buildTree(accepted);
      const getColor = (r) => ROOT_COLORS[r] || s.text;

      const totalCount = queue.length;
      const hiddenCount = queue.filter(q => q.hidden).length;
      const doneCount = queue.filter(q => q.status === 'done').length;
      const readyCount = queue.filter(q => (q.status === 'ready' || q.status === 'editing') && !q.hidden).length;
      const analyzingCount = queue.filter(q => q.status === 'analyzing').length + (analysisBatchRef.current?.pending || 0);
      const pendingCount = queue.filter(q => q.status === 'pending' && !q.hidden).length;
      const editingCount = queue.filter(q => q.status === 'editing' && !q.hidden).length;
      const errorCount = queue.filter(q => q.status === 'error').length;
      const similarCount = selectedImg ? getSimilarImages(selectedImg).length : 0;

      // Retry failed analyses
      const retryFailed = useCallback(() => {
        const failed = queue.filter(q => q.status === 'error');
        console.log('[RETRY] Retrying', failed.length, 'failed analyses');
        failed.forEach(img => {
          setQueue(q => q.map(i => i.id === img.id ? { ...i, status: 'pending' } : i));
          setTimeout(() => analyzeImage({ ...img, status: 'pending' }), 100);
        });
      }, [queue, analyzeImage]);

      const thumbSizes = [110, 200, 480];
      const currentThumbSize = thumbSizes[thumbSize];

      // Unified style system
      const s = {
        // Color Standards
        bgDark: '#1D1D1D',      // Dark grey (keywording section, toggle bg, strokes)
        bgMid: '#2D2D2D',       // Mid grey (panels, active buttons)
        text: '#A4A4A4',        // General text and keywords
        textMuted: '#777777',   // Inactive buttons, categories
        blue: '#4147FF',        // Save buttons, Ready tags
        yellow: '#D97350',      // Yellow accent
        green: '#68B757',       // Done checkmarks
        // Legacy compatibility (point to new colors)
        bg: '#1D1D1D',
        bgMedium: '#2D2D2D',
        panel: '#2D2D2D',
        border: '#1D1D1D',      // All strokes/borders (2px)
        muted: '#777777',       // Alias for textMuted
        bright: '#A4A4A4',      // Alias for text
        fontSize: 14,
        fontWeight: 500,
        lineHeight: '32px',
        radius: 4,
        radiusSm: 4,
        radiusLg: 4
      };

      return (
        <div ref={containerRef} tabIndex={0} style={{ display: 'flex', flexDirection: 'column', height: '100vh', width: '100vw', fontSize: s.fontSize, lineHeight: s.lineHeight, background: s.bgMedium, color: s.text, outline: 'none' }}>
          <input ref={fileRef} type="file" accept="image/*" multiple onChange={handleFileInput} style={{ display: 'none' }} />
          <input ref={folderRef} type="file" accept="image/*" multiple webkitdirectory="" onChange={handleFileInput} style={{ display: 'none' }} />

          {/* TOOLBAR */}
          <div style={{ height: 56, background: s.panel, display: 'flex', alignItems: 'center', padding: '0 16px', gap: 12, borderBottom: `1px solid ${s.border}`, flexShrink: 0 }}>
            {/* Left side - Import buttons */}
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <span style={{ color: s.textMuted, fontSize: s.fontSize, fontWeight: s.fontWeight }}>Import:</span>
              <button onClick={() => folderRef.current?.click()} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '8px 14px', background: 'transparent', color: s.text, border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                <Icon name="folder_open" size={18} /> Folder
              </button>
              <button onClick={() => fileRef.current?.click()} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '8px 14px', background: 'transparent', color: s.text, border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                <Icon name="add_photo_alternate" size={18} /> Files
              </button>
            </div>

            {/* Action buttons */}
            <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
              {showPending && readyCount > 0 && (
                <button onClick={() => {
                  if (confirm(`Mark all ${readyCount} ready images as done?`)) {
                    // Update queue status
                    setQueue(q => q.map(i => (i.status === 'ready' || i.status === 'editing') ? { ...i, status: 'done' } : i));

                    // Update memory to persist the "done" status
                    setMemory(prev => {
                      const updated = { ...prev };
                      queue.forEach(img => {
                        if (img.status === 'ready' || img.status === 'editing') {
                          updated[img.hash] = {
                            ...updated[img.hash],
                            exported: true,
                            keywords: img.keywords || [],
                            pending: img.pending || [],
                            creator: img.designer?.designer || null,
                            hidden: img.hidden || false
                          };
                        }
                      });
                      return updated;
                    });
                  }
                }} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 16px', background: '#4147FF', color: '#FFFFFF', border: 'none', borderRadius: 16, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                  Mark all as Done
                </button>
              )}
              {showDone && readyToSaveCount > 0 && (
                <button onClick={saveAll} disabled={isSavingAll} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 16px', background: '#68B757', color: '#000000', border: 'none', borderRadius: 16, cursor: isSavingAll ? 'default' : 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                  {isSavingAll ? 'Exporting...' : `Export All (${readyToSaveCount})`}
                </button>
              )}
              {showDone && (
                <div style={{ display: 'inline-flex', background: s.bgDark, borderRadius: 20, padding: 4 }}>
                  <button onClick={async () => {
                    if (!continuousSaveEnabled && !outputDir) {
                      try {
                        const dir = await window.showDirectoryPicker({ mode: 'readwrite' });
                        setOutputDir(dir);
                        setOutputDirName(dir.name);
                        localStorage.setItem('output_dir_name', dir.name);
                        await saveOutputDirectory(dir);
                        setContinuousSaveEnabled(true);
                        console.log('[CONTINUOUS SAVE] Output directory selected:', dir.name);
                      } catch (e) {
                        console.log('[CONTINUOUS SAVE] Directory selection cancelled');
                        return;
                      }
                    } else {
                      setContinuousSaveEnabled(!continuousSaveEnabled);
                    }
                  }}
                    className={continuousSaveEnabled ? '' : 'no-hover'}
                    style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 16px', background: continuousSaveEnabled ? s.bgMid : 'transparent', color: continuousSaveEnabled ? s.text : s.textMuted, border: 'none', borderRadius: 16, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                    Continuous Save
                  </button>
                </div>
              )}
            </div>

            {/* Right side - Logo, Status, Settings */}
            <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: 10 }}>
              <span style={{ color: s.muted, fontSize: s.fontSize }}>
                {filteredQueue.length}/{totalCount}
                {analyzingCount > 0 && <span style={{ color: s.text }}> · {analyzingCount} analyzing</span>}
                {readyCount > 0 && <span style={{ color: s.text }}> · {readyCount} ready</span>}
                {(() => {
                  const mem = getMemoryUsage();
                  if (mem && parseInt(mem.percent) > 80) {
                    return <span style={{ color: s.text }}> · Mem: {mem.percent}%</span>;
                  }
                  return null;
                })()}
              </span>
              <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                <div style={{ width: 20, height: 20, background: `linear-gradient(135deg, ${s.text}, ${s.textMuted})`, borderRadius: 5 }} />
                <span style={{ color: s.text, fontWeight: s.fontWeight, fontSize: s.fontSize }}>MegaTagger</span>
              </div>
              <button onClick={() => setShowSettings(true)} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: 40, height: 40, background: 'transparent', color: s.muted, border: 'none', borderRadius: s.radius, cursor: 'pointer' }}>
                <Icon name="tune" size={22} />
              </button>
            </div>
          </div>

          {/* MAIN */}
          <div ref={mainPanelRef} style={{ flex: 1, display: 'flex', overflow: 'hidden', width: '100%', cursor: isDraggingDivider ? 'col-resize' : 'default' }}>

            {/* LEFT - GRID */}
            <div style={{ width: `${gridWidth}%`, minWidth: 250, background: s.bgMedium, display: 'flex', flexDirection: 'column', transition: isDraggingDivider ? 'none' : 'width 0.2s ease-out', borderRight: `2px solid ${s.border}` }}>
              <div style={{ padding: '10px 12px', borderBottom: `2px solid ${s.border}`, display: 'flex', gap: 4, alignItems: 'center', flexWrap: 'wrap' }}>
                <div style={{ display: 'inline-flex', background: s.bgDark, borderRadius: 20, padding: 4, gap: 4 }}>
                  <button onClick={() => { setShowPending(true); setShowAnalyzing(false); setShowDone(false); setShowHidden(false); }}
                    className={showPending ? 'no-hover' : ''}
                    onMouseEnter={(e) => { if (!showPending) e.currentTarget.style.color = s.text; }}
                    onMouseLeave={(e) => { if (!showPending) e.currentTarget.style.color = s.textMuted; }}
                    style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 16px', background: showPending ? '#4147FF' : 'transparent', color: showPending ? '#FFFFFF' : s.textMuted, border: 'none', borderRadius: 16, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                    Ready ({readyCount})
                  </button>
                  {analyzingCount > 0 && (
                    <button onClick={() => { setShowPending(false); setShowAnalyzing(true); setShowDone(false); setShowHidden(false); }}
                      className={showAnalyzing ? 'no-hover' : ''}
                      onMouseEnter={(e) => { if (!showAnalyzing) e.currentTarget.style.color = '#000000'; }}
                      onMouseLeave={(e) => { if (!showAnalyzing) e.currentTarget.style.color = s.textMuted; }}
                      style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 16px', background: showAnalyzing ? '#fbbf24' : 'transparent', color: showAnalyzing ? '#000000' : s.textMuted, border: 'none', borderRadius: 16, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                      Analyzing ({analyzingCount})
                    </button>
                  )}
                  <button onClick={() => { setShowPending(false); setShowAnalyzing(false); setShowDone(true); setShowHidden(false); }}
                    className={showDone ? 'no-hover' : ''}
                    onMouseEnter={(e) => { if (!showDone) e.currentTarget.style.color = '#000000'; }}
                    onMouseLeave={(e) => { if (!showDone) e.currentTarget.style.color = s.textMuted; }}
                    style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 16px', background: showDone ? '#68B757' : 'transparent', color: showDone ? '#000000' : s.textMuted, border: 'none', borderRadius: 16, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                    Done ({doneCount})
                  </button>
                  <button onClick={() => { setShowPending(false); setShowAnalyzing(false); setShowDone(false); setShowHidden(true); }}
                    className={showHidden ? 'no-hover' : ''}
                    onMouseEnter={(e) => { if (!showHidden) e.currentTarget.style.color = s.text; }}
                    onMouseLeave={(e) => { if (!showHidden) e.currentTarget.style.color = s.textMuted; }}
                    style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '6px 16px', background: showHidden ? s.bgMid : 'transparent', color: showHidden ? s.text : s.textMuted, border: 'none', borderRadius: 16, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                    Hidden ({hiddenCount})
                  </button>
                </div>
                <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: 8 }}>
                  <div style={{ display: 'inline-flex', background: s.bgDark, borderRadius: 20, padding: 4 }}>
                    <button onClick={async () => {
                      const toReanalyze = filteredQueue.filter(q => !q.hidden);
                      if (toReanalyze.length > 0 && confirm(`Re-analyze all ${toReanalyze.length} images? This will clear cached analysis and start over.`)) {
                        // Clear IndexedDB cache for these images
                        try {
                          for (const img of toReanalyze) {
                            await deleteAnalysis(img.hash);
                          }
                          console.log('[REANALYZE ALL] Cleared IndexedDB cache for', toReanalyze.length, 'images');
                        } catch (e) { console.error('[REANALYZE ALL] Cache clear failed:', e); }

                        // Reset to pending first (required for analyzeImage guard to pass)
                        setQueue(q => q.map(i => {
                          const shouldReanalyze = toReanalyze.find(img => img.id === i.id);
                          return shouldReanalyze ? { ...i, status: 'pending', keywords: [], pending: [] } : i;
                        }));

                        // Start analysis after state update
                        setTimeout(() => {
                          toReanalyze.forEach(img => {
                            analyzeImage({ ...img, status: 'pending', keywords: [], pending: [] });
                          });
                          console.log('[REANALYZE ALL] Started analysis for', toReanalyze.length, 'images');
                        }, 200);
                      }
                    }} disabled={!geminiKey}
                      className='no-hover'
                      style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 6, padding: '6px 16px', background: 'transparent', color: s.textMuted, border: 'none', borderRadius: 16, cursor: geminiKey ? 'pointer' : 'not-allowed', fontSize: s.fontSize, fontWeight: s.fontWeight, opacity: !geminiKey ? 0.5 : 1 }}>
                      Re-Analyze All
                    </button>
                  </div>
                  <div style={{ display: 'inline-flex', background: s.bgDark, borderRadius: 20, padding: 4 }}>
                    <button onClick={() => setAutoScan(!autoScan)} disabled={!geminiKey}
                      className={autoScan ? '' : 'no-hover'}
                      style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 6, padding: '6px 16px', background: autoScan ? s.bgMid : 'transparent', color: autoScan ? s.text : s.textMuted, border: 'none', borderRadius: 16, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight, opacity: !geminiKey ? 0.5 : 1 }}>
                      Auto
                    </button>
                  </div>
                  <div style={{ display: 'inline-flex', background: s.bgDark, borderRadius: 20, padding: 4, gap: 0 }}>
                    {['S', 'M', 'L'].map((label, i) => (
                      <button key={label} onClick={() => setThumbSize(i)}
                        className={thumbSize === i ? 'no-hover' : ''}
                        onMouseEnter={(e) => { if (thumbSize !== i) e.currentTarget.style.color = s.text; }}
                        onMouseLeave={(e) => { if (thumbSize !== i) e.currentTarget.style.color = s.textMuted; }}
                        style={{ padding: '6px 16px', background: thumbSize === i ? s.bgMid : 'transparent', color: thumbSize === i ? s.text : s.textMuted, border: 'none', borderRadius: 16, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                        {label}
                      </button>
                    ))}
                  </div>
                </div>
              </div>
              <div style={{ flex: 1, overflow: 'auto', padding: 12 }}>
                {filteredQueue.length === 0 ? (
                  <div style={{ padding: 60, textAlign: 'center', color: s.muted }}>
                    <Icon name="add_photo_alternate" size={64} style={{ opacity: 0.3, display: 'block', margin: '0 auto 16px' }} />
                    <div style={{ fontSize: s.fontSize, marginBottom: 32 }}>Drop images here</div>
                    <div style={{ fontSize: s.fontSize, color: s.textMuted }}>Use arrow keys to navigate</div>
                  </div>
                ) : (
                  <>
                    {batchProgress && (
                      <div style={{ marginBottom: 32, background: s.bgDark, padding: 12, borderRadius: s.radius }}>
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: 32 }}>
                          <span style={{ fontSize: s.fontSize, color: s.text }}>
                            <Icon name="hourglass_empty" size={16} style={{ marginRight: 6, verticalAlign: 'middle' }} />
                            Processing batch {batchProgress.current}/{batchProgress.total}
                          </span>
                          <span style={{ fontSize: s.fontSize, color: s.text }}>
                            {Math.round((batchProgress.current / batchProgress.total) * 100)}%
                          </span>
                        </div>
                        <div style={{ height: 4, background: s.bgMid, borderRadius: 2, overflow: 'hidden' }}>
                          <div style={{ height: '100%', background: s.text, width: `${(batchProgress.current / batchProgress.total) * 100}%`, transition: 'width 0.3s ease' }} />
                        </div>
                      </div>
                    )}
                    <div style={{ display: 'grid', gridTemplateColumns: `repeat(auto-fill, minmax(${currentThumbSize}px, 1fr))`, gap: 8 }}>
                      {filteredQueue.map(item => (
                        <ThumbnailImage
                          key={item.id}
                          item={item}
                          isSelected={selectedIds.includes(item.id)}
                          onSelect={handleThumbnailClick}
                          onHide={hideImage}
                          onUnhide={unhideImage}
                          thumbSize={currentThumbSize}
                          showPending={showPending}
                          showDone={showDone}
                          showAnalyzing={showAnalyzing}
                          s={s}
                        />
                      ))}
                    </div>
                  </>
                )}
              </div>
            </div>

            {/* RESIZABLE DIVIDER */}
            <div
              onMouseDown={handleDividerMouseDown}
              style={{
                width: 12,
                background: 'transparent',
                cursor: 'col-resize',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                flexShrink: 0,
                transition: 'background 0.15s'
              }}
            />



            {/* CENTER - PREVIEW */}
            <div style={{ flex: 1, minWidth: 280, display: 'flex', flexDirection: 'column', background: s.bgDark }}>
              {selectedImg ? (
                <>
                  <div style={{ height: '35%', minHeight: 140, background: '#000', display: 'flex', alignItems: 'center', justifyContent: 'center', position: 'relative' }}>
                    <img
                      src={selectedImg.url}
                      style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain' }}
                      onLoad={async (e) => {
                        // Auto-detect low quality thumbnails and rebuild them
                        const fullWidth = e.target.naturalWidth;
                        const fullHeight = e.target.naturalHeight;
                        const fileSize = selectedImg.file.size;

                        // Check if this looks like a Dropbox placeholder (low res + small file)
                        const isLowRes = fullWidth < 400 || fullHeight < 400;
                        const isSmallFile = fileSize < 50 * 1024; // 50KB

                        if (isLowRes && isSmallFile) {
                          console.warn(`[AUTO-REBUILD] Detected low quality image: ${selectedImg.name} (${fullWidth}x${fullHeight}, ${(fileSize/1024).toFixed(1)}KB)`);
                          console.log('[AUTO-REBUILD] This appears to be a Dropbox placeholder - regenerating thumbnail...');

                          // Delete the low-quality thumbnail from cache
                          if (window.TaggerPerformance && window.TaggerPerformance.deleteThumbnail) {
                            await window.TaggerPerformance.deleteThumbnail(selectedImg.hash);
                          }

                          // Trigger thumbnail regeneration by updating the queue
                          setQueue(q => q.map(i => i.id === selectedImg.id ? {...i} : i));
                        }
                      }}
                    />
                    <div style={{ position: 'absolute', bottom: 8, left: 8, background: 'rgba(0,0,0,0.85)', padding: '4px 10px', borderRadius: s.radiusSm, color: s.text, fontSize: s.fontSize, maxWidth: '85%', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                      {selectedImg.name}
                    </div>
                    {isMultiSelect && (
                      <div style={{ position: 'absolute', bottom: 8, right: 8, background: s.text, color: '#000', padding: '6px 10px', borderRadius: s.radiusSm, fontSize: s.fontSize, fontWeight: s.fontWeight, display: 'flex', alignItems: 'center', gap: 6 }}>
                        <Icon name="select_all" size={16} /> {selectedIds.length} selected
                      </div>
                    )}
                    {modified && (
                      <div style={{ position: 'absolute', top: 8, right: 8, background: s.text, color: '#000', padding: '4px 8px', borderRadius: s.radiusSm, fontSize: s.fontSize, fontWeight: s.fontWeight, display: 'flex', alignItems: 'center', gap: 4 }}>
                        <Icon name="edit" size={14} /> Unsaved
                      </div>
                    )}
                    {downloadedLarger && (
                      <div style={{ position: 'absolute', top: 8, left: 8, background: s.text, color: '#fff', padding: '4px 8px', borderRadius: s.radiusSm, fontSize: s.fontSize, display: 'flex', alignItems: 'center', gap: 4 }}>
                        <Icon name="download" size={14} /> {(downloadedLarger.size / 1024 / 1024).toFixed(1)}MB
                      </div>
                    )}
                  </div>

                  <div style={{ flex: 1, overflow: 'auto', padding: 14 }}>
                    {selectedImg.status === 'analyzing' && (
                      <div style={{ textAlign: 'center', padding: 40, color: s.muted }}>
                        <Icon name="hourglass_empty" size={36} style={{ display: 'block', margin: '0 auto 12px', color: s.text }} />
                        <div style={{ fontSize: s.fontSize }}>Analyzing...</div>
                      </div>
                    )}

                    {selectedImg.status === 'error' && (
                      <div style={{ textAlign: 'center', padding: 40, color: s.text }}>
                        <Icon name="error" size={36} style={{ display: 'block', margin: '0 auto 12px' }} />
                        <div style={{ fontSize: s.fontSize, marginBottom: 32 }}>Analysis failed</div>
                        <button onClick={() => { setQueue(q => q.map(i => i.id === selectedImg.id ? {...i, status: 'pending'} : i)); analyzeImage({...selectedImg, status: 'pending'}); }}
                          style={{ display: 'inline-flex', alignItems: 'center', gap: 6, padding: '8px 16px', background: s.textMuted, color: 'white', border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                          <Icon name="refresh" size={16} /> Retry
                        </button>
                      </div>
                    )}

                    {(selectedImg.status === 'ready' || selectedImg.status === 'done' || selectedImg.status === 'editing' || isEditing) && (
                      <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
                        {similarCount > 0 && (
                          <div style={{ background: s.bgMid, padding: '10px 12px', borderRadius: s.radius, border: `1px solid ${s.bgMid}` }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: s.text, fontSize: s.fontSize }}>
                              <Icon name="link" size={18} />
                              {similarCount} similar image{similarCount > 1 ? 's' : ''} will sync
                            </div>
                          </div>
                        )}

                        {keywords.length > 0 && (
                          <div style={{ padding: 12 }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#777777', marginBottom: 32, fontSize: s.fontSize }}>
                              <Icon name="sell" size={16} />
                              Tagged ({keywords.length})
                            </div>

                            {/* Show "Applied to All" and "Applied to Some" sections in multi-select mode */}
                            {isMultiSelect ? (
                              <>
                                {/* DEBUG: Show what we have */}
                                {(() => {
                                  const withPartial = keywords.filter(k => k.partialCount);
                                  const withoutPartial = keywords.filter(k => !k.partialCount);
                                  console.log('[UI-RENDER] Keywords with partialCount:', withPartial.length, withPartial.map(k => k.value));
                                  console.log('[UI-RENDER] Keywords without partialCount:', withoutPartial.length, withoutPartial.map(k => k.value));
                                  return null;
                                })()}

                                {keywords.filter(k => !k.partialCount).length > 0 && (
                                  <div style={{ marginBottom: 32 }}>
                                    <div style={{ fontSize: s.fontSize, color: '#777777', marginBottom: 32, fontWeight: s.fontWeight, display: 'flex', alignItems: 'center', gap: 6 }}>
                                      <Icon name="done_all" size={16} />
                                      Applied to All ({keywords.filter(k => !k.partialCount).length})
                                    </div>
                                    <div style={{ color: s.text, fontSize: s.fontSize, lineHeight: s.lineHeight }}>
                                      {keywords.filter(k => !k.partialCount).map((k, idx, arr) => (
                                        <span key={k.id} style={{ display: 'inline-block', whiteSpace: 'nowrap' }}>
                                          {k.source === 'vision' && <Icon name="image_search" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                          {k.source === 'filename' && <Icon name="description" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                          {k.value}
                                          <span onClick={() => removeFromAll(k)} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 4, display: 'inline-flex', verticalAlign: 'middle' }}>
                                            <Icon name="close" size={14} />
                                          </span>
                                          {idx < arr.length - 1 && <span style={{ margin: '0 8px', opacity: 0.5 }}>·</span>}
                                        </span>
                                      ))}
                                    </div>
                                  </div>
                                )}

                                {keywords.filter(k => k.partialCount).length > 0 && (
                                  <div>
                                    <div style={{ fontSize: s.fontSize, color: '#777777', marginBottom: 32, fontWeight: s.fontWeight, display: 'flex', alignItems: 'center', gap: 6, justifyContent: 'space-between' }}>
                                      <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                                        <Icon name="content_copy" size={16} />
                                        Applied to Some ({keywords.filter(k => k.partialCount).length}) - Click to add to all
                                      </div>
                                      <div style={{ display: 'inline-flex', background: '#0F0F0F', borderRadius: 20, padding: 4 }}>
                                        <button onClick={removeAllPartial} style={{ display: 'flex', alignItems: 'center', gap: 4, padding: '6px 16px', background: '#1D1D1D', color: s.text, border: 'none', borderRadius: 16, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                                          Remove All
                                        </button>
                                      </div>
                                    </div>
                                    <div style={{ color: s.text, fontSize: s.fontSize, lineHeight: s.lineHeight }}>
                                      {keywords.filter(k => k.partialCount).map((k, idx, arr) => (
                                        <span key={k.id} style={{ display: 'inline-block', whiteSpace: 'nowrap' }}>
                                          {k.source === 'vision' && <Icon name="image_search" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                          {k.source === 'filename' && <Icon name="description" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                          <span
                                            onClick={(e) => {
                                              if (!e.target.closest('[data-action]')) {
                                                addToAll(k);
                                              }
                                            }}
                                            style={{ cursor: 'pointer', opacity: 0.7 }}
                                            onMouseEnter={(e) => e.currentTarget.style.opacity = '1'}
                                            onMouseLeave={(e) => e.currentTarget.style.opacity = '0.7'}
                                          >
                                            {k.value}
                                          </span>
                                          <span style={{ fontSize: s.fontSize, opacity: 0.6, marginLeft: 4 }}>({k.partialCount}/{selectedIds.length})</span>
                                          <span data-action="remove" onClick={(e) => { e.stopPropagation(); removeKw(k.id); }} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 4, display: 'inline-flex', verticalAlign: 'middle' }}>
                                            <Icon name="close" size={14} />
                                          </span>
                                          {idx < arr.length - 1 && <span style={{ margin: '0 8px', opacity: 0.5 }}>·</span>}
                                        </span>
                                      ))}
                                    </div>
                                  </div>
                                )}
                              </>
                            ) : (
                              <div style={{ color: s.text, fontSize: s.fontSize, lineHeight: s.lineHeight }}>
                                {keywords.map((k, idx) => (
                                  <span key={k.id} style={{ display: 'inline-block', whiteSpace: 'nowrap' }}>
                                    {k.source === 'vision' && <Icon name="image_search" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                    {k.source === 'filename' && <Icon name="description" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                    {k.value}
                                    <span onClick={() => removeKw(k.id)} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 4, display: 'inline-flex', verticalAlign: 'middle' }}>
                                      <Icon name="close" size={14} />
                                    </span>
                                    {idx < keywords.length - 1 && <span style={{ margin: '0 8px', opacity: 0.5 }}>·</span>}
                                  </span>
                                ))}
                              </div>
                            )}
                          </div>
                        )}

                        {/* Custom tag input - dark pill style */}
                        <div style={{ padding: '0 12px' }}>
                          <div style={{ display: 'flex', alignItems: 'center', gap: 8, background: '#0F0F0F', borderRadius: 20, padding: 4 }}>
                            <input type="text" value={customInput} onChange={e => setCustomInput(e.target.value)}
                              onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); addCustom(); } }}
                              placeholder="Add custom tag..."
                              style={{ flex: 1, padding: '6px 16px', background: 'transparent', border: 'none', borderRadius: 16, color: s.text, fontSize: s.fontSize, outline: 'none' }} />
                            <button onClick={addCustom} disabled={!customInput.trim()} tabIndex={-1}
                              style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 4, padding: '6px 16px', background: customInput.trim() ? '#1D1D1D' : 'transparent', color: customInput.trim() ? s.text : s.textMuted, border: 'none', borderRadius: 16, cursor: customInput.trim() ? 'pointer' : 'default', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                              <Icon name="add" size={16} /> Add
                            </button>
                          </div>
                        </div>

                        {pending.length > 0 && (
                          <div style={{ padding: 12 }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 32 }}>
                              <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#777777', fontSize: s.fontSize }}>
                                <Icon name="rate_review" size={16} />
                                {pending.length} to review
                              </div>
                              <div style={{ display: 'inline-flex', background: '#0F0F0F', borderRadius: 20, padding: 4 }}>
                                <button onClick={acceptAll} style={{ display: 'flex', alignItems: 'center', gap: 4, padding: '6px 16px', background: '#1D1D1D', color: s.text, border: 'none', borderRadius: 16, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                                  Accept all
                                </button>
                              </div>
                            </div>

                            {/* Show "Recommended to All" and "Recommended to Some" sections in multi-select mode */}
                            {isMultiSelect ? (
                              <>
                                {pending.filter(k => !k.partialCount).length > 0 && (
                                  <div style={{ marginBottom: 32 }}>
                                    <div style={{ fontSize: s.fontSize, color: '#777777', marginBottom: 32, fontWeight: s.fontWeight, display: 'flex', alignItems: 'center', gap: 6 }}>
                                      <Icon name="recommend" size={16} />
                                      Recommended to All ({pending.filter(k => !k.partialCount).length})
                                    </div>
                                    <div style={{ color: s.text, fontSize: s.fontSize, lineHeight: s.lineHeight }}>
                                      {pending.filter(k => !k.partialCount).map((k, idx, arr) => (
                                        <span key={k.id} style={{ display: 'inline-block', whiteSpace: 'nowrap' }}>
                                          {k.source === 'vision' && <Icon name="image_search" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                          {k.source === 'filename' && <Icon name="description" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                          <span
                                            onClick={(e) => {
                                              if (!e.target.closest('[data-action]')) accept(k.id);
                                            }}
                                            style={{ cursor: 'pointer' }}
                                          >
                                            {k.value}
                                          </span>
                                          <span data-action="block" onClick={(e) => { e.stopPropagation(); block(k.id); }} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 4, display: 'inline-flex', verticalAlign: 'middle' }}>
                                            <Icon name="block" size={14} />
                                          </span>
                                          {idx < arr.length - 1 && <span style={{ margin: '0 8px', opacity: 0.5 }}>·</span>}
                                        </span>
                                      ))}
                                    </div>
                                  </div>
                                )}

                                {pending.filter(k => k.partialCount).length > 0 && (
                                  <div>
                                    <div style={{ fontSize: s.fontSize, color: '#777777', marginBottom: 32, fontWeight: s.fontWeight, display: 'flex', alignItems: 'center', gap: 6 }}>
                                      <Icon name="exposure" size={16} />
                                      Recommended to Some ({pending.filter(k => k.partialCount).length})
                                    </div>
                                    <div style={{ color: s.text, fontSize: s.fontSize, lineHeight: s.lineHeight }}>
                                      {pending.filter(k => k.partialCount).map((k, idx, arr) => (
                                        <span key={k.id} style={{ display: 'inline-block', whiteSpace: 'nowrap' }}>
                                          {k.source === 'vision' && <Icon name="image_search" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                          {k.source === 'filename' && <Icon name="description" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                          <span
                                            onClick={(e) => {
                                              if (!e.target.closest('[data-action]')) accept(k.id);
                                            }}
                                            style={{ cursor: 'pointer', opacity: 0.7 }}
                                            onMouseEnter={(e) => e.currentTarget.style.opacity = '1'}
                                            onMouseLeave={(e) => e.currentTarget.style.opacity = '0.7'}
                                          >
                                            {k.value}
                                          </span>
                                          <span style={{ fontSize: s.fontSize, opacity: 0.6, marginLeft: 4 }}>({k.partialCount}/{selectedIds.length})</span>
                                          <span data-action="block" onClick={(e) => { e.stopPropagation(); block(k.id); }} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 4, display: 'inline-flex', verticalAlign: 'middle' }}>
                                            <Icon name="block" size={14} />
                                          </span>
                                          {idx < arr.length - 1 && <span style={{ margin: '0 8px', opacity: 0.5 }}>·</span>}
                                        </span>
                                      ))}
                                    </div>
                                  </div>
                                )}
                              </>
                            ) : (
                              <div style={{ color: s.text, fontSize: s.fontSize, lineHeight: s.lineHeight }}>
                                {pending.map((k, idx) => (
                                  <span key={k.id} style={{ display: 'inline-block', whiteSpace: 'nowrap' }}>
                                    {k.source === 'vision' && <Icon name="image_search" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                    {k.source === 'filename' && <Icon name="description" size={14} style={{ display: 'inline-flex', verticalAlign: 'middle', marginRight: 4 }} />}
                                    <span
                                      onClick={(e) => {
                                        if (!e.target.closest('[data-action]')) accept(k.id);
                                      }}
                                      style={{ cursor: 'pointer' }}
                                    >
                                      {k.value}
                                    </span>
                                    <span data-action="block" onClick={(e) => { e.stopPropagation(); block(k.id); }} style={{ cursor: 'pointer', opacity: 0.6, marginLeft: 4, display: 'inline-flex', verticalAlign: 'middle' }}>
                                      <Icon name="block" size={14} />
                                    </span>
                                    {idx < pending.length - 1 && <span style={{ margin: '0 8px', opacity: 0.5 }}>·</span>}
                                  </span>
                                ))}
                              </div>
                            )}
                          </div>
                        )}

                        {/* Save button - pill shaped */}
                        <div style={{ padding: '0 12px', display: 'flex', justifyContent: 'center' }}>
                          <button
                          onClick={async () => {
                            // Check for required category
                            const hasRequiredCategory = keywords.some(k => REQUIRED_CATEGORIES.includes(k.value));
                            if (!hasRequiredCategory) {
                              alert('Please select at least one primary category (Industrial Design, Graphic Design, Art, Photography, or Architecture) before saving.');
                              return;
                            }
                            if (keywords.length === 0) return;
                            // Handle multi-select
                            if (selectedIds.length > 1) {
                              console.log('[SAVE BUTTON] Saving', selectedIds.length, 'selected images');
                              const selectedImages = queue.filter(q => selectedIds.includes(q.id));
                              for (const img of selectedImages) {
                                await saveImage(img, keywords, designer, true); // skipSync=true for batch
                              }
                            } else {
                              await saveImage(selectedImg, keywords, designer);
                            }
                          }}
                          tabIndex={-1}
                          style={{
                            minWidth: '25%',
                            display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 6, padding: '6px 16px',
                            background: keywords.length > 0 && keywords.some(k => REQUIRED_CATEGORIES.includes(k.value)) ? s.blue : s.bgMid,
                            color: keywords.length > 0 && keywords.some(k => REQUIRED_CATEGORIES.includes(k.value)) ? '#FFFFFF' : s.textMuted,
                            border: 'none', borderRadius: 16,
                            cursor: 'pointer',
                            fontSize: s.fontSize, fontWeight: s.fontWeight
                          }}>
                          {keywords.length > 0 && keywords.some(k => REQUIRED_CATEGORIES.includes(k.value))
                            ? `Save${selectedIds.length > 1 ? ` (${selectedIds.length} images)` : similarCount > 0 ? ` + ${similarCount} similar` : ''}`
                            : keywords.length === 0 ? 'Nothing to save' : 'Select primary category'}
                        </button>
                        </div>
                      </div>
                    )}

                    {selectedImg.status === 'pending' && (
                      <div style={{ textAlign: 'center', padding: 40, color: s.muted }}>
                        <button onClick={() => analyzeImage(selectedImg)} tabIndex={-1}
                          style={{ display: 'inline-flex', alignItems: 'center', gap: 8, padding: '12px 24px', background: s.textMuted, color: 'white', border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                          <Icon name="auto_awesome" size={20} /> Analyze
                        </button>
                      </div>
                    )}
                  </div>
                </>
              ) : (
                <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', color: s.muted }}>
                  <div style={{ textAlign: 'center' }}>
                    <Icon name="image" size={64} style={{ opacity: 0.2, display: 'block', margin: '0 auto 16px' }} />
                    <div style={{ fontSize: s.fontSize }}>Select an image</div>
                    <div style={{ fontSize: s.fontSize, marginTop: 8, color: s.textMuted }}>Use arrow keys to navigate</div>
                  </div>
                </div>
              )}
            </div>

            {/* RIGHT - TAXONOMY */}
            <div style={{ width: 375, minWidth: 280, flexShrink: 0, background: s.bgMedium, borderLeft: `2px solid ${s.border}`, display: 'flex', flexDirection: 'column' }}>
              <div style={{ padding: '14px 16px', borderBottom: `2px solid ${s.border}` }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 32 }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 8, color: s.bright, fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                    Keywords
                  </div>
                  <div style={{ display: 'flex', gap: 6 }}>
                    {customCount > 0 && showMasterTaxonomy && (
                      <button onClick={runCategorization} disabled={isCategorizing || !geminiKey} tabIndex={-1}
                        style={{ display: 'flex', alignItems: 'center', gap: 4, padding: '6px 10px', background: isCategorizing ? s.bgDark : s.text, color: isCategorizing ? s.text : s.bgDark, border: 'none', borderRadius: s.radiusSm, cursor: isCategorizing ? 'default' : 'pointer', fontSize: s.fontSize }}>
                        <Icon name={isCategorizing ? "hourglass_empty" : "auto_fix_high"} size={16} /> {customCount}
                      </button>
                    )}
                    <div style={{ display: 'inline-flex', background: s.bgDark, borderRadius: 20, padding: 4, gap: 0 }}>
                      {[{ label: 'Session', value: false }, { label: 'Master', value: true }].map(({ label, value }) => (
                        <button key={label} onClick={() => setShowMasterTaxonomy(value)} tabIndex={-1}
                          className={showMasterTaxonomy === value ? 'no-hover' : ''}
                          onMouseEnter={(e) => { if (showMasterTaxonomy !== value) e.currentTarget.style.color = s.text; }}
                          onMouseLeave={(e) => { if (showMasterTaxonomy !== value) e.currentTarget.style.color = s.textMuted; }}
                          style={{ padding: '6px 16px', background: showMasterTaxonomy === value ? s.bgMid : 'transparent', color: showMasterTaxonomy === value ? s.text : s.textMuted, border: 'none', borderRadius: 16, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                          {label}
                        </button>
                      ))}
                    </div>
                  </div>
                </div>
                <div style={{ display: 'flex', justifyContent: 'flex-end' }}>
                  <div style={{ display: 'inline-flex', background: s.bgDark, borderRadius: 20, padding: 4 }}>
                    <button
                      onClick={handleOrganizeTaxonomy}
                      disabled={!geminiKey || isOrganizing}
                      title="Organize taxonomy - research and categorize custom keywords"
                      tabIndex={-1}
                      className="no-hover"
                      style={{
                        display: 'flex', alignItems: 'center', gap: 6,
                        padding: '6px 16px', background: s.bgMid,
                        color: s.text, border: 'none',
                        borderRadius: 16, cursor: isOrganizing ? 'default' : 'pointer',
                        fontSize: s.fontSize, fontWeight: s.fontWeight
                      }}
                    >
                      {isOrganizing ? 'Organizing...' : 'Organize'}
                    </button>
                  </div>
                </div>
              </div>
              <div style={{ flex: 1, padding: 12, overflowY: 'auto' }}>
                {showMasterTaxonomy ? (
                  <div style={{ fontSize: s.fontSize }}>
                    <div style={{ color: s.muted, marginBottom: 32 }}>Master dictionary ({taxInfo.allTerms.size} terms)</div>
                    {Object.entries(taxonomy).map(([name, value]) => (
                      <MasterTaxonomyNode key={name} name={name} value={value} depth={0} expanded={expanded}
                        onToggle={p => setExpanded(e => ({ ...e, [p]: e[p] === false ? true : false }))}
                        onDelete={deleteFromMasterTaxonomy} s={s} />
                    ))}
                  </div>
                ) : Object.keys(tree).length === 0 ? (
                  <div style={{ textAlign: 'center', padding: 32, color: s.muted }}>
                    <Icon name="folder_open" size={40} style={{ opacity: 0.3, display: 'block', margin: '0 auto 12px' }} />
                    <div style={{ fontSize: s.fontSize, marginBottom: 32 }}>Empty</div>
                    <div style={{ fontSize: s.fontSize, color: s.textMuted }}>Analyze images to build taxonomy</div>
                  </div>
                ) : (
                  // Sort to put Custom/Uncategorized at top (grey), then alphabetically
                  Object.entries(tree)
                    .sort(([a], [b]) => {
                      const aIsUncategorized = a === 'Custom' || a === 'Uncategorized';
                      const bIsUncategorized = b === 'Custom' || b === 'Uncategorized';
                      if (aIsUncategorized && !bIsUncategorized) return -1;
                      if (!aIsUncategorized && bIsUncategorized) return 1;
                      return a.localeCompare(b);
                    })
                    .map(([name, node]) => (
                      <TreeNode key={name} name={name} node={node} depth={0} expanded={expanded}
                        onToggle={p => setExpanded(e => ({ ...e, [p]: e[p] === false ? true : false }))}
                        onDeleteKeyword={deleteFromTaxonomy} s={s} />
                    ))
                )}
              </div>
            </div>
          </div>

          {/* SETTINGS */}
          <AnimatePresence>
            {showSettings && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                onClick={() => setShowSettings(false)}
                style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.75)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 200 }}>
                <motion.div
                  initial={{ opacity: 0, scale: 0.95, y: 20 }}
                  animate={{ opacity: 1, scale: 1, y: 0 }}
                  exit={{ opacity: 0, scale: 0.95, y: 20 }}
                  onClick={e => e.stopPropagation()}
                  style={{ background: s.panel, borderRadius: s.radiusLg, width: 480, maxHeight: '85vh', overflow: 'auto', border: `1px solid ${s.border}`, boxShadow: '0 25px 50px -12px rgba(0,0,0,0.5)' }}>
                  <div style={{ padding: '18px 20px', borderBottom: `1px solid ${s.border}`, display: 'flex', alignItems: 'center', gap: 10 }}>
                    <Icon name="settings" size={22} style={{ color: s.muted }} />
                    <span style={{ color: s.bright, fontSize: s.fontSize, fontWeight: s.fontWeight }}>Settings</span>
                  </div>
                  <div style={{ padding: 20, display: 'flex', flexDirection: 'column', gap: 20 }}>
                    <div>
                      <div style={{ marginBottom: 32, color: s.text, fontSize: s.fontSize, fontWeight: s.fontWeight }}>Gemini API Key</div>
                      <input type="password" value={geminiKey} onChange={e => setGeminiKey(e.target.value)}
                        style={{ width: '100%', padding: '10px 14px', background: s.bg, border: `1px solid ${s.border}`, borderRadius: s.radius, color: s.bright, fontSize: s.fontSize, outline: 'none' }} />
                      <a href="https://aistudio.google.com/apikey" target="_blank" rel="noreferrer" style={{ display: 'inline-flex', alignItems: 'center', gap: 4, color: s.text, fontSize: s.fontSize, marginTop: 6, textDecoration: 'none' }}>
                        Get API key <Icon name="open_in_new" size={14} />
                      </a>
                    </div>
                    <div>
                      <div style={{ marginBottom: 32, color: s.text, fontSize: s.fontSize, fontWeight: s.fontWeight }}>Vision API Key (optional)</div>
                      <input type="password" value={visionKey} onChange={e => setVisionKey(e.target.value)}
                        style={{ width: '100%', padding: '10px 14px', background: s.bg, border: `1px solid ${s.border}`, borderRadius: s.radius, color: s.bright, fontSize: s.fontSize, outline: 'none' }} />
                      <a href="https://console.cloud.google.com/apis/library/vision.googleapis.com" target="_blank" rel="noreferrer" style={{ display: 'inline-flex', alignItems: 'center', gap: 4, color: s.text, fontSize: s.fontSize, marginTop: 6, textDecoration: 'none' }}>
                        Enable Vision API <Icon name="open_in_new" size={14} />
                      </a>
                    </div>

                    <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
                      <label style={{ display: 'flex', alignItems: 'center', gap: 12, cursor: 'pointer', padding: '10px 14px', background: s.bg, borderRadius: s.radius }}>
                        <input type="checkbox" checked={useVision} onChange={e => setUseVision(e.target.checked)} style={{ width: 18, height: 18, accentColor: s.text }} />
                        <div>
                          <div style={{ fontSize: s.fontSize, color: s.bright }}>Use Vision API for reverse image search</div>
                          <div style={{ fontSize: s.fontSize, color: s.muted }}>Find web matches and similar images</div>
                        </div>
                      </label>
                      <label style={{ display: 'flex', alignItems: 'center', gap: 12, cursor: 'pointer', padding: '10px 14px', background: s.bg, borderRadius: s.radius }}>
                        <input type="checkbox" checked={autoDownloadLarger} onChange={e => setAutoDownloadLarger(e.target.checked)} style={{ width: 18, height: 18, accentColor: s.text }} />
                        <div>
                          <div style={{ fontSize: s.fontSize, color: s.bright }}>Auto-download larger versions</div>
                          <div style={{ fontSize: s.fontSize, color: s.muted }}>Requires output folder to be set</div>
                        </div>
                      </label>
                    </div>

                    <div>
                      <div style={{ marginBottom: 32, color: s.text, fontSize: s.fontSize, fontWeight: s.fontWeight }}>Save Mode</div>
                      <div style={{ display: 'flex', gap: 12 }}>
                        <label style={{ flex: 1, padding: '14px 16px', border: `2px solid ${saveMode === 'embed' ? s.text : s.border}`, background: saveMode === 'embed' ? s.bgMid : 'transparent', borderRadius: s.radius, cursor: 'pointer', display: 'flex', alignItems: 'center', gap: 10 }}>
                          <input type="radio" checked={saveMode === 'embed'} onChange={() => setSaveMode('embed')} style={{ width: 18, height: 18, accentColor: s.text }} />
                          <div>
                            <div style={{ fontSize: s.fontSize, color: s.bright }}>Embed XMP</div>
                            <div style={{ fontSize: s.fontSize, color: s.muted }}>Write metadata into file</div>
                          </div>
                        </label>
                        <label style={{ flex: 1, padding: '14px 16px', border: `2px solid ${saveMode === 'sidecar' ? s.text : s.border}`, background: saveMode === 'sidecar' ? s.bgMid : 'transparent', borderRadius: s.radius, cursor: 'pointer', display: 'flex', alignItems: 'center', gap: 10 }}>
                          <input type="radio" checked={saveMode === 'sidecar'} onChange={() => setSaveMode('sidecar')} style={{ width: 18, height: 18, accentColor: s.text }} />
                          <div>
                            <div style={{ fontSize: s.fontSize, color: s.bright }}>Sidecar .xmp</div>
                            <div style={{ fontSize: s.fontSize, color: s.muted }}>Create separate file</div>
                          </div>
                        </label>
                      </div>
                    </div>

                    <button onClick={async () => { try { setOutputDir(await window.showDirectoryPicker({ mode: 'readwrite' })); } catch {} }}
                      style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 8, padding: '12px 16px', background: outputDir ? 'rgba(16,185,129,0.15)' : (outputDirName ? s.bgMid : s.bgDark), color: outputDir ? s.text : (outputDirName ? s.text : s.text), border: `1px solid ${outputDir ? 'rgba(16,185,129,0.3)' : (outputDirName ? 'rgba(251,191,36,0.3)' : s.border)}`, borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize }}>
                      <Icon name={outputDir ? "check_circle" : (outputDirName ? "warning" : "folder_open")} size={20} />
                      {outputDir ? `Output: ${outputDir.name}` : (outputDirName ? `Re-select: ${outputDirName}` : 'Choose output folder')}
                    </button>
                  </div>
                  <div style={{ padding: '16px 20px', borderTop: `1px solid ${s.border}`, display: 'flex', justifyContent: 'flex-end' }}>
                    <button onClick={() => setShowSettings(false)} style={{ display: 'flex', alignItems: 'center', gap: 6, padding: '10px 20px', background: s.textMuted, color: 'white', border: 'none', borderRadius: s.radius, cursor: 'pointer', fontSize: s.fontSize, fontWeight: s.fontWeight }}>
                      Done
                    </button>
                  </div>
                </motion.div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
